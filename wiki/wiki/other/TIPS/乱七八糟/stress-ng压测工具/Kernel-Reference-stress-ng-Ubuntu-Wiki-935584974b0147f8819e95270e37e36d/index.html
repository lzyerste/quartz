<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="Kernel/Reference/stress-ng - Ubuntu Wiki  https://wiki.ubuntu.com/Kernel/Reference/stress-ng
Introduction stress-ng will stress test a computer system in various selectable ways. It was designed to exercise various physical subsystems of a computer as well as the various operating system kernel interfaces."><title>Kernel_Reference_stress-ng_-_Ubuntu_Wiki_935584974b0147f8819e95270e37e36d</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://lzyerste.github.io/quartz//icon.png><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Source+Sans+Pro:wght@400;600;700&family=Fira+Code:wght@400;700&display=swap" rel=stylesheet><link href=https://lzyerste.github.io/quartz/styles.48db36360688fe00f0a39f3cf1417c4b.min.css rel=stylesheet><script src=https://lzyerste.github.io/quartz/js/darkmode.46b07878b7f5d9e26ad7a3c40f8a0605.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})})</script><script>const BASE_URL="https://lzyerste.github.io/quartz/",fetchData=Promise.all([fetch("https://lzyerste.github.io/quartz/indices/linkIndex.1d754d57933a311cf3815175a0b0ad85.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://lzyerste.github.io/quartz/indices/contentIndex.717e0dd7754846023944b8377a42e13a.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n}))</script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://lzyerste.github.io/quartz/js/search.7861a82db330f0a40935b7458fee3a02.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://lzyerste.github.io/quartz/>ðŸª´ Quartz 3.2</a></h1><svg tabindex="0" id="search-icon" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg><div class=spacer></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Kernel_Reference_stress-ng_-_Ubuntu_Wiki_935584974b0147f8819e95270e37e36d</h1><p class=meta>Last updated Unknown</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#introduction>Introduction</a></li><li><a href=#a-simple-example>A simple example</a></li><li><a href=#bogo-ops>Bogo Ops</a></li><li><a href=#running-many-stressors>Running many stressors</a></li><li><a href=#how-hot>How hot?</a></li><li><a href=#more-stressy>More stressy</a></li><li><a href=#verbose-mode>Verbose mode</a></li><li><a href=#classes>Classes</a></li><li><a href=#worked-examples>Worked Examples</a><ol><li><a href=#getting-the-cpu-hot>Getting the CPU hot</a></li><li><a href=#forcing-memory-pressure>Forcing memory pressure</a></li></ol></li><li><a href=#methods>Methods</a></li><li><a href=#verify-mode>Verify mode</a></li><li><a href=#causing-more-virtual-memory-vm-stress>Causing More Virtual Memory (VM) Stress</a></li><li><a href=#generating-a-large-interrupt-load>Generating a large interrupt load</a></li><li><a href=#generating-major-page-faults>Generating major page faults</a></li></ol></nav></details></aside><h1 id=kernelreferencestress-ng---ubuntu-wiki>Kernel/Reference/stress-ng - Ubuntu Wiki</h1><p><a href=https://wiki.ubuntu.com/Kernel/Reference/stress-ng rel=noopener>https://wiki.ubuntu.com/Kernel/Reference/stress-ng</a></p><h2 id=introduction>Introduction</h2><p>stress-ng will stress test a computer system in various selectable ways. It was designed to exercise various physical subsystems of a computer as well as the various operating system kernel interfaces. stress-ng also has a wide range of CPU specific stress tests that exercise floating point, integer, bit manipulation and control flow.</p><p>stress-ng was originally intended to make a machine work hard and trip hardware issues such as thermal overruns as well as operating system bugs that only occur when a system is being thrashed hard. Use stress-ng with caution as some of the tests can make a system run hot on poorly designed hardware and also can cause excessive system thrashing which may be difficult to stop.</p><p>The tool has a wide range of different stress mechanisms (known as &ldquo;stressors&rdquo;) and a full description of these is included in the man page. This document is a quick-start reference guide and covers some of the more typical use cases for stress-ng.</p><h2 id=a-simple-example>A simple example</h2><p>The matrix stressor is a good way to exercise the CPU floating point operations as well as memory and processor data cache. Of all the tests, this one generally heats x86 CPUs the best.</p><p>To run 1 instance of this for 60 seconds, use:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --matrix 1 -t 1m
</span></span></code></pre></td></tr></table></div></div><p>If you want to run an instance of this on ALL the CPUs on your machine, specify 0 instances and stress-ng will figure out how many to run:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --matrix 0 -t 1m
</span></span></code></pre></td></tr></table></div></div><p>You can get an idea of how much user time and system (kernel) time is being used via the &ndash;times option:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --matrix 0 -t 1m --times
</span></span><span class=line><span class=cl>stress-ng: info:  [16783] dispatching hogs: 4 matrix
</span></span><span class=line><span class=cl>stress-ng: info:  [16783] successful run completed in 60.00s (1 min, 0.00 secs)
</span></span><span class=line><span class=cl>stress-ng: info:  [16783] for a 60.00s run time:
</span></span><span class=line><span class=cl>stress-ng: info:  [16783]     240.00s available CPU time
</span></span><span class=line><span class=cl>stress-ng: info:  [16783]     205.21s user time   ( 85.50%)
</span></span><span class=line><span class=cl>stress-ng: info:  [16783]       0.32s system time (  0.13%)
</span></span><span class=line><span class=cl>stress-ng: info:  [16783]     205.53s total time  ( 85.64%)
</span></span></code></pre></td></tr></table></div></div><p>In the above example, I ran this on a machine that wasn&rsquo;t particularly idle with 4 CPU threads, so 4 instances were executed. The total CPU time was 4 x 60 seconds (240 seconds), of which 0.13% was in the kernel, and 85.50% in user time and stress-ng only got 85.64% of all the CPUs (since the machine was a bit busy doing other work at the same time).</p><p>Now consider a more interesting stress test, such as passing messages between processes using a POSIX message queue. We can run the mq stressor with the &ndash;perf option to see some more detail on what the machine is doing during the run:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --mq 0 -t 30s --times --perf
</span></span><span class=line><span class=cl>stress-ng: info:  [16973] dispatching hogs: 4 mq
</span></span><span class=line><span class=cl>stress-ng: info:  [16973] successful run completed in 30.00s
</span></span><span class=line><span class=cl>stress-ng: info:  [16973] mq:
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]            290,423,383,332 CPU Cycles                     9.68 B/sec
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]            223,288,693,644 Instructions                   7.44 B/sec (0.769 instr. per cycle)
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]                138,916,980 Cache References               4.63 M/sec
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]                  5,305,248 Cache Misses                   0.18 M/sec ( 3.82%)
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]            183,625,100,272 Stalled Cycles Frontend        6.12 B/sec
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]             42,638,257,404 Branch Instructions            1.42 B/sec
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]                167,682,072 Branch Misses                  5.59 M/sec ( 0.39%)
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]             10,231,977,988 Bus Cycles                     0.34 B/sec
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]            256,043,743,440 Total Cycles                   8.53 B/sec
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]                        176 Page Faults Minor              5.87 sec  
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]                          0 Page Faults Major              0.00 sec  
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]                 22,901,328 Context Switches               0.76 M/sec
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]                        952 CPU Migrations                31.73 sec  
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]                          0 Alignment Faults               0.00 sec  
</span></span><span class=line><span class=cl>stress-ng: info:  [16973] for a 30.00s run time:
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]     120.02s available CPU time
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]      11.26s user time   (  9.38%)
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]      93.84s system time ( 78.19%)
</span></span><span class=line><span class=cl>stress-ng: info:  [16973]     105.10s total time  ( 87.57%)
</span></span><span class=line><span class=cl>stress-ng: info:  [16973] load average: 3.72 1.67 1.42
</span></span></code></pre></td></tr></table></div></div><p>So we can see here that the mq stressor is forcing the processes to context switch at around 0.76 million per second, and we&rsquo;re getting quite low data cache misses.</p><h2 id=bogo-ops>Bogo Ops</h2><p>Stress-ng measures a stress test &ldquo;throughput&rdquo; using &ldquo;bogus operations per second&rdquo;. The size of a bogo op depends on the stressor being run, and are not comparable between different stressors. They give some rough notion of performance but should not be used as an accurate benchmarking figure. They are useful to see if performance changes between kernel versions or different compiler versions used to build stress-ng. One can also use them to get a notional rough comparison of performance between different systems. But caveat emptor: they are NOT intended to be a scientifically accurate benchmarking metric.</p><p>Use the &ndash;metrics-brief option to show the bogo ops. Let&rsquo;s see how the matrix stressor fares on a i5-3210M laptop:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --matrix 0 -t 60s --metrics-brief
</span></span><span class=line><span class=cl>stress-ng: info:  [17579] dispatching hogs: 4 matrix
</span></span><span class=line><span class=cl>stress-ng: info:  [17579] successful run completed in 60.01s (1 min, 0.01 secs)
</span></span><span class=line><span class=cl>stress-ng: info:  [17579] stressor      bogo ops real time  usr time  sys time   bogo ops/s   bogo ops/s
</span></span><span class=line><span class=cl>stress-ng: info:  [17579]                          (secs)    (secs)    (secs)   (real time) (usr+sys time)
</span></span><span class=line><span class=cl>stress-ng: info:  [17579] matrix          349322     60.00    203.23      0.19      5822.03      1717.25
</span></span></code></pre></td></tr></table></div></div><p>&mldr;we are primarily interested in the bogo/ops (real time) rate, that is, the total bogo ops measured divided by the total run time.</p><p>..and now run it on a 48 thread Xeon(R) CPU E5-2680 server:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --matrix 0 -t 60s --metrics-brief
</span></span><span class=line><span class=cl>stress-ng: info:  [113534] dispatching hogs: 48 matrix
</span></span><span class=line><span class=cl>stress-ng: info:  [113534] successful run completed in 60.01s (1 min, 0.01 secs)
</span></span><span class=line><span class=cl>stress-ng: info:  [113534] stressor      bogo ops real time  usr time  sys time   bogo ops/s   bogo ops/s
</span></span><span class=line><span class=cl>stress-ng: info:  [113534]                          (secs)    (secs)    (secs)   (real time) (usr+sys time)
</span></span><span class=line><span class=cl>stress-ng: info:  [113534] matrix         6594214     60.00   2882.38      0.02    109903.67      2287.75
</span></span></code></pre></td></tr></table></div></div><p>so 5822.03 vs 109903.67, the Xeon server has 12 more threads and has about 18.8 x more throughput on this specific stress test.</p><h2 id=running-many-stressors>Running many stressors</h2><p>stress-ng can run more than one stress test. By default it will run the requested stressors in parallel, for example, running 2 instances of the CPU stressor, 1 instance of the matrix stressor and 3 instances of the message queue stressor in parallel for 5 minutes:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --cpu 2 --matrix 1 --mq 3 -t 5m
</span></span></code></pre></td></tr></table></div></div><p>One can invoke all the stress tests to run in parallel, with the &ndash;all option. The following example will run 2 instances of each of all the stress tests in parallel:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --all 2
</span></span></code></pre></td></tr></table></div></div><p>Or, alternatively, run each different stressor sequentially. The following example will run 4 instances of each stress test at a time, for 20 seconds for each stressor:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --seq 4 -t 20
</span></span></code></pre></td></tr></table></div></div><p>One may want to exclude specific stressors from the &ndash;all and &ndash;seq options, one can do that with the -x option:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --seq 1 -x numa,matrix,hdd
</span></span></code></pre></td></tr></table></div></div><p>&mldr;this will run all the stressors except for the numa, matrix and hdd stressor.</p><h2 id=how-hot>How hot?</h2><p>If you machine supports thermal zones, then stress-ng can report on the temperature at the end of a run with the &ndash;tz option, for example, 60 seconds of the CPU stressor:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --cpu 0 --tz -t 60
</span></span><span class=line><span class=cl>stress-ng: info:  [18065] dispatching hogs: 4 cpu
</span></span><span class=line><span class=cl>stress-ng: info:  [18065] successful run completed in 60.07s (1 min, 0.07 secs)
</span></span><span class=line><span class=cl>stress-ng: info:  [18065] cpu:
</span></span><span class=line><span class=cl>stress-ng: info:  [18065]         x86_pkg_temp   88.75 Â°C
</span></span><span class=line><span class=cl>stress-ng: info:  [18065]               acpitz   88.38 Â°C
</span></span></code></pre></td></tr></table></div></div><h2 id=more-stressy>More stressy</h2><p>The &ndash;aggressive option cranks up the stress by enabling more file, cache and memory aggressive options in the stress tests if they are available. It will also force processes to jump around between CPUs which will stress SMP and NUMA systems further.</p><p>Stressors are configured to run with default settings, such as memory sizes, cache sizes, file sizes etc. The &ndash;maximize option forces stressors to use the largest settings that are sanely possible, causing more stress, for example more I/O and considerably more paging.</p><p>Running stress-ng with root privilege is even more aggressive since stress-ng will change scheduling priorities and will maximize itself to the ulimit limits. Don&rsquo;t use this unless you are willing to totally lock up a machine.</p><h2 id=verbose-mode>Verbose mode</h2><p>The -v option will enable verbose mode. This will show some extra debug information in case you want to see what stress-ng is doing.</p><h2 id=classes>Classes</h2><p>The stress-ng stressors are grouped together in different classes:</p><ul><li>cpu - CPU intensive</li><li>cpu-cache - stress CPU instruction and/or data caches</li><li>device - raw device driver stressors</li><li>io - generic input/output</li><li>interrupt - high interrupt load generators</li><li>filesystem - file system activity</li><li>memory - stack, heap, memory mapping, shared memory stressors</li><li>network - TCP/IP, UDP and UNIX domain socket stressors</li><li>os - core kernel stressors</li><li>pipe - pipe and UNIX socket stressors</li><li>scheduler - force high levels of context switching</li><li>vm - Virtual Memory stressor (paging and memory)</li></ul><p>stressors may be in one or more classes, for example, the lsearch (linear search) stressor is in the cpu-cache, cpu and memory classes as it touches all these three activities.</p><p>For example, to run all the stress tests in parallel under a the network class, with 1 instance of each being run, use:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --class network --all 1
</span></span></code></pre></td></tr></table></div></div><p>..or to run all the networking class stressors one by one with an instance of each being run on ALL cpus, use:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --class network --seq 0
</span></span></code></pre></td></tr></table></div></div><h2 id=worked-examples>Worked Examples</h2><h3 id=getting-the-cpu-hot>Getting the CPU hot</h3><p>The matrix stressor is generally best for this. Using the &ndash;matrix-size option we can set the N x N size of the matrix of floating point values being operated on inside the stressor. Generally it is best to match the number if instances with the number of CPUs.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --matrix 0 --matrix-size 64 --tz  -t 60
</span></span><span class=line><span class=cl>stress-ng: info:  [18351] dispatching hogs: 4 matrix
</span></span><span class=line><span class=cl>stress-ng: info:  [18351] successful run completed in 60.00s (1 min, 0.00 secs)
</span></span><span class=line><span class=cl>stress-ng: info:  [18351] matrix:
</span></span><span class=line><span class=cl>stress-ng: info:  [18351]         x86_pkg_temp   88.00 Â°C
</span></span><span class=line><span class=cl>stress-ng: info:  [18351]               acpitz   87.00 Â°C
</span></span></code></pre></td></tr></table></div></div><p>In the above example, the x86 processor package thermal zone reached 88 degress Celsius. You may wish to change the matrix size and run time to see how hot you can get the CPU. I believe making the size small enough to fit into the L2 cache may be best, but it depends on the machine.</p><h3 id=forcing-memory-pressure>Forcing memory pressure</h3><p>Running out of memory is a great way to see what happens to applications and the kernel. stress-ng has found several bugs in applications, daemons and kernel drivers when memory has run low and code does not check for memory allocation failures correctly.</p><p>The &ndash;brk (expand heap break point), &ndash;stack (expand stack), &ndash;bigheap stressors try to rapidly consume memory. The kernel will eventually kill these using the Out Of Memory (OOM) killer, however, stress-ng will respawn the processes to keep the kernel busy. On a system with swap enabled the swap device will be heavily exercised. One can try running this with swap disabled using swapoff -a before invoking stress-ng.</p><p>Example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --brk 2 --stack 2 --bigheap 2
</span></span></code></pre></td></tr></table></div></div><h2 id=methods>Methods</h2><p>Some stressors contain more than one method of causing stress. For example, the cpu stress test contains a wide range of ways to exercise a CPU; these are known as &ldquo;methods&rdquo;. You can see all the methods using the &ldquo;which&rdquo; operator:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --cpu-method which
</span></span><span class=line><span class=cl>cpu-method must be one of: all ackermann bitops callfunc cdouble cfloat clongdouble 
</span></span><span class=line><span class=cl>correlate crc16 decimal32 decimal64 decimal128 dither djb2a double euler explog fft 
</span></span><span class=line><span class=cl>fibonacci float fnv1a gamma gcd gray hamming hanoi hyperbolic idct int128 int64 int32 
</span></span><span class=line><span class=cl>int16 int8 int128float int128double int128longdouble int128decimal32 int128decimal64 
</span></span><span class=line><span class=cl>int128decimal128 int64float int64double int64longdouble int32float int32double 
</span></span><span class=line><span class=cl>int32longdouble jenkin jmp ln2 longdouble loop matrixprod nsqrt omega parity phi pi 
</span></span><span class=line><span class=cl>pjw prime psi queens rand rand48 rgb sdbm sieve sqrt trig union zeta
</span></span></code></pre></td></tr></table></div></div><p>For a full explanation of these, please consult the manual.</p><p>By default, when running the cpu stressor without specifying a method, the stressor will step through all the stressors one by one in round-robin fashion to exercise the CPU with each one. To select just a specific cpu stressor method, for example, the Fast Fourier Transform (fft) stressor, use:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --cpu 1 --cpu-method fft -t 1m
</span></span></code></pre></td></tr></table></div></div><p>So to do a quick and dirty integer bogo ops benchmark, one could do:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for m in int8 int16 int32 int64; do stress-ng --cpu 0 --cpu-method $m -t 10s --metrics-brief; done
</span></span></code></pre></td></tr></table></div></div><h2 id=verify-mode>Verify mode</h2><p>Some stressors have a verification mode. A stress test is run and the results are checked, if the results are incorrect then stress-ng will flag up a warning error message. Suppose we want to run some exhaustive memory checks on a blob of virtually mapped memory via the vm stressor, enable the &ndash;verify mode and this will sanity check that the read/write results on the memory:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --vm 1 --vm-bytes 2G --verify -v
</span></span></code></pre></td></tr></table></div></div><p>Note that not all stressors have a verify mode, and enabling it will reduce the bogo op stats as there is an extra verification step being invoked.</p><h2 id=causing-more-virtual-memory-vm-stress>Causing More Virtual Memory (VM) Stress</h2><p>When under memory pressure, the kernel will start writing pages out to swap. By checking which pages in a memory mapping are not resident in memory and touching them we can force them back into memory, causing the VM system to be heavily exercised. The &ndash;page-in option enables this mode for the bigheap, mmap and vm stressors. For example, expect a lot of swapping on a system with only 4GB of memory - 2 x 2G of vm stressor and 2 x 2GB of mmap stressor with page-in enabled:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --vm 2 --vm-bytes 2G --mmap 2 --mmap-bytes 2G --page-in
</span></span></code></pre></td></tr></table></div></div><h2 id=generating-a-large-interrupt-load>Generating a large interrupt load</h2><p>Running timers at high frequency can generate a large interrupt load. The timer stressor with an appropriately selected timer frequency can be used to force many hundreds of thousands of interrupts per second, for example, 32 instances at 1MHz:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --timer 32 --timer-freq 1000000
</span></span></code></pre></td></tr></table></div></div><h2 id=generating-major-page-faults>Generating major page faults</h2><p>You can generate major page faults (by accessing a page is not loaded in memory at the time of the fault) and see the page fault rate using:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --fault 0 --perf -t 1m
</span></span></code></pre></td></tr></table></div></div><p>or with newer kernels use the userfaultfd stressor to force even more major faults:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>stress-ng --userfaultfd 0 --perf -t 1m
</span></span></code></pre></td></tr></table></div></div></article><hr><div class=page-end><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div></div><div id=contact_buttons><footer><p>Made by Jacky Zhao using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2022</p><ul><li><a href=/>Home</a></li><li><a href=https://twitter.com/_jzhao>Twitter</a></li><li><a href=https://github.com/jackyzha0>Github</a></li></ul></footer></div><script src=https://lzyerste.github.io/quartz/js/popover.e57188d2e4c06b0654e020b3a734bb62.min.js></script>
<script>initPopover("https://lzyerste.github.io/quartz")</script></div></body></html>