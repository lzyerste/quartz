<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="linux kernel soft lockup/hard lockupç®€ä»‹åŠå…¶è§£å†³æ€è·¯_æ‚Ÿç©ºæ˜é•œ-CSDNåšå®¢_config_softlockup_detector  https://blog.csdn.net/wukongmingjing/article/details/82870807
æœ€è¿‘æœ‰ä¸€ä¸ªæœ‹å‹é—®åˆ°æˆ‘ä¸€ä¸ªkernel panicé—®é¢˜.ç”±äºä¸æ˜¯åšè¿™æ–¹é¢çš„,ä½†æ˜¯äº†è§£ä¸‹å’Œå…¶è§£å†³æ€è·¯è¿˜æ˜¯æœ‰å¿…è¦çš„.
ä¸€ æ¦‚è¿° åœ¨linux kernelé‡Œï¼Œæœ‰ä¸€ä¸ªdebugé€‰é¡¹CONFIG_HARDLOCKUP_DETECTORã€‚ä½¿èƒ½å®ƒå¯ä»¥æ‰“å¼€kernelä¸­çš„soft lockupå’Œhard lockupæ¢æµ‹ã€‚è¿™ä¸¤ä¸ªä¸œè¥¿åˆ°åº•æœ‰ä»€ä¹ˆç”¨å¤„é‚£ï¼Ÿé¦–å…ˆï¼Œsoft/hard lockupçš„å®ç°åœ¨kernel/watchdog.cä¸­ï¼Œä¸»ä½“æ¶‰åŠåˆ°äº†3ä¸ªä¸œè¥¿ï¼škernelçº¿ç¨‹ï¼Œæ—¶é’Ÿä¸­æ–­ï¼ŒNMIä¸­æ–­ï¼ˆä¸å¯å±è”½ä¸­æ–­ï¼‰ã€‚è¿™3ä¸ªä¸œè¥¿å…·æœ‰ä¸ä¸€æ ·çš„ä¼˜å…ˆçº§ï¼Œä¾æ¬¡æ˜¯kernelçº¿ç¨‹ < æ—¶é’Ÿä¸­æ–­ < NMIä¸­æ–­ã€‚è€Œæ­£æ˜¯ç”¨åˆ°äº†ä»–ä»¬ä¹‹é—´ä¼˜å…ˆçº§çš„åŒºåˆ«ï¼Œæ‰€ä»¥æ‰å¯ä»¥è°ƒè¯•ç³»ç»Ÿè¿è¡Œä¸­çš„ä¸¤ç§é—®é¢˜ï¼š"><title>linux_kernel_soft_lockup_hard_lockupç®€ä»‹åŠå…¶è§£å†³æ€è·¯_æ‚Ÿç©ºæ˜é•œ-_c2aa9d6231ce4b30979941e4ff806974</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://lzyerste.github.io/quartz//icon.png><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Source+Sans+Pro:wght@400;600;700&family=Fira+Code:wght@400;700&display=swap" rel=stylesheet><link href=https://lzyerste.github.io/quartz/styles.48db36360688fe00f0a39f3cf1417c4b.min.css rel=stylesheet><script src=https://lzyerste.github.io/quartz/js/darkmode.46b07878b7f5d9e26ad7a3c40f8a0605.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})})</script><script>const BASE_URL="https://lzyerste.github.io/quartz/",fetchData=Promise.all([fetch("https://lzyerste.github.io/quartz/indices/linkIndex.1d754d57933a311cf3815175a0b0ad85.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://lzyerste.github.io/quartz/indices/contentIndex.64bf45e4e0775d02af721f1302f61020.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n}))</script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://lzyerste.github.io/quartz/js/search.7861a82db330f0a40935b7458fee3a02.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://lzyerste.github.io/quartz/>ğŸª´ Quartz 3.2</a></h1><svg tabindex="0" id="search-icon" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg><div class=spacer></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>linux_kernel_soft_lockup_hard_lockupç®€ä»‹åŠå…¶è§£å†³æ€è·¯_æ‚Ÿç©ºæ˜é•œ-_c2aa9d6231ce4b30979941e4ff806974</h1><p class=meta>Last updated Unknown</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#ä¸€-æ¦‚è¿°>ä¸€ æ¦‚è¿°</a></li><li><a href=#äºŒ-soft-lockupç®€ä»‹>äºŒ soft lockupç®€ä»‹</a></li><li><a href=#ä¸‰-hard-lockupç®€ä»‹>ä¸‰ hard lockupç®€ä»‹</a></li><li><a href=#å››-æ¡ˆä¾‹åˆ†æ>å›› æ¡ˆä¾‹åˆ†æ</a></li></ol></nav></details></aside><h1 id=linux-kernel-soft-lockuphard-lockupç®€ä»‹åŠå…¶è§£å†³æ€è·¯_æ‚Ÿç©ºæ˜é•œ-csdnåšå®¢_config_softlockup_detector>linux kernel soft lockup/hard lockupç®€ä»‹åŠå…¶è§£å†³æ€è·¯_æ‚Ÿç©ºæ˜é•œ-CSDNåšå®¢_config_softlockup_detector</h1><p><a href=https://blog.csdn.net/wukongmingjing/article/details/82870807 rel=noopener>https://blog.csdn.net/wukongmingjing/article/details/82870807</a></p><p>æœ€è¿‘æœ‰ä¸€ä¸ªæœ‹å‹é—®åˆ°æˆ‘ä¸€ä¸ªkernel panicé—®é¢˜.ç”±äºä¸æ˜¯åšè¿™æ–¹é¢çš„,ä½†æ˜¯äº†è§£ä¸‹å’Œå…¶è§£å†³æ€è·¯è¿˜æ˜¯æœ‰å¿…è¦çš„.</p><h2 id=ä¸€-æ¦‚è¿°>ä¸€ æ¦‚è¿°</h2><p>åœ¨linux kernelé‡Œï¼Œæœ‰ä¸€ä¸ªdebugé€‰é¡¹CONFIG_HARDLOCKUP_DETECTORã€‚ä½¿èƒ½å®ƒå¯ä»¥æ‰“å¼€kernelä¸­çš„soft lockupå’Œhard lockupæ¢æµ‹ã€‚è¿™ä¸¤ä¸ªä¸œè¥¿åˆ°åº•æœ‰ä»€ä¹ˆç”¨å¤„é‚£ï¼Ÿé¦–å…ˆï¼Œsoft/hard lockupçš„å®ç°åœ¨kernel/watchdog.cä¸­ï¼Œä¸»ä½“æ¶‰åŠåˆ°äº†3ä¸ªä¸œè¥¿ï¼škernelçº¿ç¨‹ï¼Œæ—¶é’Ÿä¸­æ–­ï¼ŒNMIä¸­æ–­ï¼ˆä¸å¯å±è”½ä¸­æ–­ï¼‰ã€‚è¿™3ä¸ªä¸œè¥¿å…·æœ‰ä¸ä¸€æ ·çš„ä¼˜å…ˆçº§ï¼Œä¾æ¬¡æ˜¯kernelçº¿ç¨‹ &lt; æ—¶é’Ÿä¸­æ–­ &lt; NMIä¸­æ–­ã€‚è€Œæ­£æ˜¯ç”¨åˆ°äº†ä»–ä»¬ä¹‹é—´ä¼˜å…ˆçº§çš„åŒºåˆ«ï¼Œæ‰€ä»¥æ‰å¯ä»¥è°ƒè¯•ç³»ç»Ÿè¿è¡Œä¸­çš„ä¸¤ç§é—®é¢˜ï¼š</p><ul><li>ç”±äºæŸç§åŸå› å¯¼è‡´ç³»ç»Ÿå¤„äºå†…æ ¸æ€è¶…è¿‡20så¯¼è‡´è¿›ç¨‹æ— æ³•è¿è¡Œ(soft lockup)</li><li>ç”±äºæŸç§åŸå› å¯¼è‡´ç³»ç»Ÿå¤„äºå†…æ ¸æ€è¶…è¿‡10så¯¼è‡´ä¸­æ–­æ— æ³•è¿è¡Œ(hard lockup)</li></ul><p>ä¸‹é¢æ˜¯kernel documentå¯¹è¿™ä¸¤è€…çš„ç®€ä»‹:</p><ul><li>A â€˜softlockupâ€™ is defined as a bug that causes the kernel to loop in kernel mode for more than 20 seconds (see â€œImplementationâ€ below for details), without giving other tasks a chance to run. The current stack trace is displayed upon detection and, by default, the system will stay locked up. Alternatively, the kernel can be configured to panic; a sysctl, â€œkernel.softlockup_panicâ€, a kernel parameter,â€œsoftlockup_panicâ€ (see â€œDocumentation/kernel-parameters.txtâ€ for details), and a compile option,â€œBOOTPARAM_SOFTLOCKUP_PANICâ€, are provided for this.</li><li>A â€˜hardlockupâ€™ is defined as a bug that causes the CPU to loop in kernel mode for more than 10 seconds (see â€œImplementationâ€ below for details), without letting other interrupts have a chance to run. Similarly to the softlockup case, the current stack trace is displayed upon detection and the system will stay locked up unless the default behavior is changed, which can be done through a sysctl, â€˜hardlockup_panicâ€™, a compile time knob,â€œBOOTPARAM_HARDLOCKUP_PANICâ€, and a kernel parameter, â€œnmi_watchdogâ€</li></ul><p>å…·ä½“å¯ä»¥å‚è€ƒ: Document/lockup-watchdogs.txt:
<a href=https://elixir.bootlin.com/linux/latest/source/Documentation/lockup-watchdogs.txt rel=noopener>https://elixir.bootlin.com/linux/latest/source/Documentation/lockup-watchdogs.txt</a></p><h2 id=äºŒ-soft-lockupç®€ä»‹>äºŒ soft lockupç®€ä»‹</h2><p>æ¥ä¸‹æ¥æˆ‘ä»¬ä»å…·ä½“ä»£ç å…¥æ‰‹åˆ†ælinux(4.4.83)æ˜¯å¦‚ä½•å®ç°è¿™ä¸¤ç§lockupçš„æ¢æµ‹çš„ï¼š</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span><span class=lnt>79
</span><span class=lnt>80
</span><span class=lnt>81
</span><span class=lnt>82
</span><span class=lnt>83
</span><span class=lnt>84
</span><span class=lnt>85
</span><span class=lnt>86
</span><span class=lnt>87
</span><span class=lnt>88
</span><span class=lnt>89
</span><span class=lnt>90
</span><span class=lnt>91
</span><span class=lnt>92
</span><span class=lnt>93
</span><span class=lnt>94
</span><span class=lnt>95
</span><span class=lnt>96
</span><span class=lnt>97
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>static struct smp_hotplug_thread watchdog_threads = {  
</span></span><span class=line><span class=cl>    .store          = &amp;softlockup_watchdog,  
</span></span><span class=line><span class=cl>    .thread_should_run  = watchdog_should_run,  
</span></span><span class=line><span class=cl>    .thread_fn      = watchdog,  
</span></span><span class=line><span class=cl>    .thread_comm        = &#34;watchdog/%u&#34;,  
</span></span><span class=line><span class=cl>    .setup          = watchdog_enable,  
</span></span><span class=line><span class=cl>    .cleanup        = watchdog_cleanup,  
</span></span><span class=line><span class=cl>    .park           = watchdog_disable,  
</span></span><span class=line><span class=cl>    .unpark         = watchdog_enable,  
</span></span><span class=line><span class=cl>};  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>void __init lockup_detector_init(void)  
</span></span><span class=line><span class=cl>{   /*è·å–é‡‡ç”¨å‘¨æœŸ*/
</span></span><span class=line><span class=cl>    set_sample_period();  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>#ifdef CONFIG_NO_HZ_FULL  
</span></span><span class=line><span class=cl>    if (tick_nohz_full_enabled()) {  
</span></span><span class=line><span class=cl>        pr_info(&#34;Disabling watchdog on nohz_full cores by default\n&#34;);  
</span></span><span class=line><span class=cl>        cpumask_copy(&amp;watchdog_cpumask, housekeeping_mask);  
</span></span><span class=line><span class=cl>    } else  
</span></span><span class=line><span class=cl>        cpumask_copy(&amp;watchdog_cpumask, cpu_possible_mask);  
</span></span><span class=line><span class=cl>#else  
</span></span><span class=line><span class=cl>    cpumask_copy(&amp;watchdog_cpumask, cpu_possible_mask);  
</span></span><span class=line><span class=cl>#endif  
</span></span><span class=line><span class=cl>    /*åœ¨ç³»ç»Ÿåˆå§‹åŒ–çš„æ—¶å€™,ä¸ºæ¯ä¸ªonline cpuåˆ›å»ºwatch_threadsçº¿ç¨‹ä¿¡æ¯.*/
</span></span><span class=line><span class=cl>    if (watchdog_enabled)  
</span></span><span class=line><span class=cl>        watchdog_enable_all_cpus();  
</span></span><span class=line><span class=cl>}  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>static int watchdog_enable_all_cpus(void)  
</span></span><span class=line><span class=cl>{  
</span></span><span class=line><span class=cl>    int err = 0;  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    if (!watchdog_running) { 
</span></span><span class=line><span class=cl>        /*åˆå§‹åŒ–çš„æ—¶å€™,åˆ›å»ºwatchdogçº¿ç¨‹,åŒæ—¶å…³è”percpu 
</span></span><span class=line><span class=cl>              watchdog_cpumask=cpu_possible_mask*/ 
</span></span><span class=line><span class=cl>        err = smpboot_register_percpu_thread_cpumask(&amp;watchdog_threads,  
</span></span><span class=line><span class=cl>                                 &amp;watchdog_cpumask);  
</span></span><span class=line><span class=cl>        if (err)  
</span></span><span class=line><span class=cl>            pr_err(&#34;Failed to create watchdog threads, disabled\n&#34;);  
</span></span><span class=line><span class=cl>        else  
</span></span><span class=line><span class=cl>            watchdog_running = 1;  
</span></span><span class=line><span class=cl>    } else {  
</span></span><span class=line><span class=cl>        /* 
</span></span><span class=line><span class=cl>         * Enable/disable the lockup detectors or 
</span></span><span class=line><span class=cl>         * change the sample period &#39;on the fly&#39;. 
</span></span><span class=line><span class=cl>         */  
</span></span><span class=line><span class=cl>        err = update_watchdog_all_cpus();  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>        if (err) {  
</span></span><span class=line><span class=cl>            watchdog_disable_all_cpus();  
</span></span><span class=line><span class=cl>            pr_err(&#34;Failed to update lockup detectors, disabled\n&#34;);  
</span></span><span class=line><span class=cl>        }  
</span></span><span class=line><span class=cl>    }  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    if (err)  
</span></span><span class=line><span class=cl>        watchdog_enabled = 0;  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    return err;  
</span></span><span class=line><span class=cl>}  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>/** 
</span></span><span class=line><span class=cl> * smpboot_register_percpu_thread_cpumask - Register a per_cpu thread related 
</span></span><span class=line><span class=cl> *                      to hotplug 
</span></span><span class=line><span class=cl> * @plug_thread:    Hotplug thread descriptor 
</span></span><span class=line><span class=cl> * @cpumask:        The cpumask where threads run 
</span></span><span class=line><span class=cl> * 
</span></span><span class=line><span class=cl> * Creates and starts the threads on all online cpus. 
</span></span><span class=line><span class=cl> */  
</span></span><span class=line><span class=cl>int smpboot_register_percpu_thread_cpumask(struct smp_hotplug_thread *plug_thread,  
</span></span><span class=line><span class=cl>                       const struct cpumask *cpumask)  
</span></span><span class=line><span class=cl>{  
</span></span><span class=line><span class=cl>    unsigned int cpu;  
</span></span><span class=line><span class=cl>    int ret = 0;  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    if (!alloc_cpumask_var(&amp;plug_thread-&gt;cpumask, GFP_KERNEL))  
</span></span><span class=line><span class=cl>        return -ENOMEM;  
</span></span><span class=line><span class=cl>    cpumask_copy(plug_thread-&gt;cpumask, cpumask);  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    get_online_cpus();  
</span></span><span class=line><span class=cl>    mutex_lock(&amp;smpboot_threads_lock);  
</span></span><span class=line><span class=cl>    for_each_online_cpu(cpu) {  
</span></span><span class=line><span class=cl>        ret = __smpboot_create_thread(plug_thread, cpu);  
</span></span><span class=line><span class=cl>        if (ret) {  
</span></span><span class=line><span class=cl>            smpboot_destroy_threads(plug_thread);  
</span></span><span class=line><span class=cl>            free_cpumask_var(plug_thread-&gt;cpumask);  
</span></span><span class=line><span class=cl>            goto out;  
</span></span><span class=line><span class=cl>        }  
</span></span><span class=line><span class=cl>        if (cpumask_test_cpu(cpu, cpumask))  
</span></span><span class=line><span class=cl>            smpboot_unpark_thread(plug_thread, cpu);  
</span></span><span class=line><span class=cl>    }  
</span></span><span class=line><span class=cl>    list_add(&amp;plug_thread-&gt;list, &amp;hotplug_threads);  
</span></span><span class=line><span class=cl>out:  
</span></span><span class=line><span class=cl>    mutex_unlock(&amp;smpboot_threads_lock);  
</span></span><span class=line><span class=cl>    put_online_cpus();  
</span></span><span class=line><span class=cl>    return ret;  
</span></span><span class=line><span class=cl>}  
</span></span></code></pre></td></tr></table></div></div><p>å®é™…çš„é€»è¾‘å¦‚ä¸‹:é¦–å…ˆï¼Œç³»ç»Ÿä¼šä¸ºæ¯ä¸ªcpu coreæ³¨å†Œä¸€ä¸ªä¸€èˆ¬çš„kernelçº¿ç¨‹ï¼Œåå­—å«watchdog/0, watchdog/1â€¦ä»¥æ­¤ç±»æ¨ã€‚è¿™ä¸ªçº¿ç¨‹ä¼šå®šæœŸå¾—è°ƒç”¨watchdogå‡½æ•°</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>static DEFINE_PER_CPU(unsigned long, soft_lockup_hrtimer_cnt);  
</span></span><span class=line><span class=cl>static DEFINE_PER_CPU(unsigned long, watchdog_touch_ts);  
</span></span><span class=line><span class=cl>static DEFINE_PER_CPU(unsigned long, hrtimer_interrupts);  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>/* 
</span></span><span class=line><span class=cl> * The watchdog thread function - touches the timestamp. 
</span></span><span class=line><span class=cl> * 
</span></span><span class=line><span class=cl> * It only runs once every sample_period seconds (4 seconds by 
</span></span><span class=line><span class=cl> * default) to reset the softlockup timestamp. If this gets delayed 
</span></span><span class=line><span class=cl> * for more than 2*watchdog_thresh seconds then the debug-printout 
</span></span><span class=line><span class=cl> * triggers in watchdog_timer_fn(). 
</span></span><span class=line><span class=cl> */  
</span></span><span class=line><span class=cl>static void watchdog(unsigned int cpu)  
</span></span><span class=line><span class=cl>{   /*å°†å˜é‡hrtimer_interruptsæ•°å€¼èµ‹å€¼ç»™ soft_lockup_hrtimer_cnt*/
</span></span><span class=line><span class=cl>    __this_cpu_write(soft_lockup_hrtimer_cnt,  
</span></span><span class=line><span class=cl>             __this_cpu_read(hrtimer_interrupts));  
</span></span><span class=line><span class=cl>    __touch_watchdog();  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    /* 
</span></span><span class=line><span class=cl>     * watchdog_nmi_enable() clears the NMI_WATCHDOG_ENABLED bit in the 
</span></span><span class=line><span class=cl>     * failure path. Check for failures that can occur asynchronously - 
</span></span><span class=line><span class=cl>     * for example, when CPUs are on-lined - and shut down the hardware 
</span></span><span class=line><span class=cl>     * perf event on each CPU accordingly. 
</span></span><span class=line><span class=cl>     * 
</span></span><span class=line><span class=cl>     * The only non-obvious place this bit can be cleared is through 
</span></span><span class=line><span class=cl>     * watchdog_nmi_enable(), so a pr_info() is placed there.  Placing a 
</span></span><span class=line><span class=cl>     * pr_info here would be too noisy as it would result in a message 
</span></span><span class=line><span class=cl>     * every few seconds if the hardlockup was disabled but the softlockup 
</span></span><span class=line><span class=cl>     * enabled. 
</span></span><span class=line><span class=cl>     */  
</span></span><span class=line><span class=cl>    if (!(watchdog_enabled &amp; NMI_WATCHDOG_ENABLED))  
</span></span><span class=line><span class=cl>        watchdog_nmi_disable(cpu);  
</span></span><span class=line><span class=cl>}  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>/* Commands for resetting the watchdog */  
</span></span><span class=line><span class=cl>static void __touch_watchdog(void)  
</span></span><span class=line><span class=cl>{  /*è·å–å½“å‰æ—¶é—´å¹¶èµ‹å€¼ç»™watchdog_touch_ts,ç›®çš„æ˜¯å‘¨æœŸæ€§çš„æ£€æµ‹æ˜¯å¦æ˜¯soft_lockup*/
</span></span><span class=line><span class=cl>    __this_cpu_write(watchdog_touch_ts, get_timestamp());  
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>/*watdogå‡½æ•°æ›´æ–°watchdog_touch_tsæ—¶é—´æˆ³,åœ¨å“ªé‡Œè¢«è°ƒç”¨å‘¢?*/
</span></span><span class=line><span class=cl>/** 
</span></span><span class=line><span class=cl> * smpboot_thread_fn - percpu hotplug thread loop function 
</span></span><span class=line><span class=cl> * @data:   thread data pointer 
</span></span><span class=line><span class=cl> * 
</span></span><span class=line><span class=cl> * Checks for thread stop and park conditions. Calls the necessary 
</span></span><span class=line><span class=cl> * setup, cleanup, park and unpark functions for the registered 
</span></span><span class=line><span class=cl> * thread. 
</span></span><span class=line><span class=cl> * 
</span></span><span class=line><span class=cl> * Returns 1 when the thread should exit, 0 otherwise. 
</span></span><span class=line><span class=cl> */  
</span></span><span class=line><span class=cl>static int smpboot_thread_fn(void *data)  
</span></span><span class=line><span class=cl>{  
</span></span><span class=line><span class=cl>    struct smpboot_thread_data *td = data;  
</span></span><span class=line><span class=cl>    struct smp_hotplug_thread *ht = td-&gt;ht;  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    while (1) {  
</span></span><span class=line><span class=cl>        set_current_state(TASK_INTERRUPTIBLE);  
</span></span><span class=line><span class=cl>        preempt_disable();  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>        if (!ht-&gt;thread_should_run(td-&gt;cpu)) {  
</span></span><span class=line><span class=cl>            preempt_enable_no_resched();  
</span></span><span class=line><span class=cl>            schedule();  
</span></span><span class=line><span class=cl>        } else {  
</span></span><span class=line><span class=cl>            __set_current_state(TASK_RUNNING);  
</span></span><span class=line><span class=cl>            preempt_enable();
</span></span><span class=line><span class=cl>            /*åœ¨è¿™é‡Œè¢«call,åœ¨initæ—¶,ä¸ºæ¯ä¸ªonline cpuå…³è”watchdog_threadsç»“æ„ä½“ä¿¡æ¯
</span></span><span class=line><span class=cl>           çš„æ—¶å€™è¢«è°ƒç”¨åˆ°.smpboot_register_percpu_thread_cpumask*/  
</span></span><span class=line><span class=cl>            ht-&gt;thread_fn(td-&gt;cpu);  
</span></span><span class=line><span class=cl>        }  
</span></span><span class=line><span class=cl>    }  
</span></span><span class=line><span class=cl>}  
</span></span><span class=line><span class=cl>  
</span></span></code></pre></td></tr></table></div></div><p>æˆ‘ä»¬å…ˆä¸ç†ä¼šè¿™ä¸ªçº¿ç¨‹å¤„ç†å‡½æ•°watchdogå¤šä¹…è¢«è°ƒç”¨ä¸€æ¬¡ï¼Œæˆ‘ä»¬å°±å…ˆç®€å•çš„è®¤ä¸ºï¼Œè¿™ä¸ªçº¿ç¨‹æ˜¯è´Ÿè´£æ›´æ–°watchdog_touch_tsçš„ã€‚ç„¶åæˆ‘ä»¬è¦çœ‹ä¸€ä¸‹æ—¶é’Ÿä¸­æ–­äº†ï¼š</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-zed data-lang=zed><span class=line><span class=cl><span class=n>static</span><span class=w> </span><span class=n>void</span><span class=w> </span><span class=n>watchdog_enable</span><span class=p>(</span><span class=n>unsigned</span><span class=w> </span><span class=n>int</span><span class=w> </span><span class=n>cpu</span><span class=p>)</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>  </span><span class=cm>/*static DEFINE_PER_CPU(struct hrtimer, watchdog_hrtimer)*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>struct</span><span class=w> </span><span class=n>hrtimer</span><span class=w> </span><span class=o>*</span><span class=n>hrtimer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>raw_cpu_ptr</span><span class=p>(</span><span class=o>&amp;</span><span class=n>watchdog_hrtimer</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/* kick off the timer for the hardlockup detector */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>hrtimer_init</span><span class=p>(</span><span class=n>hrtimer</span><span class=p>,</span><span class=w> </span><span class=n>CLOCK_MONOTONIC</span><span class=p>,</span><span class=w> </span><span class=n>HRTIMER_MODE_REL</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/*å°†æ—¶é’Ÿä¸­æ–­å‡½æ•°èµ‹å€¼ç»™hrtimer callback function*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>hrtimer</span><span class=o>-&gt;</span><span class=n>function</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>watchdog_timer_fn</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/* Enable the perf event */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>watchdog_nmi_enable</span><span class=p>(</span><span class=n>cpu</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/* done here because hrtimer_start can only pin to smp_processor_id() åœ¨å½“å‰cpuä¸Šä»¥å‘¨æœŸsample_periodè¿è¡Œ*/</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>hrtimer_start</span><span class=p>(</span><span class=n>hrtimer</span><span class=p>,</span><span class=w> </span><span class=n>ns_to_ktime</span><span class=p>(</span><span class=n>sample_period</span><span class=p>),</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=n>HRTIMER_MODE_REL_PINNED</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/* initialize timestamp è®¾ç½®watchdogçº¿ç¨‹çš„ä¼˜å…ˆçº§ä¸ºRTçº¿ç¨‹,ä¼˜å…ˆçº§
</span></span></span><span class=line><span class=cl><span class=cm>    ä¸ºprio:99*/</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>watchdog_set_prio</span><span class=p>(</span><span class=n>SCHED_FIFO</span><span class=p>,</span><span class=w> </span><span class=n>MAX_RT_PRIO</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=err>1</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>__touch_watchdog</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/*ä¸‹é¢æ˜¯è®¡ç®—sample_period=4s*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>static</span><span class=w> </span><span class=n>u64</span><span class=w> </span><span class=n>__read_mostly</span><span class=w> </span><span class=n>sample_period</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>int</span><span class=w> </span><span class=n>__read_mostly</span><span class=w> </span><span class=n>watchdog_thresh</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=err>10</span><span class=p>;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/* 
</span></span></span><span class=line><span class=cl><span class=cm> * Hard-lockup warnings should be triggered after just a few seconds. Soft- 
</span></span></span><span class=line><span class=cl><span class=cm> * lockups can have false positives under extreme conditions. So we generally 
</span></span></span><span class=line><span class=cl><span class=cm> * want a higher threshold for soft lockups than for hard lockups. So we couple 
</span></span></span><span class=line><span class=cl><span class=cm> * the thresholds with a factor: we make the soft threshold twice the amount of 
</span></span></span><span class=line><span class=cl><span class=cm> * time the hard threshold is. 
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>static</span><span class=w> </span><span class=n>int</span><span class=w> </span><span class=n>get_softlockup_thresh</span><span class=p>(</span><span class=n>void</span><span class=p>)</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>return</span><span class=w> </span><span class=n>watchdog_thresh</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=err>2</span><span class=p>;</span><span class=w>  </span><span class=cm>/*20s*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/* 
</span></span></span><span class=line><span class=cl><span class=cm> * Returns seconds, approximately.  We don&#39;t need nanosecond 
</span></span></span><span class=line><span class=cl><span class=cm> * resolution, and we don&#39;t need to waste time with a big divide when 
</span></span></span><span class=line><span class=cl><span class=cm> * 2^30ns == 1.074s. 
</span></span></span><span class=line><span class=cl><span class=cm> */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>static</span><span class=w> </span><span class=n>unsigned</span><span class=w> </span><span class=n>long</span><span class=w> </span><span class=n>get_timestamp</span><span class=p>(</span><span class=n>void</span><span class=p>)</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>return</span><span class=w> </span><span class=n>running_clock</span><span class=p>()</span><span class=w> </span><span class=o>&gt;&gt;</span><span class=w> </span><span class=err>30</span><span class=n>LL</span><span class=p>;</span><span class=w>  </span><span class=cm>/* 2^30 ~= 10^9 */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>static</span><span class=w> </span><span class=n>void</span><span class=w> </span><span class=n>set_sample_period</span><span class=p>(</span><span class=n>void</span><span class=p>)</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cm>/* 
</span></span></span><span class=line><span class=cl><span class=cm>     * convert watchdog_thresh from seconds to ns 
</span></span></span><span class=line><span class=cl><span class=cm>     * the divide by 5 is to give hrtimer several chances (two 
</span></span></span><span class=line><span class=cl><span class=cm>     * or three with the current relation between the soft 
</span></span></span><span class=line><span class=cl><span class=cm>     * and hard thresholds) to increment before the 
</span></span></span><span class=line><span class=cl><span class=cm>     * hardlockup detector generates a warning 
</span></span></span><span class=line><span class=cl><span class=cm>     */</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>sample_period</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>get_softlockup_thresh</span><span class=p>()</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=p>((</span><span class=n>u64</span><span class=p>)</span><span class=n>NSEC_PER_SEC</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=err>5</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>  
</span></span></span></code></pre></td></tr></table></div></div><p>æ—¶é’Ÿä¸­æ–­å¤„ç†å‡½æ•°æ˜¯watchdog_timer_fn(æ³¨æ„å…³é”®å­—:HRTIMER_RESTART,ä¼šå‘¨æœŸæ€§çš„æ‰§è¡Œ.):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* watchdog kicker functions */  
</span></span><span class=line><span class=cl>static enum hrtimer_restart watchdog_timer_fn(struct hrtimer *hrtimer)  
</span></span><span class=line><span class=cl>{   /*è·å–æ‰§è¡Œå‡½æ•°watchdogæ—¶å€™æ›´æ–°watchdog_touch_tsæ—¶é—´æˆ³*/
</span></span><span class=line><span class=cl>    unsigned long touch_ts = __this_cpu_read(watchdog_touch_ts);  
</span></span><span class=line><span class=cl>    struct pt_regs *regs = get_irq_regs();  
</span></span><span class=line><span class=cl>    int duration;  
</span></span><span class=line><span class=cl>    int softlockup_all_cpu_backtrace = sysctl_softlockup_all_cpu_backtrace;  
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    /* kick the hardlockup detector */  
</span></span><span class=line><span class=cl>    watchdog_interrupt_count();  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    /* test for hardlockups on the next cpu */  
</span></span><span class=line><span class=cl>    watchdog_check_hardlockup_other_cpu();  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    /* kick the softlockup detector */  
</span></span><span class=line><span class=cl>    wake_up_process(__this_cpu_read(softlockup_watchdog));  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    /* .. and repeat */  
</span></span><span class=line><span class=cl>    hrtimer_forward_now(hrtimer, ns_to_ktime(sample_period));  
</span></span><span class=line><span class=cl>    /*ç¬¬ä¸€æ¬¡æ‰§è¡Œ,watchdog_touch_tsæ—¶é—´æˆ³å¯èƒ½ä¸ºé›¶,éœ€è¦æ›´æ–°touch_ts
</span></span><span class=line><span class=cl>    ä¸ºå½“å‰æ—¶é—´æˆ³*/
</span></span><span class=line><span class=cl>    if (touch_ts == 0) {  
</span></span><span class=line><span class=cl>        if (unlikely(__this_cpu_read(softlockup_touch_sync))) {  
</span></span><span class=line><span class=cl>            /* 
</span></span><span class=line><span class=cl>             * If the time stamp was touched atomically 
</span></span><span class=line><span class=cl>             * make sure the scheduler tick is up to date. 
</span></span><span class=line><span class=cl>             */  
</span></span><span class=line><span class=cl>            __this_cpu_write(softlockup_touch_sync, false);  
</span></span><span class=line><span class=cl>            sched_clock_tick();  
</span></span><span class=line><span class=cl>        }  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>        /* Clear the guest paused flag on watchdog reset */  
</span></span><span class=line><span class=cl>        kvm_check_and_clear_guest_paused();  
</span></span><span class=line><span class=cl>        __touch_watchdog();  
</span></span><span class=line><span class=cl>        return HRTIMER_RESTART;  
</span></span><span class=line><span class=cl>    }  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    /* check for a softlockup 
</span></span><span class=line><span class=cl>     * This is done by making sure a high priority task is 
</span></span><span class=line><span class=cl>     * being scheduled.  The task touches the watchdog to 
</span></span><span class=line><span class=cl>     * indicate it is getting cpu time.  If it hasn&#39;t then 
</span></span><span class=line><span class=cl>     * this is a good indication some task is hogging the cpu 
</span></span><span class=line><span class=cl>     */ /*æ£€æµ‹ç³»ç»Ÿæ˜¯å¦å¤„äºå†…æ ¸modeè¶…è¿‡20s,å¹¶åšå‡ºå†³ç­–*/ 
</span></span><span class=line><span class=cl>    duration = is_softlockup(touch_ts);  
</span></span><span class=line><span class=cl>    if (unlikely(duration)) {  
</span></span><span class=line><span class=cl>        /* 
</span></span><span class=line><span class=cl>         * If a virtual machine is stopped by the host it can look to 
</span></span><span class=line><span class=cl>         * the watchdog like a soft lockup, check to see if the host 
</span></span><span class=line><span class=cl>         * stopped the vm before we issue the warning 
</span></span><span class=line><span class=cl>         */  
</span></span><span class=line><span class=cl>        if (kvm_check_and_clear_guest_paused())  
</span></span><span class=line><span class=cl>            return HRTIMER_RESTART;  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>        /* only warn once */  
</span></span><span class=line><span class=cl>        if (__this_cpu_read(soft_watchdog_warn) == true) {  
</span></span><span class=line><span class=cl>            /* 
</span></span><span class=line><span class=cl>             * When multiple processes are causing softlockups the 
</span></span><span class=line><span class=cl>             * softlockup detector only warns on the first one 
</span></span><span class=line><span class=cl>             * because the code relies on a full quiet cycle to 
</span></span><span class=line><span class=cl>             * re-arm.  The second process prevents the quiet cycle 
</span></span><span class=line><span class=cl>             * and never gets reported.  Use task pointers to detect 
</span></span><span class=line><span class=cl>             * this. 
</span></span><span class=line><span class=cl>             */  
</span></span><span class=line><span class=cl>            if (__this_cpu_read(softlockup_task_ptr_saved) !=  
</span></span><span class=line><span class=cl>                current) {  
</span></span><span class=line><span class=cl>                __this_cpu_write(soft_watchdog_warn, false);  
</span></span><span class=line><span class=cl>                __touch_watchdog();  
</span></span><span class=line><span class=cl>            }  
</span></span><span class=line><span class=cl>            return HRTIMER_RESTART;  
</span></span><span class=line><span class=cl>        }  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>        if (softlockup_all_cpu_backtrace) {  
</span></span><span class=line><span class=cl>            /* Prevent multiple soft-lockup reports if one cpu is already 
</span></span><span class=line><span class=cl>             * engaged in dumping cpu back traces 
</span></span><span class=line><span class=cl>             */  
</span></span><span class=line><span class=cl>            if (test_and_set_bit(0, &amp;soft_lockup_nmi_warn)) {  
</span></span><span class=line><span class=cl>                /* Someone else will report us. Let&#39;s give up */  
</span></span><span class=line><span class=cl>                __this_cpu_write(soft_watchdog_warn, true);  
</span></span><span class=line><span class=cl>                return HRTIMER_RESTART;  
</span></span><span class=line><span class=cl>            }  
</span></span><span class=line><span class=cl>        }  
</span></span><span class=line><span class=cl>        /*ä¸Šé¢æ˜¯ä¸€äº›æ¡ä»¶çš„åˆ¤æ–­æ˜¯å¦æ˜¯çœŸæ­£çš„soft_lockup.ä¸‹é¢æ˜¯å½“soft_lockupå‡ºç°çš„è¯ä¼šå°†
</span></span><span class=line><span class=cl>     ä¸€äº›å¿…è¦çš„ä¿¡æ¯dumpå‡ºæ¥.*/
</span></span><span class=line><span class=cl>        pr_emerg(&#34;BUG: soft lockup - CPU#%d stuck for %us! [%s:%d]\n&#34;,  
</span></span><span class=line><span class=cl>            smp_processor_id(), duration,  
</span></span><span class=line><span class=cl>            current-&gt;comm, task_pid_nr(current));  
</span></span><span class=line><span class=cl>        __this_cpu_write(softlockup_task_ptr_saved, current);  
</span></span><span class=line><span class=cl>        print_modules();  
</span></span><span class=line><span class=cl>        print_irqtrace_events(current);  
</span></span><span class=line><span class=cl>        if (regs)  
</span></span><span class=line><span class=cl>            show_regs(regs);  
</span></span><span class=line><span class=cl>        else  
</span></span><span class=line><span class=cl>            dump_stack();  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>        if (softlockup_all_cpu_backtrace) {  
</span></span><span class=line><span class=cl>            /* Avoid generating two back traces for current 
</span></span><span class=line><span class=cl>             * given that one is already made above 
</span></span><span class=line><span class=cl>             */  
</span></span><span class=line><span class=cl>            trigger_allbutself_cpu_backtrace();  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>            clear_bit(0, &amp;soft_lockup_nmi_warn);  
</span></span><span class=line><span class=cl>            /* Barrier to sync with other cpus */  
</span></span><span class=line><span class=cl>            smp_mb__after_atomic();  
</span></span><span class=line><span class=cl>        }  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>        add_taint(TAINT_SOFTLOCKUP, LOCKDEP_STILL_OK);  
</span></span><span class=line><span class=cl>        if (softlockup_panic)  
</span></span><span class=line><span class=cl>            panic(&#34;softlockup: hung tasks&#34;);  
</span></span><span class=line><span class=cl>        __this_cpu_write(soft_watchdog_warn, true);  
</span></span><span class=line><span class=cl>    } else  
</span></span><span class=line><span class=cl>        __this_cpu_write(soft_watchdog_warn, false);  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    return HRTIMER_RESTART;  
</span></span><span class=line><span class=cl>}  
</span></span></code></pre></td></tr></table></div></div><p>watchdog_timer_fnè¿™ä¸ªå‡½æ•°çš„ç›®çš„å¦‚ä¸‹:</p><ul><li>watchdog_interrupt_countå‡½æ•°æ›´æ–°hrtimer_interruptså˜é‡</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>static void watchdog_interrupt_count(void)  
</span></span><span class=line><span class=cl>{  
</span></span><span class=line><span class=cl>    __this_cpu_inc(hrtimer_interrupts);  
</span></span><span class=line><span class=cl>}  
</span></span></code></pre></td></tr></table></div></div><ul><li>is_softlockupåˆ¤æ–­æ˜¯å¦å‡ºç°äº†soft_lockup</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>static int is_softlockup(unsigned long touch_ts)  
</span></span><span class=line><span class=cl>{  
</span></span><span class=line><span class=cl>    unsigned long now = get_timestamp();  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    if ((watchdog_enabled &amp; SOFT_WATCHDOG_ENABLED) &amp;&amp; watchdog_thresh){  
</span></span><span class=line><span class=cl>        /* Warn about unreasonable delays. */  
</span></span><span class=line><span class=cl>        if (time_after(now, touch_ts + get_softlockup_thresh()))  
</span></span><span class=line><span class=cl>            return now - touch_ts;  
</span></span><span class=line><span class=cl>    }  
</span></span><span class=line><span class=cl>    return 0;  
</span></span><span class=line><span class=cl>}  
</span></span></code></pre></td></tr></table></div></div><p>å¾ˆå®¹æ˜“ç†è§£ï¼Œå…¶å®å°±æ˜¯æŸ¥çœ‹watchdog_touch_tså˜é‡åœ¨æœ€è¿‘20ç§’çš„æ—¶é—´å†…ï¼Œæœ‰æ²¡æœ‰è¢«åˆ›å»ºçš„kernel thread(å³watchdogå‡½æ•°æœ‰æ²¡æœ‰åœ¨æŸä¸ªcpuä¸Šè¶…è¿‡20sæ²¡æœ‰æ‰§è¡Œè¿‡æ¥æ›´æ–°watchdog_touch_tså˜é‡)æ›´æ–°è¿‡ã€‚å‡å¦‚æ²¡æœ‰ï¼Œé‚£å°±æ„å‘³ç€çº¿ç¨‹å¾—ä¸åˆ°è°ƒåº¦ï¼Œæ‰€ä»¥å¾ˆæœ‰å¯èƒ½å°±æ˜¯ç³»ç»Ÿå¤„äºå†…æ ¸æ€å¤ªä¹…äº†ï¼Œå¯¼è‡´è°ƒåº¦å™¨æ²¡æœ‰åŠæ³•è¿›è¡Œè°ƒåº¦ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œç³»ç»Ÿå¾€å¾€ä¸ä¼šæ­»æ‰ï¼Œä½†æ˜¯ä¼šå¾ˆæ…¢ã€‚æœ‰äº†soft lockupçš„æœºåˆ¶ï¼Œæˆ‘ä»¬å°±èƒ½å°½æ—©çš„å‘ç°è¿™æ ·çš„é—®é¢˜äº†ã€‚</p><h2 id=ä¸‰-hard-lockupç®€ä»‹>ä¸‰ hard lockupç®€ä»‹</h2><p>æˆ‘ä»¬æ¥ç€åˆ†æhard lockup</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>static int watchdog_nmi_enable(unsigned int cpu)  
</span></span><span class=line><span class=cl>{  
</span></span><span class=line><span class=cl>    struct perf_event_attr *wd_attr;  
</span></span><span class=line><span class=cl>    struct perf_event *event = per_cpu(watchdog_ev, cpu);  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    /* nothing to do if the hard lockup detector is disabled */  
</span></span><span class=line><span class=cl>    if (!(watchdog_enabled &amp; NMI_WATCHDOG_ENABLED))  
</span></span><span class=line><span class=cl>        goto out;  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    /* is it already setup and enabled? */  
</span></span><span class=line><span class=cl>    if (event &amp;&amp; event-&gt;state &gt; PERF_EVENT_STATE_OFF)  
</span></span><span class=line><span class=cl>        goto out;  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    /* it is setup but not enabled */  
</span></span><span class=line><span class=cl>    if (event != NULL)  
</span></span><span class=line><span class=cl>        goto out_enable;  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    wd_attr = &amp;wd_hw_attr;
</span></span><span class=line><span class=cl>   /*è·å–hard lockupå‘¨æœŸæ€§æ£€æµ‹çš„æ—¶é—´*/  
</span></span><span class=line><span class=cl>    wd_attr-&gt;sample_period = hw_nmi_get_sample_period(watchdog_thresh);  
</span></span><span class=line><span class=cl>    /* é€šè¿‡HW event,å³é€šè¿‡NMIå°†ä¿¡å·å‘é€ç»™cpuæ¥å¤„ç†hard lockup.æ ¸å¿ƒå‡½æ•°watchdog_ov
</span></span><span class=line><span class=cl>   erflow_callback */
</span></span><span class=line><span class=cl>    /* Try to register using hardware perf events */  
</span></span><span class=line><span class=cl>    event = perf_event_create_kernel_counter(wd_attr, cpu, NULL, watchdog_overflow_callback, NULL);  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    /* save cpu0 error for future comparision */  
</span></span><span class=line><span class=cl>    if (cpu == 0 &amp;&amp; IS_ERR(event))  
</span></span><span class=line><span class=cl>        cpu0_err = PTR_ERR(event);  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    if (!IS_ERR(event)) {  
</span></span><span class=line><span class=cl>        /* only print for cpu0 or different than cpu0 */  
</span></span><span class=line><span class=cl>        if (cpu == 0 || cpu0_err)  
</span></span><span class=line><span class=cl>            pr_info(&#34;enabled on all CPUs, permanently consumes one hw-PMU counter.\n&#34;);  
</span></span><span class=line><span class=cl>        goto out_save;  
</span></span><span class=line><span class=cl>    }  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    /* 
</span></span><span class=line><span class=cl>     * Disable the hard lockup detector if _any_ CPU fails to set up 
</span></span><span class=line><span class=cl>     * set up the hardware perf event. The watchdog() function checks 
</span></span><span class=line><span class=cl>     * the NMI_WATCHDOG_ENABLED bit periodically. 
</span></span><span class=line><span class=cl>     * 
</span></span><span class=line><span class=cl>     * The barriers are for syncing up watchdog_enabled across all the 
</span></span><span class=line><span class=cl>     * cpus, as clear_bit() does not use barriers. 
</span></span><span class=line><span class=cl>     */  
</span></span><span class=line><span class=cl>    smp_mb__before_atomic();  
</span></span><span class=line><span class=cl>    clear_bit(NMI_WATCHDOG_ENABLED_BIT, &amp;watchdog_enabled);  
</span></span><span class=line><span class=cl>    smp_mb__after_atomic();  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    /* skip displaying the same error again */  
</span></span><span class=line><span class=cl>    if (cpu &gt; 0 &amp;&amp; (PTR_ERR(event) == cpu0_err))  
</span></span><span class=line><span class=cl>        return PTR_ERR(event);  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    /* vary the KERN level based on the returned errno */  
</span></span><span class=line><span class=cl>    if (PTR_ERR(event) == -EOPNOTSUPP)  
</span></span><span class=line><span class=cl>        pr_info(&#34;disabled (cpu%i): not supported (no LAPIC?)\n&#34;, cpu);  
</span></span><span class=line><span class=cl>    else if (PTR_ERR(event) == -ENOENT)  
</span></span><span class=line><span class=cl>        pr_warn(&#34;disabled (cpu%i): hardware events not enabled\n&#34;,  
</span></span><span class=line><span class=cl>             cpu);  
</span></span><span class=line><span class=cl>    else  
</span></span><span class=line><span class=cl>        pr_err(&#34;disabled (cpu%i): unable to create perf event: %ld\n&#34;,  
</span></span><span class=line><span class=cl>            cpu, PTR_ERR(event));  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    pr_info(&#34;Shutting down hard lockup detector on all cpus\n&#34;);  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    return PTR_ERR(event);  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    /* success path */  
</span></span><span class=line><span class=cl>out_save:  
</span></span><span class=line><span class=cl>    per_cpu(watchdog_ev, cpu) = event;  
</span></span><span class=line><span class=cl>out_enable:  
</span></span><span class=line><span class=cl>    perf_event_enable(per_cpu(watchdog_ev, cpu));  
</span></span><span class=line><span class=cl>out:  
</span></span><span class=line><span class=cl>    return 0;  
</span></span><span class=line><span class=cl>}  
</span></span></code></pre></td></tr></table></div></div><p>perf_event_create_kernel_counterå‡½æ•°ä¸»è¦æ˜¯æ³¨å†Œäº†ä¸€ä¸ªç¡¬ä»¶çš„äº‹ä»¶ã€‚è¿™ä¸ªç¡¬ä»¶åœ¨x86é‡Œå«performance monitoringï¼Œè¿™ä¸ªç¡¬ä»¶æœ‰ä¸€ä¸ªåŠŸèƒ½å°±æ˜¯åœ¨cpu clockç»è¿‡äº†å¤šå°‘ä¸ªå‘¨æœŸåå‘å‡ºä¸€ä¸ªNMIä¸­æ–­å‡ºæ¥ã€‚ æ ¸å¿ƒå‡½æ•°åˆ†æ:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span><span class=lnt>75
</span><span class=lnt>76
</span><span class=lnt>77
</span><span class=lnt>78
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#ifdef CONFIG_HARDLOCKUP_DETECTOR_NMI  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>static struct perf_event_attr wd_hw_attr = {  
</span></span><span class=line><span class=cl>    .type       = PERF_TYPE_HARDWARE,  
</span></span><span class=line><span class=cl>    .config     = PERF_COUNT_HW_CPU_CYCLES,  
</span></span><span class=line><span class=cl>    .size       = sizeof(struct perf_event_attr),  
</span></span><span class=line><span class=cl>    .pinned     = 1,  
</span></span><span class=line><span class=cl>    .disabled   = 1,  
</span></span><span class=line><span class=cl>};  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>/* Callback function for perf event subsystem */  
</span></span><span class=line><span class=cl>static void watchdog_overflow_callback(struct perf_event *event,  
</span></span><span class=line><span class=cl>         struct perf_sample_data *data,  
</span></span><span class=line><span class=cl>         struct pt_regs *regs)  
</span></span><span class=line><span class=cl>{  
</span></span><span class=line><span class=cl>    /* Ensure the watchdog never gets throttled */  
</span></span><span class=line><span class=cl>    event-&gt;hw.interrupts = 0;  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    if (__this_cpu_read(watchdog_nmi_touch) == true) {  
</span></span><span class=line><span class=cl>        __this_cpu_write(watchdog_nmi_touch, false);  
</span></span><span class=line><span class=cl>        return;  
</span></span><span class=line><span class=cl>    }  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    /* check for a hardlockup 
</span></span><span class=line><span class=cl>     * This is done by making sure our timer interrupt 
</span></span><span class=line><span class=cl>     * is incrementing.  The timer interrupt should have 
</span></span><span class=line><span class=cl>     * fired multiple times before we overflow&#39;d.  If it hasn&#39;t 
</span></span><span class=line><span class=cl>     * then this is a good indication the cpu is stuck 
</span></span><span class=line><span class=cl>     *//*hrtimer_interrupts_savedä¸Šæ¬¡ä¿å­˜çš„æ•°å€¼ä¸å½“å‰hrtimer_interruptsæ˜¯å¦æœ‰å·®å¼‚
</span></span><span class=line><span class=cl>     */  
</span></span><span class=line><span class=cl>    if (is_hardlockup()) {  
</span></span><span class=line><span class=cl>        int this_cpu = smp_processor_id();  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>        /* only print hardlockups once */  
</span></span><span class=line><span class=cl>        if (__this_cpu_read(hard_watchdog_warn) == true)  
</span></span><span class=line><span class=cl>            return;  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>        pr_emerg(&#34;Watchdog detected hard LOCKUP on cpu %d&#34;, this_cpu);  
</span></span><span class=line><span class=cl>        print_modules();  
</span></span><span class=line><span class=cl>        print_irqtrace_events(current);  
</span></span><span class=line><span class=cl>        if (regs)  
</span></span><span class=line><span class=cl>            show_regs(regs);  
</span></span><span class=line><span class=cl>        else  
</span></span><span class=line><span class=cl>            dump_stack();  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>        /* 
</span></span><span class=line><span class=cl>         * Perform all-CPU dump only once to avoid multiple hardlockups 
</span></span><span class=line><span class=cl>         * generating interleaving traces 
</span></span><span class=line><span class=cl>         */  
</span></span><span class=line><span class=cl>        if (sysctl_hardlockup_all_cpu_backtrace &amp;&amp;  
</span></span><span class=line><span class=cl>                !test_and_set_bit(0, &amp;hardlockup_allcpu_dumped))  
</span></span><span class=line><span class=cl>            trigger_allbutself_cpu_backtrace();  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>        if (hardlockup_panic)  
</span></span><span class=line><span class=cl>            panic(&#34;Hard LOCKUP&#34;);  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>        __this_cpu_write(hard_watchdog_warn, true);  
</span></span><span class=line><span class=cl>        return;  
</span></span><span class=line><span class=cl>    }  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    __this_cpu_write(hard_watchdog_warn, false);  
</span></span><span class=line><span class=cl>    return;  
</span></span><span class=line><span class=cl>}  
</span></span><span class=line><span class=cl>#endif /* CONFIG_HARDLOCKUP_DETECTOR_NMI */ 
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl>#ifdef CONFIG_HARDLOCKUP_DETECTOR_NMI  
</span></span><span class=line><span class=cl>/* watchdog detector functions */  
</span></span><span class=line><span class=cl>static bool is_hardlockup(void)  
</span></span><span class=line><span class=cl>{  
</span></span><span class=line><span class=cl>    unsigned long hrint = __this_cpu_read(hrtimer_interrupts);  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    if (__this_cpu_read(hrtimer_interrupts_saved) == hrint)  
</span></span><span class=line><span class=cl>        return true;  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>    __this_cpu_write(hrtimer_interrupts_saved, hrint);  
</span></span><span class=line><span class=cl>    return false;  
</span></span><span class=line><span class=cl>}  
</span></span><span class=line><span class=cl>#endif  
</span></span></code></pre></td></tr></table></div></div><p>è€Œè¿™ä¸ªå‡½æ•°ä¸»è¦å°±æ˜¯æŸ¥çœ‹hrtimer_interruptså˜é‡åœ¨æ—¶é’Ÿä¸­æ–­å¤„ç†å‡½æ•°é‡Œæœ‰æ²¡æœ‰è¢«æ›´æ–°ã€‚å‡å¦‚æ²¡æœ‰æ›´æ–°ï¼Œå°±æ„å‘³ç€ä¸­æ–­å‡ºäº†é—®é¢˜ï¼Œå¯èƒ½è¢«é”™è¯¯ä»£ç é•¿æ—¶é—´çš„å…³ä¸­æ–­äº†ã€‚é‚£è¿™æ ·ï¼Œç›¸åº”çš„é—®é¢˜ä¹Ÿå°±æš´éœ²å‡ºæ¥äº†ã€‚</p><h2 id=å››-æ¡ˆä¾‹åˆ†æ>å›› æ¡ˆä¾‹åˆ†æ</h2><p>å‡ºç°panicçš„dmesgä¿¡æ¯å¦‚ä¸‹:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[5561883.978551] NMI watchdog: Watchdog detected hard LOCKUP on cpu 15  
</span></span><span class=line><span class=cl>[5561883.978593] Modules linked in:  
</span></span><span class=line><span class=cl>[5561883.978598]  dm_mod sctp_diag sctp dccp_diag dccp tcp_diag udp_diag inet_diag unix_diag af_packet_diag netlink_diag iptable_filter binfmt_misc bonding skx_edac edac_core intel_powerclamp coretemp intel_rapl iTCO_wdt iosf_mbi kvm_intel iTCO_vendor_support kvm dcdbas irqbypass crc32_pclmul ghash_clmulni_intel aesni_intel lrw gf128mul glue_helper ablk_helper cryptd sg ipmi_ssif pcspkr ipmi_si shpchp ipmi_devintf mei_me ipmi_msghandler mei lpc_ich nfit i2c_i801 libnvdimm acpi_power_meter acpi_pad ip_tables xfs libcrc32c sd_mod crc_t10dif crct10dif_generic mgag200 i2c_algo_bit drm_kms_helper crct10dif_pclmul syscopyarea crct10dif_common sysfillrect crc32c_intel sysimgblt fb_sys_fops ttm i40e drm ahci libahci tg3 libata megaraid_sas ptp i2c_core pps_core  
</span></span><span class=line><span class=cl>[5561883.978652] CPU: 15 PID: 0 Comm: swapper/15 Not tainted 3.10.0-693.el7.x86_64 #1  
</span></span><span class=line><span class=cl>[5561883.978654] Hardware name: Dell Inc. PowerEdge R540/0NJK2F, BIOS 1.3.7 02/09/2018  
</span></span><span class=line><span class=cl>[5561883.978657] task: ffff88289bb1bf40 ti: ffff88289bb90000 task.ti: ffff88289bb90000  
</span></span><span class=line><span class=cl>[5561883.978659] RIP: 0010:[&lt;ffffffff810bf107&gt;]  [&lt;ffffffff810bf107&gt;] finish_task_switch+0x57/0x160  
</span></span><span class=line><span class=cl>[5561883.978671] RSP: 0000:ffff88289bb93e48  EFLAGS: 00000286  
</span></span><span class=line><span class=cl>[5561883.978672] RAX: ffff882899e0dee0 RBX: ffffffff810b4155 RCX: 0000000000000000  
</span></span><span class=line><span class=cl>[5561883.978673] RDX: ffff88289bb91fd8 RSI: ffff88289bb1bf40 RDI: ffff883fdbfd6cc0  
</span></span><span class=line><span class=cl>[5561883.978675] RBP: ffff88289bb93e68 R08: ffff88289bb90000 R09: 0000000000000002  
</span></span><span class=line><span class=cl>[5561883.978676] R10: 000000000000000f R11: 0000000000000000 R12: ffff883fdbfcfe80  
</span></span><span class=line><span class=cl>[5561883.978677] R13: ffff883fdbfcf960 R14: ffffffff8132bfe0 R15: ffff88289bb93db8  
</span></span><span class=line><span class=cl>[5561883.978679] FS:  0000000000000000(0000) GS:ffff883fdbfc0000(0000) knlGS:0000000000000000  
</span></span><span class=line><span class=cl>[5561883.978680] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033  
</span></span><span class=line><span class=cl>[5561883.978682] CR2: 00007f3fe8b4aff8 CR3: 00000004981d8000 CR4: 00000000003407e0  
</span></span><span class=line><span class=cl>[5561883.978683] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000  
</span></span><span class=line><span class=cl>[5561883.978684] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400  
</span></span><span class=line><span class=cl>[5561883.978685] Stack:  
</span></span><span class=line><span class=cl>[5561883.978686]  0000000000000000 ffff883fdbfd6cc0 ffff88026b7ce400 0000000000000000  
</span></span><span class=line><span class=cl>[5561883.978689]  ffff88289bb93ec8 ffffffff816a8f8d ffff88289bb1bf40 ffff88289bb93fd8  
</span></span><span class=line><span class=cl>[5561883.978691]  ffff88289bb93fd8 ffff88289bb93fd8 ffff88289bb1bf40 ffffffff81b1c820  
</span></span><span class=line><span class=cl>[5561883.978694] Call Trace:  
</span></span><span class=line><span class=cl>[5561883.978700]  [&lt;ffffffff816a8f8d&gt;] __schedule+0x39d/0x8b0  
</span></span><span class=line><span class=cl>[5561883.978703]  [&lt;ffffffff816aa3e9&gt;] schedule_preempt_disabled+0x29/0x70  
</span></span><span class=line><span class=cl>[5561883.978710]  [&lt;ffffffff810e7c0a&gt;] cpu_startup_entry+0x18a/0x1c0  
</span></span><span class=line><span class=cl>[5561883.978715]  [&lt;ffffffff81051af6&gt;] start_secondary+0x1b6/0x230  
</span></span><span class=line><span class=cl>[5561883.978717] Code: 1f 44 00 00 65 48 8b 34 25 00 ce 00 00 0f 1f 44 00 00 41 c7 45 28 00 00 00 00 48 89 df c6 07 00 0f 1f 40 00 fb 66 0f 1f 44 00 00 &lt;65&gt; 48 8b 04 25 00 ce 00 00 48 8b 98 78 01 00 00 48 85 db 74 1c  
</span></span><span class=line><span class=cl>[5561883.978741] Kernel panic - not syncing: Hard LOCKUP  
</span></span><span class=line><span class=cl>[5561883.978767] CPU: 15 PID: 0 Comm: swapper/15 Not tainted 3.10.0-693.el7.x86_64 #1  
</span></span><span class=line><span class=cl>[5561883.978802] Hardware name: Dell Inc. PowerEdge R540/0NJK2F, BIOS 1.3.7 02/09/2018  
</span></span><span class=line><span class=cl>[5561883.978837]  ffff88289bb93d00 d5511a25db39e950 ffff883fdbfc5b18 ffffffff816a3d91  
</span></span><span class=line><span class=cl>[5561883.978879]  ffff883fdbfc5b98 ffffffff8169dc54 0000000000000010 ffff883fdbfc5ba8  
</span></span><span class=line><span class=cl>[5561883.978923]  ffff883fdbfc5b48 d5511a25db39e950 0000000000000000 ffffffff8190ac0f  
</span></span><span class=line><span class=cl>[5561883.978966] Call Trace:  
</span></span><span class=line><span class=cl>[5561883.978980]  &lt;NMI&gt;  [&lt;ffffffff816a3d91&gt;] dump_stack+0x19/0x1b  
</span></span><span class=line><span class=cl>[5561883.979019]  [&lt;ffffffff8169dc54&gt;] panic+0xe8/0x20d  
</span></span><span class=line><span class=cl>[5561883.979046]  [&lt;ffffffff8108771f&gt;] nmi_panic+0x3f/0x40  
</span></span><span class=line><span class=cl>[5561883.979073]  [&lt;ffffffff8112fa75&gt;] watchdog_overflow_callback+0xf5/0x100  
</span></span><span class=line><span class=cl>[5561883.979108]  [&lt;ffffffff8116e561&gt;] __perf_event_overflow+0x51/0xf0  
</span></span><span class=line><span class=cl>[5561883.979139]  [&lt;ffffffff811770b4&gt;] perf_event_overflow+0x14/0x20  
</span></span><span class=line><span class=cl>[5561883.979170]  [&lt;ffffffff81009f78&gt;] intel_pmu_handle_irq+0x218/0x4f0  
</span></span><span class=line><span class=cl>[5561883.979204]  [&lt;ffffffff81324abc&gt;] ? ioremap_page_range+0x26c/0x3d0  
</span></span><span class=line><span class=cl>[5561883.979236]  [&lt;ffffffff811c0a04&gt;] ? vunmap_page_range+0x1b4/0x300  
</span></span><span class=line><span class=cl>[5561883.979266]  [&lt;ffffffff811c0b61&gt;] ? unmap_kernel_range_noflush+0x11/0x20  
</span></span><span class=line><span class=cl>[5561883.979300]  [&lt;ffffffff813da15e&gt;] ? ghes_copy_tofrom_phys+0x10e/0x210  
</span></span><span class=line><span class=cl>[5561883.979332]  [&lt;ffffffff813da300&gt;] ? ghes_read_estatus+0xa0/0x190  
</span></span><span class=line><span class=cl>[5561883.979363]  [&lt;ffffffff816ac06b&gt;] perf_event_nmi_handler+0x2b/0x50  
</span></span><span class=line><span class=cl>[5561883.979394]  [&lt;ffffffff816ad427&gt;] nmi_handle.isra.0+0x87/0x160  
</span></span><span class=line><span class=cl>[5561883.979424]  [&lt;ffffffff816ad710&gt;] do_nmi+0x210/0x450  
</span></span><span class=line><span class=cl>[5561883.979451]  [&lt;ffffffff810c89b0&gt;] ? task_scan_max+0x40/0x40  
</span></span><span class=line><span class=cl>[5561883.979480]  [&lt;ffffffff816ac8d3&gt;] end_repeat_nmi+0x1e/0x2e  
</span></span><span class=line><span class=cl>[5561883.979508]  [&lt;ffffffff810c89b0&gt;] ? task_scan_max+0x40/0x40  
</span></span><span class=line><span class=cl>[5561883.979536]  [&lt;ffffffff810c89ce&gt;] ? tg_unthrottle_up+0x1e/0x50  
</span></span><span class=line><span class=cl>[5561883.979566]  [&lt;ffffffff810c89ce&gt;] ? tg_unthrottle_up+0x1e/0x50  
</span></span><span class=line><span class=cl>[5561883.979595]  [&lt;ffffffff810c89ce&gt;] ? tg_unthrottle_up+0x1e/0x50  
</span></span><span class=line><span class=cl>[5561883.979624]  &lt;&lt;EOE&gt;&gt;  &lt;IRQ&gt;  [&lt;ffffffff810c0bcb&gt;] walk_tg_tree_from+0x7b/0x110  
</span></span><span class=line><span class=cl>[5561883.979666]  [&lt;ffffffff810ba190&gt;] ? __smp_mb__after_atomic+0x10/0x10  
</span></span><span class=line><span class=cl>[5561883.979698]  [&lt;ffffffff810d0977&gt;] unthrottle_cfs_rq+0xb7/0x170  
</span></span><span class=line><span class=cl>[5561883.979726]  [&lt;ffffffff810d0bfa&gt;] distribute_cfs_runtime+0x10a/0x130  
</span></span><span class=line><span class=cl>[5561883.979759]  [&lt;ffffffff810d0da7&gt;] sched_cfs_period_timer+0xb7/0x150  
</span></span><span class=line><span class=cl>[5561883.979790]  [&lt;ffffffff810d0cf0&gt;] ? sched_cfs_slack_timer+0xd0/0xd0  
</span></span><span class=line><span class=cl>[5561883.979822]  [&lt;ffffffff810b4ae4&gt;] __hrtimer_run_queues+0xd4/0x260  
</span></span><span class=line><span class=cl>[5561883.979853]  [&lt;ffffffff810b507f&gt;] hrtimer_interrupt+0xaf/0x1d0  
</span></span><span class=line><span class=cl>[5561883.979883]  [&lt;ffffffff81053895&gt;] local_apic_timer_interrupt+0x35/0x60  
</span></span><span class=line><span class=cl>[5561883.979917]  [&lt;ffffffff816b76bd&gt;] smp_apic_timer_interrupt+0x3d/0x50  
</span></span><span class=line><span class=cl>[5561883.979949]  [&lt;ffffffff816b5c1d&gt;] apic_timer_interrupt+0x6d/0x80  
</span></span><span class=line><span class=cl>[5561883.979977]  &lt;EOI&gt;  [&lt;ffffffff810b4155&gt;] ? enqueue_hrtimer+0x25/0x80  
</span></span><span class=line><span class=cl>[5561883.980013]  [&lt;ffffffff810bf107&gt;] ? finish_task_switch+0x57/0x160  
</span></span><span class=line><span class=cl>[5561883.980044]  [&lt;ffffffff816a8f8d&gt;] __schedule+0x39d/0x8b0  
</span></span><span class=line><span class=cl>[5561883.980071]  [&lt;ffffffff816aa3e9&gt;] schedule_preempt_disabled+0x29/0x70  
</span></span><span class=line><span class=cl>[5561883.981014]  [&lt;ffffffff810e7c0a&gt;] cpu_startup_entry+0x18a/0x1c0  
</span></span><span class=line><span class=cl>[5561883.981889]  [&lt;ffffffff81051af6&gt;] start_secondary+0x1b6/0x230  
</span></span></code></pre></td></tr></table></div></div><p>å¯ä»¥çœ‹åˆ°æ˜¯hard lockup, çœ‹dumpå‡ºæ¥çš„æ ˆä¿¡æ¯,å¯ä»¥åŸºæœ¬åˆ¤æ–­æ˜¯å‡ºç°cfsåœ¨åšunthrottleçš„æ—¶å€™å‡ºç°çš„é—®é¢˜. å› ä¸ºcfsæ£€æµ‹throttleæ˜¯å®šæ—¶ä¸­æ–­å‘¨æœŸæ€§æ£€æµ‹çš„,å¯¼è‡´hard lockup hrtimer_interruptså˜é‡é•¿æ—¶é—´æ²¡æœ‰æ›´æ–°. å³ç³»ç»Ÿåœ¨ç»™è¿›ç¨‹é‡æ–°åˆ†æè°ƒåº¦æ—¶é—´çš„æ—¶å€™å‡ºç°çš„é—®é¢˜. ä»…ä»…æ˜¯æ€€ç–‘,æ²¡æœ‰ç°åœºå’Œä½¿ç”¨crash toolå»debug. åç»­åœ¨update.</p></article><hr><div class=page-end><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div></div><div id=contact_buttons><footer><p>Made by Jacky Zhao using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2022</p><ul><li><a href=/>Home</a></li><li><a href=https://twitter.com/_jzhao>Twitter</a></li><li><a href=https://github.com/jackyzha0>Github</a></li></ul></footer></div><script src=https://lzyerste.github.io/quartz/js/popover.e57188d2e4c06b0654e020b3a734bb62.min.js></script>
<script>initPopover("https://lzyerste.github.io/quartz")</script></div></body></html>