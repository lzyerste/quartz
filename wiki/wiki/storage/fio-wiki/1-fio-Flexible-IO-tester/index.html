<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="1. fio - Flexible IO tester rev. 3.25 1. fio - Flexible I/O tester rev. 3.25 1.1. Overview and history Fio was originally written to save me the hassle of writing special test case programs when I wanted to test a specific workload, either for performance reasons or to find/reproduce a bug."><title>1_fio_-_Flexible_IO_tester</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://lzyerste.github.io/quartz//icon.png><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Source+Sans+Pro:wght@400;600;700&family=Fira+Code:wght@400;700&display=swap" rel=stylesheet><link href=https://lzyerste.github.io/quartz/styles.48db36360688fe00f0a39f3cf1417c4b.min.css rel=stylesheet><script src=https://lzyerste.github.io/quartz/js/darkmode.46b07878b7f5d9e26ad7a3c40f8a0605.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})})</script><script>const BASE_URL="https://lzyerste.github.io/quartz/",fetchData=Promise.all([fetch("https://lzyerste.github.io/quartz/indices/linkIndex.d9d5859c0e0b3db667123f4df2b3a95c.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://lzyerste.github.io/quartz/indices/contentIndex.8142ea9941fd6973dd3e16e4214a0035.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n}))</script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://lzyerste.github.io/quartz/js/search.7861a82db330f0a40935b7458fee3a02.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://lzyerste.github.io/quartz/>ğŸª´ Quartz 3.2</a></h1><svg tabindex="0" id="search-icon" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg><div class=spacer></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>1_fio_-_Flexible_IO_tester</h1><p class=meta>Last updated May 1, 2022</p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#11-overview-and-history>1.1. Overview and history</a></li><li><a href=#12-source>1.2. Source</a></li><li><a href=#13-mailing-list>1.3. Mailing list</a></li><li><a href=#14-author>1.4. Author</a></li><li><a href=#15-binary-packages>1.5. Binary packages</a></li><li><a href=#16-building>1.6. Building</a><ol><li><a href=#161-windows>1.6.1. Windows</a></li><li><a href=#162-documentation>1.6.2. Documentation</a></li></ol></li><li><a href=#17-platforms>1.7. Platforms</a></li><li><a href=#18-running-fio>1.8. Running fio</a></li><li><a href=#19-how-fio-works>â¤1.9. How fio works</a></li><li><a href=#110-command-line-options>â¤1.10. Command line options</a></li><li><a href=#111-job-file-format>1.11. Job file format</a><ol><li><a href=#1111-environment-variables>1.11.1. Environment variables</a></li><li><a href=#1112-reserved-keywords>1.11.2. Reserved keywords</a></li></ol></li><li><a href=#112-job-file-parameters>â¤1.12. Job file parameters</a><ol><li><a href=#1121-parameter-types>1.12.1. Parameter types</a></li><li><a href=#1122-units>1.12.2. Units</a></li><li><a href=#1123-job-description>â¤1.12.3. Job description</a></li><li><a href=#1124-time-related-parameters>1.12.4. Time related parameters</a></li><li><a href=#1125-target-filedevice>1.12.5. Target file/device</a></li><li><a href=#1126-io-type>1.12.6. I/O type</a></li><li><a href=#1127-block-size>1.12.7. Block size</a></li><li><a href=#1128-buffers-and-memory>1.12.8. Buffers and memory</a></li><li><a href=#1129-io-size>1.12.9. I/O size</a></li><li><a href=#11210-io-engine>1.12.10. I/O engine</a></li><li><a href=#11211-io-engine-specific-parameters>1.12.11. I/O engine specific parameters</a></li><li><a href=#11212-io-depth>1.12.12. I/O depth</a></li><li><a href=#11213-io-rate>1.12.13. I/O rate</a></li><li><a href=#11214-io-latency>1.12.14. I/O latency</a></li><li><a href=#11215-io-replay>1.12.15. I/O replay</a></li><li><a href=#11216-threads-processes-and-job-synchronization>1.12.16. Threads, processes and job synchronization</a></li><li><a href=#11217-verification>1.12.17. Verification</a></li><li><a href=#11218-steady-state>1.12.18. Steady state</a></li><li><a href=#11219-measurements-and-reporting>1.12.19. Measurements and reporting</a></li><li><a href=#11220-error-handling>1.12.20. Error handling</a></li></ol></li><li><a href=#113-running-predefined-workloads>1.13. Running predefined workloads</a><ol><li><a href=#1131-act-profile-options>1.13.1. Act profile options</a></li><li><a href=#1132-tiobench-profile-options>1.13.2. Tiobench profile options</a></li></ol></li><li><a href=#114-interpreting-the-output>1.14. Interpreting the output</a></li><li><a href=#115-terse-output>1.15. Terse output</a></li><li><a href=#116-json-output>1.16. JSON output</a></li><li><a href=#117-json-output>1.17. JSON+ output</a></li><li><a href=#118-trace-file-format>1.18. Trace file format</a><ol><li><a href=#1181-trace-file-format-v1>1.18.1. Trace file format v1</a></li><li><a href=#1182-trace-file-format-v2>1.18.2. Trace file format v2</a></li></ol></li><li><a href=#119-io-replay---merging-traces>1.19. I/O Replay - Merging Traces</a></li><li><a href=#120-cpu-idleness-profiling>1.20. CPU idleness profiling</a></li><li><a href=#121-verification-and-triggers>1.21. Verification and triggers</a><ol><li><a href=#1211-verification-trigger-example>1.21.1. Verification trigger example</a></li><li><a href=#1212-loading-verify-state>1.21.2. Loading verify state</a></li></ol></li><li><a href=#122-log-file-formats>1.22. Log File Formats</a></li><li><a href=#123-clientserver>1.23. Client/Server</a></li></ol><ol><li><a href=#21-poisson-request-flow>2.1. Poisson request flow</a></li><li><a href=#22-latency-profile>2.2. Latency profile</a></li><li><a href=#23-read-4-files-with-aio-at-different-depths>2.3. Read 4 files with aio at different depths</a></li><li><a href=#24-read-backwards-in-a-file>2.4. Read backwards in a file</a></li><li><a href=#25-basic-verification>2.5. Basic verification</a></li><li><a href=#26-fixed-rate-submission>2.6. Fixed rate submission</a></li><li><a href=#27-butterfly-seek-pattern>2.7. Butterfly seek pattern</a></li></ol><ol><li><a href=#31-gfio-todo>3.1. GFIO TODO</a></li><li><a href=#32-server-todo>3.2. Server TODO</a></li><li><a href=#33-steady-state-todo>3.3. Steady State TODO</a></li></ol></nav></details></aside><h1 id=1-fio---flexible-io-tester-rev-325>1. fio - Flexible IO tester rev. 3.25</h1><h1 id=1-fio---flexible-io-tester-rev-325-1>1. fio - Flexible I/O tester rev. 3.25</h1><h2 id=11-overview-and-history>1.1. Overview and history</h2><p>Fio was originally written to save me the hassle of writing special test case programs when I wanted to test a specific workload, either for performance reasons or to find/reproduce a bug. The process of writing such a test app can be tiresome, especially if you have to do it often. Hence I needed a tool that would be able to simulate a given I/O workload without resorting to writing a tailored test case again and again.</p><p>A test work load is difficult to define, though. There can be any number of processes or threads involved, and they can each be using their own way of generating I/O. You could have someone dirtying large amounts of memory in an memory mapped file, or maybe several threads issuing reads using asynchronous I/O. fio needed to be <code>flexible</code> enough to simulate both of these cases, and many more.</p><p>Fio spawns a number of threads or processes doing a particular type of I/O action as specified by the user. fio takes a number of <code>global parameters</code>, each inherited by the thread unless otherwise parameters given to them <code>overriding</code> that setting is given. The typical use of fio is to write a job file matching the I/O load one wants to simulate.</p><h2 id=12-source>1.2. Source</h2><p>Fio resides in a git repo, the canonical place is:</p><blockquote><p>git://git.kernel.dk/fio.git</p></blockquote><p>When inside a corporate firewall, git:// URL sometimes does not work. If git:// does not work, use the http protocol instead:</p><blockquote><p><a href=http://git.kernel.dk/fio.git rel=noopener>http://git.kernel.dk/fio.git</a></p></blockquote><p>Snapshots are frequently generated and <code>fio-git-*.tar.gz</code> include the git meta data as well. Other tarballs are archives of official fio releases. Snapshots can download from:</p><blockquote><p><a href=http://brick.kernel.dk/snaps/ rel=noopener>http://brick.kernel.dk/snaps/</a></p></blockquote><p>There are also two official mirrors. Both of these are automatically synced with the main repository, when changes are pushed. If the main repo is down for some reason, either one of these is safe to use as a backup:</p><blockquote><p>git://git.kernel.org/pub/scm/linux/kernel/git/axboe/fio.git
<a href=https://git.kernel.org/pub/scm/linux/kernel/git/axboe/fio.git rel=noopener>https://git.kernel.org/pub/scm/linux/kernel/git/axboe/fio.git</a></p></blockquote><p>or</p><blockquote><p>git://github.com/axboe/fio.git
<a href=https://github.com/axboe/fio.git rel=noopener>https://github.com/axboe/fio.git</a></p></blockquote><h2 id=13-mailing-list>1.3. Mailing list</h2><p>The fio project mailing list is meant for anything related to fio including general discussion, bug reporting, questions, and development. For bug reporting, see REPORTING-BUGS.</p><p>An automated mail detailing recent commits is automatically sent to the list at most <code>daily</code>. The list address is
<a rel=noopener class="internal-link broken" data-src=mailto:fio%40vger.kernel.org>fio@vger.kernel.org</a>, subscribe by sending an email to
<a rel=noopener class="internal-link broken" data-src=mailto:majordomo%40vger.kernel.org>majordomo@vger.kernel.org</a> with</p><blockquote><p>subscribe fio</p></blockquote><p>in the body of the email. Archives can be found here:</p><blockquote><p><a href=http://www.spinics.net/lists/fio/ rel=noopener>http://www.spinics.net/lists/fio/</a></p></blockquote><p>and archives for the old list can be found here:</p><blockquote><p><a href=http://maillist.kernel.dk/fio-devel/ rel=noopener>http://maillist.kernel.dk/fio-devel/</a></p></blockquote><h2 id=14-author>1.4. Author</h2><p>Fio was written by <code>Jens Axboe</code> &lt;
<a rel=noopener class="internal-link broken" data-src=mailto:axboe%40kernel.dk>axboe@kernel.dk</a>> to enable flexible testing of the Linux I/O subsystem and schedulers. He got tired of writing specific test applications to simulate a given workload, and found that the existing I/O benchmark/test tools out there werenâ€™t flexible enough to do what he wanted.</p><p>Jens Axboe &lt;
<a rel=noopener class="internal-link broken" data-src=mailto:axboe%40kernel.dk>axboe@kernel.dk</a>> 20060905</p><h2 id=15-binary-packages>1.5. Binary packages</h2><ul><li><p>Debian:</p><p>Starting with Debian â€œSqueezeâ€, fio packages are part of the official Debian repository.
<a href="http://packages.debian.org/search?keywords=fio" rel=noopener>http://packages.debian.org/search?keywords=fio</a> .</p></li><li><p><code>Ubuntu</code>:</p><p>Starting with Ubuntu 10.04 LTS (aka â€œLucid Lynxâ€), fio packages are part of the Ubuntu â€œuniverseâ€ repository.
<a href="http://packages.ubuntu.com/search?keywords=fio" rel=noopener>http://packages.ubuntu.com/search?keywords=fio</a> .</p></li><li><p>Red Hat, Fedora, <code>CentOS</code> & Co:</p><p>Starting with Fedora 9/Extra Packages for Enterprise Linux 4, fio packages are part of the Fedora/EPEL repositories.
<a href=https://apps.fedoraproject.org/packages/fio rel=noopener>https://apps.fedoraproject.org/packages/fio</a> .</p></li><li><p>Mandriva:</p><p>Mandriva has integrated fio into their package repository, so installing on that distro should be as easy as typing <code>urpmi fio</code>.</p></li><li><p>Arch Linux:</p><p>An Arch Linux package is provided under the Community sub-repository:
<a href="https://www.archlinux.org/packages/?sort=&q=fio" rel=noopener>https://www.archlinux.org/packages/?sort=&q=fio</a></p></li><li><p>Solaris:</p><p>Packages for Solaris are available from OpenCSW. Install their pkgutil tool (
<a href=http://www.opencsw.org/get-it/pkgutil/ rel=noopener>http://www.opencsw.org/get-it/pkgutil/</a>) and then install fio via <code>pkgutil -i fio</code>.</p></li><li><p><code>Windows</code>:</p><p>Rebecca Cran &lt;
<a rel=noopener class="internal-link broken" data-src=mailto:rebecca%40bsdio.com>rebecca@bsdio.com</a>> has fio packages for Windows at
<a href=https://bsdio.com/fio/ rel=noopener>https://bsdio.com/fio/</a> . The latest builds for Windows can also be grabbed from
<a href=https://ci.appveyor.com/project/axboe/fio rel=noopener>https://ci.appveyor.com/project/axboe/fio</a> by clicking the latest x86 or x64 build, then selecting the ARTIFACTS tab.</p></li><li><p>BSDs:</p><p>Packages for BSDs may be available from their binary package repositories. Look for a package â€œfioâ€ using their binary package managers.</p></li></ul><h2 id=16-building>1.6. Building</h2><p>Just type:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ ./configure
</span></span><span class=line><span class=cl>$ make
</span></span><span class=line><span class=cl>$ make install
</span></span></code></pre></td></tr></table></div></div><p>Note that GNU make is required. On BSDs itâ€™s available from devel/gmake within ports directory; on Solaris itâ€™s in the SUNWgmake package. On platforms where GNU make isnâ€™t the default, type <code>gmake</code> instead of <code>make</code>.</p><p>Configure will print the enabled options. Note that on Linux based platforms, the <code>libaio</code> development packages must be installed to use the libaio engine. Depending on distro, it is usually called libaio-devel or libaio-dev.</p><blockquote><p>ubuntuä¸‹å®‰è£…ï¼š
sudo apt install libaio-dev
æ³¨æ„ï¼Œznsæ¨¡å¼ä¸‹fioåˆ‡åˆ°3.27ç‰ˆæœ¬</p></blockquote><p>For <code>gfio</code>, gtk 2.18 (or newer), associated glib threads, and cairo are required to be installed. gfio isnâ€™t built automatically and can be enabled with a <code>--enable-gfio</code> option to configure.</p><p>To build fio with a <code>cross-compiler</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ make clean
</span></span><span class=line><span class=cl>$ make CROSS_COMPILE=/path/to/toolchain/prefix
</span></span></code></pre></td></tr></table></div></div><p>Configure will attempt to determine the target platform automatically.</p><p>Itâ€™s possible to build fio for ESX as well, use the <code>--esx</code> switch to configure.</p><h3 id=161-windows>1.6.1. Windows</h3><p>The minimum versions of Windows for building/runing fio are Windows 7/Windows Server 2008 R2. On Windows, <code>Cygwin</code> (
<a href=https://www.cygwin.com/ rel=noopener>https://www.cygwin.com/</a>) is required in order to build fio. To create an MSI installer package install WiX from
<a href=https://wixtoolset.org/ rel=noopener>https://wixtoolset.org</a> and run <code>dobuild.cmd</code> from the <code>os/windows</code> directory.</p><p>How to compile fio on <code>64-bit</code> Windows:</p><ol><li>Install Cygwin (
<a href=http://www.cygwin.com/ rel=noopener>http://www.cygwin.com/</a>). Install <code>make</code> and all packages starting with <code>mingw64-x86_64</code>. Ensure <code>mingw64-x86_64-zlib</code> are installed if you wish to enable fioâ€™s log compression functionality.</li><li>Open the Cygwin Terminal.</li><li>Go to the fio directory (source files).</li><li>Run <code>make clean && make -j</code>.</li></ol><p>To build fio for <code>32-bit</code> Windows, ensure the <code>-i686</code> versions of the previously mentioned -x86_64 packages are installed and run <code>./configure --build-32bit-win</code> before <code>make</code>.</p><p>Itâ€™s recommended that once built or installed, fio be run in a Command Prompt or other â€˜nativeâ€™ console such as console2, since there are known to be display and signal issues when running it under a Cygwin shell (see
<a href=https://github.com/mintty/mintty/issues/56 rel=noopener>https://github.com/mintty/mintty/issues/56</a> and
<a href=https://github.com/mintty/mintty/wiki/Tips#inputoutput-interaction-with-alien-programs rel=noopener>https://github.com/mintty/mintty/wiki/Tips#inputoutput-interaction-with-alien-programs</a> for details).</p><h3 id=162-documentation>1.6.2. Documentation</h3><p>Fio uses
<a href=http://www.sphinx-doc.org/ rel=noopener>Sphinx</a> to generate documentation from the
<a href=http://www.sphinx-doc.org/rest.html rel=noopener>reStructuredText</a> files. To build HTML formatted documentation run <code>make -C doc html</code> and direct your browser to <code>./doc/output/html/index.html</code>. To build manual page run <code>make -C doc man</code> and then <code>man doc/output/man/fio.1</code>. To see what other output formats are supported run <code>make -C doc help</code>.</p><h2 id=17-platforms>1.7. Platforms</h2><p>Fio works on (at least) <code>Linux</code>, Solaris, AIX, HP-UX, <code>OSX</code>, NetBSD, OpenBSD, <code>Windows</code>, FreeBSD, and DragonFly. Some features and/or options may only be available on some of the platforms, typically because those features only apply to that platform (like the solarisaio engine, or the splice engine on Linux).</p><p>Some features are not available on FreeBSD/Solaris even if they could be implemented, Iâ€™d be happy to take patches for that. An example of that is <code>disk utility statistics</code> and (I think) <code>huge page support</code>, support for that does exist in FreeBSD/Solaris.</p><p>Fio uses <code>pthread mutexes</code> for signalling and locking and some platforms do not support process shared pthread mutexes. As a result, on such platforms only threads are supported. This could be fixed with sysv ipc locking or other locking alternatives.</p><blockquote><p>è¿™æ˜¯è¯´fioçš„å¤šè¿›ç¨‹æ¨¡å‹ä¹Ÿæ˜¯é€šè¿‡pthread mutexæ¥äº¤äº’ï¼Ÿå¦‚æœä¸æ”¯æŒçš„è¯ï¼Œé‚£å°±åªèƒ½ä½¿ç”¨å¤šçº¿ç¨‹æ¨¡å‹ã€‚</p></blockquote><p>Other *BSD platforms are untested, but fio should work there almost out of the box. Since I donâ€™t do test runs or even compiles on those platforms, your mileage may vary. Sending me patches for other platforms is greatly appreciated. Thereâ€™s a lot of value in having the same test/benchmark tool available on all platforms.</p><p>Note that POSIX aio is not enabled by default on AIX. Messages like these:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Symbol resolution failed for /usr/lib/libc.a(posix_aio.o) because:
</span></span><span class=line><span class=cl>    Symbol _posix_kaio_rdwr (number 2) is not exported from dependent module /unix.
</span></span></code></pre></td></tr></table></div></div><p>indicate one needs to enable POSIX aio. Run the following commands as root:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># lsdev -C -l posix_aio0</span>
</span></span><span class=line><span class=cl>    posix_aio0 Defined  Posix Asynchronous I/O
</span></span><span class=line><span class=cl><span class=c1># cfgmgr -l posix_aio0</span>
</span></span><span class=line><span class=cl><span class=c1># lsdev -C -l posix_aio0</span>
</span></span><span class=line><span class=cl>    posix_aio0 Available  Posix Asynchronous I/O
</span></span></code></pre></td></tr></table></div></div><p>POSIX aio should work now. To make the change permanent:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># chdev -l posix_aio0 -P -a autoconfig=&#39;available&#39;</span>
</span></span><span class=line><span class=cl>    posix_aio0 changed
</span></span></code></pre></td></tr></table></div></div><h2 id=18-running-fio>1.8. Running fio</h2><p>Running fio is normally the easiest part - you just give it the job file (or job files) as parameters:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ fio [options] [jobfile] ...
</span></span></code></pre></td></tr></table></div></div><p>and it will start doing what the <em><code>jobfile</code></em> tells it to do. You can give more than one job file on the command line, fio will serialize the running of those files. Internally that is the same as using the <code>[stonewall](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-stonewall)</code> parameter described in the parameter section.</p><blockquote><p>ä¸€ä¸ªjobfileç›¸å½“äºä¸€æ¬¡workloadã€‚workloadé—´é¡ºåºä¸€ä¸ªä¸ªæ‰§è¡Œã€‚workloadå†…éƒ¨æœ‰å¤šä¸ªjobåŒæ—¶æ‰§è¡Œã€‚</p></blockquote><p>If the job file contains only one job, you may as well just give the parameters on the command line. The command line parameters are identical to the job parameters, with a few extra that control global parameters. For example, for the job file parameter <code>[iodepth=2](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-iodepth)</code>, the mirror command line option would be <code>[--iodepth 2](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-iodepth)</code> or <code>[--iodepth=2](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-iodepth)</code>. You can also use the command line for giving more than one job entry. For each <code>[--name](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-name)</code> option that fio sees, it will start a new job with that name. Command line entries following a <code>[--name](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-name)</code> entry will apply to that job, until there are no more entries or a new <code>[--name](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-name)</code> entry is seen. This is similar to the job file options, where each option applies to the current job until a new [] job entry is seen.</p><blockquote><p>å¯ä»¥ç›´æ¥åœ¨å‘½ä»¤è¡Œé‡Œè¿è¡Œjobï¼Œ<code>--name</code>ç›¸å½“äºjobçš„åˆ†ç•Œçº¿ã€‚é‚£ä¹ˆç¬¬ä¸€ä¸ªjobå‰é¢çš„å‚æ•°ä»£è¡¨global parameterä¹ˆï¼Ÿ</p></blockquote><p>fio does not need to run as root, except if the files or devices specified in the job section requires that. Some other options may also be restricted, such as memory locking, I/O scheduler switching, and decreasing the nice value.</p><p>If <em>jobfile</em> is specified as <code>-</code>, the job file will be read from standard input.</p><h2 id=19-how-fio-works>â¤1.9. How fio works</h2><p>The first step in getting fio to simulate a desired I/O workload, is <code>writing a job file</code> describing that specific setup. A job file may contain any number of threads and/or files â€“ the typical contents of the job file is a *<code>global* section</code> defining shared parameters, and one or more <code>job sections</code> describing the jobs involved. When run, fio parses this file and sets everything up as described. If we break down a job from top to bottom, it contains the following basic parameters:</p><p><a href=https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-type rel=noopener><code>I/O type</code></a></p><blockquote><p>Defines the I/O pattern issued to the file(s). We may only be reading sequentially from this file(s), or we may be writing randomly. Or even mixing reads and writes, sequentially or randomly. Should we be doing buffered I/O, or direct/raw I/O?
è¯»å†™ç±»å‹ï¼Œæ¯”å¦‚è¯»è¿˜æ˜¯å†™è¿˜æ˜¯æ··åˆï¼Œé¡ºåºè¿˜æ˜¯éšæœºã€‚</p></blockquote><p><a href=https://fio.readthedocs.io/en/latest/fio_doc.html#block-size rel=noopener><code>Block size</code></a></p><blockquote><p>In how large chunks are we issuing I/O? This may be a single value, or it may describe a range of block sizes.
é»˜è®¤å•ä½æ˜¯å­—èŠ‚ï¼Œä¹Ÿå¯ä»¥è·Ÿä¸Šå•ä½ï¼Œæ¯”å¦‚8kã€‚
å¤§å°ä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªèŒƒå›´ï¼Œæ¯”å¦‚bsrange=1k-4k</p></blockquote><p><a href=https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-size rel=noopener><code>I/O size</code></a></p><blockquote><p>How much data are we going to be reading/writing.
æ³¨æ„ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªIOè¯·æ±‚çš„å¤§å°ï¼Œè€Œæ˜¯jobçš„è¯»å†™èŒƒå›´ã€‚</p></blockquote><p><a href=https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-engine rel=noopener><code>I/O engine</code></a></p><blockquote><p>How do we issue I/O? We could be memory mapping the file, we could be using regular read/write, we could be using splice, async I/O, or even SG (SCSI generic sg).</p></blockquote><p><a href=https://fio.readthedocs.io/en/latest/fio_doc.html#i-o-depth rel=noopener><code>I/O depth</code></a></p><blockquote><p>If the I/O engine is <code>async</code>, how large a <code>queuing depth</code> do we want to maintain?</p></blockquote><p><a href=https://fio.readthedocs.io/en/latest/fio_doc.html#target-file-device rel=noopener><code>Target file/device</code></a></p><blockquote><p>How many files are we spreading the workload over.
æ¯ä¸ªjobä¸€ä¸ªæ–‡ä»¶å—ï¼Ÿè¿˜æ˜¯ä¸€ç»„æ–‡ä»¶æ‹¼æ¥æˆä¸€ä¸ªå¤§çš„èŒƒå›´ï¼Ÿ</p></blockquote><p><a href=https://fio.readthedocs.io/en/latest/fio_doc.html#threads-processes-and-job-synchronization rel=noopener><code>Threads, processes and job synchronization</code></a></p><blockquote><p>How many threads or processes should we spread this workload over.</p></blockquote><p>The above are the basic parameters defined for a workload, in addition thereâ€™s a multitude of parameters that modify other aspects of how this job behaves.</p><h2 id=110-command-line-options>â¤1.10. Command line options</h2><ul><li><p><code>--debug=type</code></p><p>Enable verbose tracing type of various fio actions. May be <code>all</code> for all types or individual types separated by a comma (e.g.Â <code>--debug=file,mem</code> will enable file and memory debugging). Currently, additional logging is available for:</p><ul><li><em>process</em><ul><li>Dump info related to processes.</li></ul></li><li><em>file</em><ul><li>Dump info related to file actions.</li></ul></li><li><em>io</em><ul><li>Dump info related to I/O queuing.</li></ul></li><li><em>mem</em><ul><li>Dump info related to memory allocations.</li></ul></li><li><em>blktrace</em><ul><li>Dump info related to blktrace setup.</li></ul></li><li><em>verify</em><ul><li>Dump info related to I/O verification.</li></ul></li><li><em>all</em><ul><li>Enable all debug options.</li></ul></li><li><em>random</em><ul><li>Dump info related to random offset generation.</li></ul></li><li><em>parse</em><ul><li>Dump info related to option matching and parsing.</li></ul></li><li><em>diskutil</em><ul><li>Dump info related to disk utilization updates.</li></ul></li><li><em>job:x</em><ul><li>Dump info only related to job number x.</li></ul></li><li><em>mutex</em><ul><li>Dump info only related to mutex up/down ops.</li></ul></li><li><em>profile</em><ul><li>Dump info related to profile extensions.</li></ul></li><li><em>time</em><ul><li>Dump info related to internal time keeping.</li></ul></li><li><em>net</em><ul><li>Dump info related to networking connections.</li></ul></li><li><em>rate</em><ul><li>Dump info related to I/O rate switching.</li></ul></li><li><em>compress</em><ul><li>Dump info related to log compress/decompress.</li></ul></li><li><em>steadystate</em><ul><li>Dump info related to steadystate detection.</li></ul></li><li><em>helperthread</em><ul><li>Dump info related to the helper thread.</li></ul></li><li><em><code>zbd</code></em><ul><li>Dump info related to support for zoned block devices.</li></ul></li><li><em>?</em> or <em>help</em><ul><li>Show available debug options.</li></ul></li></ul></li><li><p><code>--parse-only</code></p><p>Parse options only, donâ€™t start any I/O.</p></li><li><p><code>â€“-merge-blktrace-only</code></p><p>Merge blktraces only, donâ€™t start any I/O.</p></li><li><p><code>--output=filename</code></p><p>Write output to file filename.</p></li><li><p><code>--output-format=format</code></p><p>Set the reporting format to normal, terse, <code>json</code>, or json+. Multiple formats can be selected, separated by a comma. terse is a CSV based format. json+ is like json, except it adds a full dump of the latency buckets.</p></li><li><p><code>â€“-bandwidth-log</code></p><p>Generate aggregate bandwidth logs.</p></li><li><p><code>â€“-minimal</code></p><p>Print statistics in a <code>terse</code>, semicolon-delimited format.</p></li><li><p><code>â€“-append-terse</code></p><p>Print statistics in selected mode AND terse, semicolon-delimited format. <strong><code>Deprecated</code></strong>, use <code>[--output-format](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-output-format)</code> instead to select multiple formats.</p></li><li><p><code>--terse-version=version</code></p><p>Set terse version output format (<code>default 3</code>, or 2 or 4 or 5).</p></li><li><p><code>â€“-version</code></p><p>Print version information and exit.</p></li><li><p><code>â€“-help</code></p><p>Print a summary of the command line options and exit.</p></li><li><p><code>â€“-cpuclock-test</code></p><p>Perform test and validation of internal CPU clock.</p></li><li><p><code>--crctest=[test]</code></p><p>Test the speed of the built-in checksumming functions. If no argument is given, all of them are tested. Alternatively, a comma separated list can be passed, in which case the given ones are tested.</p></li><li><p>â¤<code>--cmdhelp=command</code></p><p>Print help information for command. May be <code>all</code> for all commands.</p></li><li><p>â¤<code>--enghelp=[ioengine[,command]]</code></p><p>List all commands defined by ioengine, or print help for command defined by ioengine. If no ioengine is given, list all available ioengines.</p></li><li><p>â¤<code>--showcmd=jobfile</code></p><p>Convert jobfile to a set of command-line options.</p></li><li><p><code>â€“-readonly</code></p><p>Turn on safety read-only checks, preventing writes and trims. The <code>--readonly</code> option is an extra safety guard to prevent users from accidentally starting a write or trim workload when that is not desired. Fio will only modify the device under test if <em>rw=write/randwrite/rw/randrw/trim/randtrim/trimwrite</em> is given. This safety net can be used as an extra precaution.</p></li><li><p><code>--eta=when</code></p><p>Specifies when real-time ETA estimate should be printed. when may be <code>always</code>, <code>never</code> or <code>auto</code>. auto is the default, it prints ETA when requested if the output is a TTY. always disregards the output type, and prints ETA when requested. never never prints ETA.</p></li><li><p><code>--eta-interval=time</code></p><p>By default, fio requests client ETA status roughly every second. With this option, the interval is configurable. Fio imposes a minimum allowed time to avoid flooding the console, less than 250 msec is not supported.</p></li><li><p><code>--eta-newline=time</code></p><p>Force a new line for every time period passed. When the unit is omitted, the value is interpreted in seconds.</p></li><li><p><code>--status-interval=time</code></p><p>Force a full status dump of cumulative (from job start) values at time intervals. This option does <em>not</em> provide per-period measurements. So values such as bandwidth are running averages. When the time unit is omitted, time is interpreted in seconds. Note that using this option with <code>--output-format=json</code> will yield output that technically isnâ€™t valid json, since the output will be collated sets of valid json. It will need to be split into valid sets of json after the run.</p></li><li><p><code>--section=name</code></p><p>Only run specified section name in job file. Multiple sections can be specified. The <code>--section</code> option allows one to combine related jobs into one file. E.g. one job file could define light, moderate, and heavy sections. Tell fio to run only the â€œheavyâ€ section by giving <code>--section=heavy</code> command line option. One can also specify the â€œwriteâ€ operations in one section and â€œverifyâ€ operation in another section. The <code>--section</code> option only applies to job sections. The reserved <em>global</em> section is always parsed and used.</p></li><li><p><code>--alloc-size=kb</code></p><p>Allocate additional internal smalloc pools of size <code>kb</code> in KiB. The <code>--alloc-size</code> option increases shared memory set aside for use by fio. If running large jobs with randommap enabled, fio can run out of memory. Smalloc is an internal allocator for shared structures from a fixed size memory pool and can grow to 16 pools. The pool size defaults to 16MiB.</p><p>NOTE: While running <code>.fio_smalloc.*</code> backing store files are visible in <code>/tmp</code>.</p></li><li><p><code>â€“-warnings-fatal</code></p><p>All fio parser warnings are fatal, causing fio to exit with an error.</p></li><li><p><code>--max-jobs=nr</code></p><p>Set the maximum number of threads/processes to support to nr. NOTE: On Linux, it may be necessary to increase the shared-memory limit (<code>/proc/sys/kernel/shmmax</code>) if fio runs into errors while creating jobs.</p></li><li><p><code>--server=args</code></p><p>Start a backend server, with args specifying what to listen to. See
<a href=https://fio.readthedocs.io/en/latest/fio_doc.html#client-server rel=noopener>Client/Server</a> section.</p></li><li><p><code>--daemonize=pidfile</code></p><p>Background a fio server, writing the pid to the given pidfile file.</p></li><li><p><code>--client=hostname</code></p><p>Instead of running the jobs locally, send and run them on the given hostname or set of hostnames. See
<a href=https://fio.readthedocs.io/en/latest/fio_doc.html#client-server rel=noopener>Client/Server</a> section.</p></li><li><p><code>--remote-config=file</code></p><p>Tell fio server to load this local file.</p></li><li><p><code>--idle-prof=option</code></p><p>Report CPU idleness. option is one of the following:</p><ul><li><p><strong>calibrate</strong></p><p>Run unit work calibration only and exit.</p></li><li><p><strong>system</strong></p><p>Show aggregate system idleness and unit work.</p></li><li><p><strong>percpu</strong></p><p>As <strong>system</strong> but also show per CPU idleness.</p></li></ul></li><li><p><code>--inflate-log=log</code></p><p>Inflate and output compressed log.</p></li><li><p><code>--trigger-file=file</code></p><p>Execute trigger command when file exists.</p></li><li><p><code>--trigger-timeout=time</code></p><p>Execute trigger at this time.</p></li><li><p><code>--trigger=command</code></p><p>Set this command as local trigger.</p></li><li><p><code>--trigger-remote=command</code></p><p>Set this command as remote trigger.</p></li><li><p><code>--aux-path=path</code></p><p>Use the directory specified by path for generated state files instead of the current working directory.</p></li></ul><p>Any parameters following the options will be assumed to be job files, unless they match a job file parameter. Multiple job files can be listed and each job file will be regarded as a separate group. Fio will <code>[stonewall](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-stonewall)</code> execution between each group.</p><h2 id=111-job-file-format>1.11. Job file format</h2><p>As previously described, fio accepts one or more job files describing what it is supposed to do. The job file format is the classic ini file, where the names enclosed in <code>[]</code> brackets define the <code>job name</code>. You are free to use any ASCII name you want, except <em><code>global</code></em> which has special meaning. Following the job name is a sequence of zero or more parameters, one per line, that define the behavior of the job. If the first character in a line is a â€˜;â€™ or a â€˜#â€™, the entire line is discarded as a comment.</p><p>A <em>global</em> section sets defaults for the jobs described in that file. A job may <code>override</code> a <em>global</em> section parameter, and a job file may even have several <em>global</em> sections if so desired. A job is only affected by a <em>global</em> section residing above it.</p><p>The <code>[--cmdhelp](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-cmdhelp)</code> option also lists all options. If used with a command argument, <code>[--cmdhelp](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-cmdhelp)</code> will detail the given command.</p><p>See the <code>examples/</code> directory for inspiration on how to write job files. Note the copyright and license requirements currently apply to examples/ files.</p><p>So letâ€™s look at a really simple job file that defines two processes, each randomly reading from a 128MiB file:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>; -- start job file --
</span></span><span class=line><span class=cl>[global]
</span></span><span class=line><span class=cl>rw=randread
</span></span><span class=line><span class=cl>size=128m
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[job1]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[job2]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>; -- end job file --
</span></span></code></pre></td></tr></table></div></div><blockquote><p>fioåœ¨å½“å‰ç›®å½•å»ºç«‹æ–‡ä»¶job1.0.0å’Œjob2.0.0</p></blockquote><p>As you can see, the job file sections themselves are empty as all the described parameters are shared. As no <code>[filename](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-filename)</code> option is given, fio makes up a filename for each of the jobs as it sees fit. On the command line, this job would look as follows:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ fio --name=global --rw=randread --size=128m --name=job1 --name=job2
</span></span></code></pre></td></tr></table></div></div><p>Letâ€™s look at an example that has a number of processes writing randomly to files:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>; -- start job file --
</span></span><span class=line><span class=cl>[random-writers]
</span></span><span class=line><span class=cl>ioengine=libaio
</span></span><span class=line><span class=cl>iodepth=4
</span></span><span class=line><span class=cl>rw=randwrite
</span></span><span class=line><span class=cl>bs=32k
</span></span><span class=line><span class=cl>direct=0
</span></span><span class=line><span class=cl>size=64m
</span></span><span class=line><span class=cl>numjobs=4
</span></span><span class=line><span class=cl>; -- end job file --
</span></span></code></pre></td></tr></table></div></div><p>Here we have no <em>global</em> section, as we only have one job defined anyway. We want to use async I/O here, with a depth of 4 for each file. We also increased the buffer size used to 32KiB and define numjobs to 4 to fork 4 identical jobs. The result is 4 processes each randomly writing to their own 64MiB file. Instead of using the above job file, you could have given the parameters on the command line. For this case, you would specify:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ fio --name=random-writers --ioengine=libaio --iodepth=4 --rw=randwrite --bs=32k --direct=0 --size=64m --numjobs=4
</span></span></code></pre></td></tr></table></div></div><blockquote><p>ä¼šç”Ÿæˆå„è‡ªçš„æ–‡ä»¶ï¼Œrandom-writers.0.0, random-writers.1.0, random-writers.2.0, random-writers.3.0</p></blockquote><p>When fio is utilized as a basis of any reasonably large test suite, it might be desirable to share a set of standardized settings across multiple job files. Instead of copy/pasting such settings, any section may pull in an external <code>filename.fio</code> file with <em>include filename</em> directive, as in the following example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>; -- start job file including.fio --
</span></span><span class=line><span class=cl>[global]
</span></span><span class=line><span class=cl>filename=/tmp/test
</span></span><span class=line><span class=cl>filesize=1m
</span></span><span class=line><span class=cl>include glob-include.fio
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[test]
</span></span><span class=line><span class=cl>rw=randread
</span></span><span class=line><span class=cl>bs=4k
</span></span><span class=line><span class=cl>time_based=1
</span></span><span class=line><span class=cl>runtime=10
</span></span><span class=line><span class=cl>include test-include.fio
</span></span><span class=line><span class=cl>; -- end job file including.fio --
</span></span><span class=line><span class=cl>; -- start job file glob-include.fio --
</span></span><span class=line><span class=cl>thread=1
</span></span><span class=line><span class=cl>group_reporting=1
</span></span><span class=line><span class=cl>; -- end job file glob-include.fio --
</span></span><span class=line><span class=cl>; -- start job file test-include.fio --
</span></span><span class=line><span class=cl>ioengine=libaio
</span></span><span class=line><span class=cl>iodepth=4
</span></span><span class=line><span class=cl>; -- end job file test-include.fio --
</span></span></code></pre></td></tr></table></div></div><p>Settings pulled into a section apply to that section only (except <em>global</em> section). Include directives may be nested in that any included file may contain further include directive(s). Include files may not contain [] sections.</p><h3 id=1111-environment-variables>1.11.1. Environment variables</h3><p>Fio also supports environment variable expansion in job files. Any sub-string of the form <code>${VARNAME}</code> as part of an option value (in other words, on the right of the â€˜=â€™), will be expanded to the value of the environment variable called VARNAME. If no such environment variable is defined, or VARNAME is the empty string, the empty string will be substituted.</p><p>As an example, letâ€™s look at a sample fio invocation and job file:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ SIZE=64m NUMJOBS=4 fio jobfile.fio
</span></span><span class=line><span class=cl>; -- start job file --
</span></span><span class=line><span class=cl>[random-writers]
</span></span><span class=line><span class=cl>rw=randwrite
</span></span><span class=line><span class=cl>size=${SIZE}
</span></span><span class=line><span class=cl>numjobs=${NUMJOBS}
</span></span><span class=line><span class=cl>; -- end job file --
</span></span></code></pre></td></tr></table></div></div><p>This will expand to the following equivalent job file at runtime:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>; -- start job file --
</span></span><span class=line><span class=cl>[random-writers]
</span></span><span class=line><span class=cl>rw=randwrite
</span></span><span class=line><span class=cl>size=64m
</span></span><span class=line><span class=cl>numjobs=4
</span></span><span class=line><span class=cl>; -- end job file --
</span></span></code></pre></td></tr></table></div></div><p>Fio ships with a few example job files, you can also look there for inspiration.</p><h3 id=1112-reserved-keywords>1.11.2. Reserved keywords</h3><p>Additionally, fio has a set of reserved keywords that will be replaced internally with the appropriate value. Those keywords are:</p><p><strong>$pagesize</strong></p><blockquote><p>The architecture page size of the running system.</p></blockquote><p><strong>$mb_memory</strong></p><blockquote><p>Megabytes of total memory in the system.</p></blockquote><p><strong>$ncpus</strong></p><blockquote><p>Number of online available CPUs.</p></blockquote><p>These can be used on the command line or in the job file, and will be automatically substituted with the current system values when the job is run. Simple math is also supported on these keywords, so you can perform actions like:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>size=8*$mb_memory
</span></span></code></pre></td></tr></table></div></div><p>and get that properly expanded to 8 times the size of memory in the machine.</p><h2 id=112-job-file-parameters>â¤1.12. Job file parameters</h2><p>This section describes in details each parameter associated with a job. Some parameters take an option of a given type, such as an integer or a string. Anywhere a numeric value is required, an arithmetic expression may be used, provided it is surrounded by parentheses. Supported operators are:</p><ul><li>addition (+)</li><li>subtraction (-)</li><li>multiplication (*)</li><li>division (/)</li><li>modulus (%)</li><li>exponentiation (^)</li></ul><p>For time values in expressions, units are microseconds by default. This is different than for time values not in expressions (not enclosed in parentheses). The following types are used:</p><h3 id=1121-parameter-types>1.12.1. Parameter types</h3><ul><li><p><strong>str</strong></p><p>String: A sequence of alphanumeric characters.</p></li><li><p><strong>time</strong></p><p>Integer with possible time suffix. Without a unit value is interpreted as seconds unless otherwise specified. Accepts a suffix of â€˜<code>d</code>â€™ for days, â€˜<code>h</code>â€™ for hours, â€˜<code>m</code>â€™ for minutes, â€˜<code>s</code>â€™ for seconds, â€˜<code>ms</code>â€™ (or â€˜<code>msec</code>â€™) for milliseconds and â€˜<code>us</code>â€™ (or â€˜<code>usec</code>â€™) for microseconds. For example, use 10m for 10 minutes.</p></li><li><p><strong>int</strong></p><p>Integer. A whole number value, which may contain an integer prefix and an integer suffix:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span>*integer prefix*<span class=o>]</span> **number** <span class=o>[</span>*integer suffix*<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>The optional <em><code>integer prefix</code></em> specifies the numberâ€™s base. The default is decimal. <em><code>0x</code></em> specifies hexadecimal.</p><p>The optional <em><code>integer suffix</code></em> specifies the numberâ€™s <code>units</code>, and includes an optional unit prefix and an optional unit. For quantities of data, the default unit is bytes. For quantities of time, the default unit is seconds unless otherwise specified.</p><p>With <code>[kb_base](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-kb-base)</code>=1000, fio follows international standards for unit prefixes. To specify <code>power-of-10</code> decimal values defined in the International System of Units (SI):</p><ul><li>K â€“ means kilo (K) or 1000</li><li>M â€“ means mega (M) or 1000**2</li><li>G â€“ means giga (G) or 1000**3</li><li>T â€“ means tera (T) or 1000**4</li><li>P â€“ means peta (P) or 1000**5</li></ul><p>To specify <code>power-of-2</code> binary values defined in IEC 80000-13:</p><ul><li>Ki â€“ means kibi (Ki) or 1024</li><li>Mi â€“ means mebi (Mi) or 1024**2</li><li>Gi â€“ means gibi (Gi) or 1024**3</li><li>Ti â€“ means tebi (Ti) or 1024**4</li><li>Pi â€“ means pebi (Pi) or 1024**5</li></ul><p>With <code>[kb_base](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-kb-base)</code>=1024 (the default), the unit prefixes are opposite from those specified in the SI and IEC 80000-13 standards to provide compatibility with old scripts. For example, 4k means 4096.</p><p>For quantities of data, an optional unit of â€˜Bâ€™ may be included (e.g., â€˜kBâ€™ is the same as â€˜kâ€™).</p><p>The <em>integer suffix</em> is not case sensitive (e.g., m/mi mean mebi/mega, not milli). â€˜bâ€™ and â€˜Bâ€™ both mean byte, not bit.</p><p>Examples with <code>[kb_base](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-kb-base)</code>=1000:</p><ul><li>4 KiB: 4096, 4096b, 4096B, 4ki, 4kib, 4kiB, 4Ki, 4KiB</li><li>1 MiB: 1048576, 1mi, 1024ki</li><li>1 MB: 1000000, 1m, 1000k</li><li>1 TiB: 1099511627776, 1ti, 1024gi, 1048576mi</li><li>1 TB: 1000000000, 1t, 1000m, 1000000k</li></ul><p>Examples with <code>[kb_base](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-kb-base)</code>=1024 (default):</p><ul><li>4 KiB: 4096, 4096b, 4096B, 4k, 4kb, 4kB, 4K, 4KB</li><li>1 MiB: 1048576, 1m, 1024k</li><li>1 MB: 1000000, 1mi, 1000ki</li><li>1 TiB: 1099511627776, 1t, 1024g, 1048576m</li><li>1 TB: 1000000000, 1ti, 1000mi, 1000000ki</li></ul><blockquote><p>å…³äºkä¸kiï¼šè·Ÿkb_baseé€‰é¡¹æœ‰å…³ï¼ˆé»˜è®¤ä¸º1024ï¼‰ï¼Œå¦‚æœkb_baseä¸º1024ï¼Œé‚£ä¹ˆä¸å¸¦içš„è¡¨ç¤º1024è¿›åˆ¶ï¼Œå¸¦içš„è¡¨ç¤º1000è¿›åˆ¶ï¼›åä¹‹ï¼Œå¦‚æœkb_baseä¸º1000ï¼Œé‚£ä¹ˆä¸å¸¦içš„è¡¨ç¤º1000è¿›åˆ¶ï¼Œå¸¦içš„è¡¨ç¤º1024è¿›åˆ¶ã€‚</p></blockquote><p>To specify <code>times</code> (units are not case sensitive):</p><ul><li>D â€“ means days</li><li>H â€“ means hours</li><li>M â€“ means minutes</li><li>s â€“ or sec means seconds (default)</li><li>ms â€“ or msec means milliseconds</li><li>us â€“ or usec means microseconds</li></ul><p>If the option accepts an upper and lower range, use a colon â€˜<code>:</code>â€™ or minus â€˜<code>-</code>â€˜ to separate such values. See
<a href=https://fio.readthedocs.io/en/latest/fio_man.html#irange rel=noopener>irange</a>. If the lower value specified happens to be larger than the upper value
the two values are swapped.</p></li><li><p><strong>bool</strong></p><p>Boolean. Usually parsed as an integer, however only defined for true and false (1 and 0).</p></li><li><p><strong>irange</strong></p><p>Integer range with suffix. Allows value range to be given, such as 1024-4096. A colon may also be used as the separator, e.g.Â 1k:4k. If the option allows two sets of ranges, they can be specified with a â€˜<code>,</code>â€™ or â€˜<code>/</code>â€™ delimiter: 1k-4k/8k-32k. Also see
<a href=https://fio.readthedocs.io/en/latest/fio_man.html#int rel=noopener>int</a>.</p></li><li><p><strong>float_list</strong></p><p>A list of floating point numbers, separated by a â€˜<code>:</code>â€™ character.</p></li></ul><p>With the above in mind, here follows the complete list of fio job parameters.</p><h3 id=1122-units>1.12.2. Units</h3><ul><li><p><code>kb_base=int</code></p><p>Select the interpretation of unit prefixes in input parameters.</p><ul><li><strong>1000</strong><ul><li>Inputs comply with IEC 80000-13 and the International System of Units (SI). Use:<ul><li>power-of-2 values with IEC prefixes (e.g., KiB)</li><li>power-of-10 values with SI prefixes (e.g., kB)</li></ul></li></ul></li><li><strong>1024</strong><ul><li>Compatibility mode (default). To avoid breaking old scripts:<ul><li>power-of-2 values with SI prefixes</li><li>power-of-10 values with IEC prefixes</li></ul></li></ul></li></ul><p>See <code>[bs](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize)</code> for more details on input parameters.</p><p>Outputs always use correct prefixes. Most outputs include both side-by-side, like:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>bw</span><span class=o>=</span>2383.3kB/s <span class=o>(</span>2327.4KiB/s<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>If only one value is reported, then kb_base selects the one to use:</p><p><strong>1000</strong> â€“ SI prefixes</p><p><strong>1024</strong> â€“ IEC prefixes</p></li><li><p><code>unit_base=int</code></p><p>Base unit for reporting. Allowed values are:</p><p><strong>0</strong></p><p>Use auto-detection (default).</p><p><strong>8</strong></p><p>Byte based.</p><p><strong>1</strong></p><p>Bit based.</p></li></ul><h3 id=1123-job-description>â¤1.12.3. Job description</h3><ul><li><p><code>name=str</code></p><p>ASCII name of the job. This may be used to override the name printed by fio for this job. Otherwise the job name is used. On the command line this parameter has the special purpose of also signaling the start of a new job.</p></li><li><p><code>description=str</code></p><p>Text description of the job. Doesnâ€™t do anything except dump this text description when this job is run. Itâ€™s not parsed.</p></li><li><p><code>loops=int</code></p><p>Run the specified number of iterations of this job. Used to repeat the same workload a given number of times. Defaults to 1.</p></li><li><p><code>numjobs=int</code></p><p>Create the specified number of clones of this job. Each clone of job is spawned as an independent thread or process. May be used to setup a larger number of threads/processes doing the same thing. Each thread is reported separately; to see statistics for all clones as a whole, use <code>[group_reporting](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-group-reporting)</code> in conjunction with <code>[new_group](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-new-group)</code>. See <code>[--max-jobs](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-max-jobs)</code>. Default: 1.</p></li></ul><h3 id=1124-time-related-parameters>1.12.4. Time related parameters</h3><ul><li><p>â¤<code>runtime=time</code></p><p>Tell fio to terminate processing after the specified period of time. It can be quite hard to determine for how long a specified job will run, so this parameter is handy to cap the total runtime to a given time. When the unit is omitted, the value is interpreted in seconds.</p><blockquote><p>è¦ç»“åˆtime_basedå¼€å…³</p></blockquote></li><li><p>â¤<code>time_based</code></p><p>If set, fio will run for the duration of the <code>[runtime](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-runtime)</code> specified even if the file(s) are completely read or written. It will simply loop over the same workload as many times as the <code>[runtime](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-runtime)</code> allows.</p></li><li><p><code>startdelay=irange(time)</code></p><p>Delay the start of job for the specified amount of time. Can be a single value or a range. When given as a range, each thread will choose a value randomly from within the range. Value is in seconds if a unit is omitted.</p></li><li><p><code>ramp_time=time</code></p><p>If set, fio will run the specified workload for this amount of time before logging any performance numbers. Useful for letting performance settle before logging results, thus minimizing the runtime required for stable results. Note that the <code>ramp_time</code> is considered lead in time for a job, thus it will increase the total runtime if a special timeout or <code>[runtime](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-runtime)</code> is specified. When the unit is omitted, the value is given in seconds.</p><blockquote><p>é¢„çƒ­ã€‚è¯¥æ—¶é—´ä¸è®¡å…¥runtimeã€‚</p></blockquote></li><li><p><code>clocksource=str</code></p><p>Use the given clocksource as the base of timing. The supported options are:</p><p><strong>gettimeofday</strong></p><p><em>gettimeofday(2)</em></p><p><strong>clock_gettime</strong></p><p><em>clock_gettime(2)</em></p><p><strong>cpu</strong></p><p>Internal CPU clock source</p><p>cpu is the preferred clocksource if it is reliable, as it is very fast (and fio is heavy on time calls). Fio will automatically use this clocksource if itâ€™s supported and considered reliable on the system it is running on, unless another clocksource is specifically set. For x86/x86-64 CPUs, this means supporting TSC Invariant.</p></li><li><p><code>gtod_reduce=bool</code></p><p>Enable all of the <em>gettimeofday(2)</em> reducing options (<code>[disable_clat](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-disable-clat)</code>, <code>[disable_slat](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-disable-slat)</code>, <code>[disable_bw_measurement](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-disable-bw-measurement)</code>) plus reduce precision of the timeout somewhat to really shrink the <em>gettimeofday(2)</em> call count. With this option enabled, we only do about 0.4% of the <em>gettimeofday(2)</em> calls we would have done if all time keeping was enabled.</p></li><li><p><code>gtod_cpu=int</code></p><p>Sometimes itâ€™s cheaper to dedicate a single thread of execution to just getting the current time. Fio (and databases, for instance) are very intensive on <em>gettimeofday(2)</em> calls. With this option, you can set one CPU aside for doing nothing but logging current time to a shared memory location. Then the other threads/processes that run I/O workloads need only copy that segment, instead of entering the kernel with a <em>gettimeofday(2)</em> call. The CPU set aside for doing these time calls will be excluded from other uses. Fio will manually clear it from the CPU mask of other jobs.</p></li></ul><h3 id=1125-target-filedevice>1.12.5. Target file/device</h3><ul><li><p><code>directory=str</code></p><p>Prefix filenames with this directory. Used to place files in a different location than <code>./</code>. You can specify a number of directories by separating the names with a â€˜<code>:</code>â€™ character. These directories will be assigned equally distributed to job clones created by <code>[numjobs](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-numjobs)</code> as long as they are using generated filenames. If specific filename(s) are set fio will use the first listed directory, and thereby matching the filename semantic (which generates a file for each clone if not specified, but lets all clones use the same file if set).</p><p>See the <code>[filename](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-filename)</code> option for information on how to escape â€œ<code>:</code>â€ characters within the directory path itself.</p><p>Note: To control the directory fio will use for internal state files use <code>[--aux-path](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-aux-path)</code>.</p></li><li><p>â¤<code>filename=str</code></p><p>Fio normally makes up a filename based on the job name, thread number, and file number (see <code>[filename_format](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-filename-format)</code>). If you want to share files between threads in a job or several jobs with fixed file paths, specify a filename for each of them to override the default. If the ioengine is file based, you can specify a number of files by separating the names with a â€˜<code>:</code>â€™ colon. So if you wanted a job to open <code>/dev/sda</code> and <code>/dev/sdb</code> as the two working files, you would use <code>filename=/dev/sda:/dev/sdb</code>. This also means that whenever this option is specified, <code>[nrfiles](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-nrfiles)</code> is ignored. The size of regular files specified by this option will be <code>[size](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-size)</code> divided by number of files unless an explicit size is specified by <code>[filesize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-filesize)</code>.</p><blockquote><p>å¦‚æœå¤šä¸ªjobå…±äº«ä¸€ä¸ªæ–‡ä»¶çš„è¯ï¼Œå®ƒä»¬çš„ä½¿ç”¨åŒºåŸŸæ˜¯ä¸ä¸€æ ·çš„ï¼Ÿ</p></blockquote><p>Each colon in the wanted path must be escaped with a <code>\</code> character. For instance, if the path is <code>/dev/dsk/foo@3,0:c</code> then you would use <code>filename=/dev/dsk/foo@3,0\:c</code> and if the path is <code>F:\filename</code> then you would use <code>filename=F\:\filename</code>.</p><p>On Windows, disk devices are accessed as <code>\\.\PhysicalDrive0</code> for the first device, <code>\\.\PhysicalDrive1</code> for the second etc. Note: Windows and FreeBSD prevent write access to areas of the disk containing in-use data (e.g.Â filesystems).</p><p>The filename â€œ<code>-</code>â€ is a reserved name, meaning <em>stdin</em> or <em>stdout</em>. Which of the two depends on the read/write direction set.</p></li><li><p><code>filename_format=str</code></p><p>If sharing multiple files between jobs, it is usually necessary to have fio generate the exact names that you want. By default, fio will name a file based on the default file format specification of <code>jobname.jobnumber.filenumber</code>. With this option, that can be customized. Fio will recognize and replace the following keywords in this string:</p><p><strong>$jobname</strong></p><p>The name of the worker thread or process.</p><p><strong>$clientuid</strong></p><p>IP of the fio process when using client/server mode.</p><p><strong>$jobnum</strong></p><p>The incremental number of the worker thread or process.</p><p><strong>$filenum</strong></p><p>The incremental number of the file for that worker thread or process.</p><p>To have dependent jobs share a set of files, this option can be set to have fio generate filenames that are shared between the two. For instance, if <code>testfiles.$filenum</code> is specified, file number 4 for any job will be named testfiles.4. The default of <code>$jobname.$jobnum.$filenum</code> will be used if no other format specifier is given.</p><p>If you specify a path then the directories will be created up to the main directory for the file. So for example if you specify <code>filename_format=a/b/c/$jobnum</code> then the directories <code>a/b/c</code> will be created before the file setup part of the job. If you specify <strong>directory</strong> then the path will be relative that directory, otherwise it is treated as the absolute path.</p></li><li><p><code>unique_filename=bool</code></p><p>To avoid collisions between networked clients, fio defaults to prefixing any generated filenames (with a directory specified) with the source of the client connecting. To disable this behavior, set this option to 0.</p></li><li><p><code>opendir=str</code></p><p>Recursively open any files below directory str.</p></li><li><p><code>lockfile=str</code></p><p>Fio defaults to not locking any files before it does I/O to them. If a file or file descriptor is shared, fio can serialize I/O to that file to make the end result consistent. This is usual for emulating real workloads that share files. The lock modes are:</p><p><strong>none</strong></p><p>No locking. The default.</p><p><strong>exclusive</strong></p><p>Only one thread or process may do I/O at a time, excluding all others.</p><p><strong>readwrite</strong></p><p>Read-write locking on the file. Many readers may access the file at the same time, but writes get exclusive access.</p></li><li><p><code>nrfiles=int</code></p><p>Number of files to use for this job. Defaults to 1. The size of files will be <code>[size](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-size)</code> divided by this unless explicit size is specified by <code>[filesize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-filesize)</code>. Files are created for each thread separately, and each file will have a file number within its name by default, as explained in <code>[filename](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-filename)</code> section.</p></li><li><p><code>openfiles=int</code></p><p>Number of files to keep open at the same time. Defaults to the same as <code>[nrfiles](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-nrfiles)</code>, can be set smaller to limit the number simultaneous opens.</p></li><li><p><code>file_service_type=str</code></p><p>Defines how fio decides which file from a job to service next. The following types are defined:</p><p><strong>random</strong></p><p>Choose a file at random.</p><p><strong>roundrobin</strong></p><p>Round robin over opened files. This is the default.</p><p><strong>sequential</strong></p><p>Finish one file before moving on to the next. Multiple files can still be open depending on <code>[openfiles](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-openfiles)</code>.</p><p><strong>zipf</strong></p><p>Use a <em>Zipf</em> distribution to decide what file to access.</p><p><strong>pareto</strong></p><p>Use a <em>Pareto</em> distribution to decide what file to access.</p><p><strong>normal</strong></p><p>Use a <em>Gaussian</em> (normal) distribution to decide what file to access.</p><p><strong>gauss</strong></p><p>Alias for normal.</p><p>For <em>random</em>, <em>roundrobin</em>, and <em>sequential</em>, a postfix can be appended to tell fio how many I/Os to issue before switching to a new file. For example, specifying <code>file_service_type=random:8</code> would cause fio to issue 8 I/Os before selecting a new file at random. For the non-uniform distributions, a floating point postfix can be given to influence how the distribution is skewed. See <code>[random_distribution](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-random-distribution)</code> for a description of how that would work.</p><blockquote><p>ä¸€ä¸ªjobå¯ä»¥å¯¹åº”å¤šä¸ªfileã€‚ä»€ä¹ˆæ—¶å€™åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªfileå‘¢ï¼Œå¦‚æœpostfixæ²¡æä¾›çš„è¯ï¼Ÿ</p></blockquote></li><li><p>â¤<code>ioscheduler=str</code></p><p>Attempt to switch the device hosting the file to the specified I/O scheduler before running.</p></li><li><p><code>create_serialize=bool</code></p><p>If true, serialize the file creation for the jobs. This may be handy to avoid interleaving of data files, which may greatly depend on the filesystem used and even the number of processors in the system. Default: true.</p></li><li><p><code>create_fsync=bool</code></p><p><em>fsync(2)</em> the data file after creation. This is the default.</p></li><li><p><code>create_on_open=bool</code></p><p>If true, donâ€™t pre-create files but allow the jobâ€™s open() to create a file when itâ€™s time to do I/O. Default: false â€“ pre-create all necessary files when the job starts.</p></li><li><p><code>create_only=bool</code></p><p>If true, fio will only run the setup phase of the job. If files need to be laid out or updated on disk, only that will be done â€“ the actual job contents are not executed. Default: false.</p></li><li><p><code>allow_file_create=bool</code></p><p>If true, fio is permitted to create files as part of its workload. If this option is false, then fio will error out if the files it needs to use donâ€™t already exist. Default: true.</p></li><li><p><code>allow_mounted_write=bool</code></p><p>If this isnâ€™t set, fio will abort jobs that are destructive (e.g.Â that write) to what appears to be a mounted device or partition. This should help catch creating inadvertently <code>destructive tests</code>, not realizing that the test will destroy data on the mounted file system. Note that some platforms donâ€™t allow writing against a mounted device regardless of this option. Default: false.</p></li><li><p><code>pre_read=bool</code></p><p>If this is given, files will be pre-read into memory before starting the given I/O operation. This will also clear the <code>[invalidate](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-invalidate)</code> flag, since it is pointless to pre-read and then drop the cache. This will only work for I/O engines that are seek-able, since they allow you to read the same data multiple times. Thus it will not work on non-seekable I/O engines (e.g.Â network, splice). Default: false.</p></li><li><p><code>unlink=bool</code></p><p>Unlink the job files when done. Not the default, as repeated runs of that job would then waste time recreating the file set again and again. Default: false.</p></li><li><p><code>unlink_each_loop=bool</code></p><p>Unlink job files after each iteration or loop. Default: false.</p></li><li><p>â¤<code>zonemode=str</code></p><p>Accepted values are:</p><p><strong>none</strong></p><p>The <code>[zonerange](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonerange)</code>, <code>[zonesize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonesize)</code>, :option <em>zonecapacity</em> and option:<em>zoneskip</em> parameters are ignored.</p><p><strong>strided</strong></p><p>I/O happens in a single zone until <code>[zonesize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonesize)</code> bytes have been transferred. After that number of bytes has been transferred processing of the next zone starts. :option <em>zonecapacity</em> is ignored.</p><p>â¤<strong>zbd</strong></p><p><code>Zoned block device mode.</code> I/O happens sequentially in each zone, even if random I/O has been selected. Random I/O happens across all zones instead of being restricted to a single zone. The <code>[zoneskip](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zoneskip)</code> parameter is ignored. <code>[zonerange](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonerange)</code> and <code>[zonesize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonesize)</code> must be identical.</p></li><li><p><code>zonerange=int</code></p><p>Size of a single zone. See also <code>[zonesize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonesize)</code> and <code>[zoneskip](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zoneskip)</code>.</p></li><li><p>â¤<code>zonesize=int</code></p><p>For <code>[zonemode](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonemode)</code> =strided, this is the number of bytes to transfer before skipping <code>[zoneskip](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zoneskip)</code> bytes. If this parameter is smaller than <code>[zonerange](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonerange)</code> then only a fraction of each zone with <code>[zonerange](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonerange)</code> bytes will be accessed. If this parameter is larger than <code>[zonerange](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonerange)</code> then each zone will be accessed multiple times before skipping to the next zone.</p><p>For <code>[zonemode](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonemode)</code> =zbd, this is the size of a single zone. The <code>[zonerange](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonerange)</code> parameter is ignored in this mode.</p></li><li><p>â¤<code>zonecapacity=int</code></p><p>For <code>[zonemode](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonemode)</code> =zbd, this defines the capacity of a single zone, which is the accessible area starting from the zone start address. This parameter only applies when using <code>[zonemode](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonemode)</code> =zbd in combination with regular block devices. If not specified it defaults to the zone size. If the target device is a zoned block device, the zone capacity is obtained from the device information and this option is ignored.</p></li><li><p><code>zoneskip=int</code></p><p>For <code>[zonemode](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonemode)</code> =strided, the number of bytes to skip after <code>[zonesize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonesize)</code> bytes of data have been transferred. This parameter must be zero for <code>[zonemode](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonemode)</code> =zbd.</p></li><li><p>â¤<code>read_beyond_wp=bool</code></p><p>This parameter applies to <code>[zonemode](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zonemode)</code> =zbd only.</p><p>Zoned block devices are block devices that consist of multiple zones. Each zone has a type, e.g.Â conventional or sequential. A <code>conventional zone</code> can be written at any offset that is a multiple of the block size. <code>Sequential zones</code> must be written sequentially. The position at which a write must occur is called the <code>write pointer</code>. A zoned block device can be either drive managed, host managed or host aware. For host managed devices the host must ensure that writes happen sequentially. Fio recognizes host managed devices and serializes writes to sequential zones for these devices.</p><p>If a read occurs in a sequential zone beyond the write pointer then the zoned block device will complete the read without reading any data from the storage medium. Since such reads lead to unrealistically high bandwidth and IOPS numbers fio only reads beyond the write pointer if explicitly told to do so. Default: false.</p></li><li><p>â¤<code>max_open_zones=int</code></p><p>When running a random write test across an entire drive many more zones will be open than in a typical application workload. Hence this command line option that allows to limit the number of open zones. The number of open zones is defined as the number of zones to which write commands are issued.</p></li><li><p><code>zone_reset_threshold=float</code></p><p>A number between zero and one that indicates the ratio of logical blocks with data to the total number of logical blocks in the test above which zones should be reset periodically.</p></li><li><p><code>zone_reset_frequency=float</code></p><p>A number between zero and one that indicates how often a zone reset should be issued if the zone reset threshold has been exceeded. A zone reset is submitted after each (1 / zone_reset_frequency) write requests. This and the previous parameter can be used to simulate garbage collection activity.</p></li></ul><h3 id=1126-io-type>1.12.6. I/O type</h3><ul><li><p>â¤<code>direct=bool</code></p><p>If value is true, use <code>non-buffered I/O</code>. This is usually <code>O_DIRECT</code>. Note that OpenBSD and ZFS on Solaris donâ€™t support direct I/O. On Windows the synchronous ioengines donâ€™t support direct I/O. Default: false.</p></li><li><p><code>atomic=bool</code></p><p>If value is true, attempt to use atomic direct I/O. Atomic writes are guaranteed to be stable once acknowledged by the operating system. Only Linux supports O_ATOMIC right now.</p></li><li><p><code>buffered=bool</code></p><p>If value is true, use <code>buffered I/O</code>. This is the opposite of the <code>[direct](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-direct)</code> option. Defaults to true.</p></li><li><p>â¤<code>readwrite=str, rw=str</code></p><p>Type of I/O pattern. Accepted values are:</p><p><strong>read</strong></p><p>Sequential reads.</p><p><strong>write</strong></p><p>Sequential writes.</p><p><strong>trim</strong></p><p>Sequential trims (Linux block devices and SCSI character devices only).</p><p><strong>randread</strong></p><p>Random reads.</p><p><strong>randwrite</strong></p><p>Random writes.</p><p><strong>randtrim</strong></p><p>Random trims (Linux block devices and SCSI character devices only).</p><p><strong><code>rw</code>,readwrite</strong></p><p>Sequential mixed reads and writes.</p><p><strong><code>randrw</code></strong></p><p>Random mixed reads and writes.</p><p><strong>trimwrite</strong></p><p>Sequential trim+write sequences. Blocks will be trimmed first, then the same blocks will be written to.</p><p>Fio defaults to read if the option is not specified. For the mixed I/O types, the default is to split them 50/50. For certain types of I/O the result may still be skewed a bit, since the speed may be different.</p><p>It is possible to specify the number of I/Os to do before getting a new offset by appending <code>:&lt;nr></code> to the end of the string given. For a random read, it would look like <code>rw=randread:8</code> for passing in an offset modifier with a value of 8. If the suffix is used with a sequential I/O pattern, then the value specified will be <strong>added</strong> to the generated offset for each I/O turning sequential I/O into sequential I/O with holes. For instance, using <code>rw=write:4k</code> will skip 4k for every write. Also see the <code>[rw_sequencer](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-rw-sequencer)</code> option.</p><blockquote><p>å¦‚æœåŠ ä¸ªåç¼€çš„è¯ï¼Œæ¯”å¦‚:8ï¼Œé’ˆå¯¹éšæœºè¯»ï¼Œé‚£ä¹ˆï¼Œæ¯æ¬¡äº§ç”Ÿä¸€ä¸ªoffsetï¼Œç„¶åé¡ºåºäº§ç”Ÿ8ä¸ªIOï¼Œç„¶åä¸‹ä¸€æ¬¡å†éšæœºç”Ÿæˆoffsetï¼›é’ˆå¯¹é¡ºåºå†™:4kï¼Œç›¸å½“äºæ¯æ¬¡IOä¼šäº§ç”Ÿä¸€ä¸ªholeã€‚</p></blockquote></li><li><p><code>rw_sequencer=str</code></p><p>If an offset modifier is given by appending a number to the <code>rw=&lt;str></code> line, then this option controls how that number modifies the I/O offset being generated. Accepted values are:</p><p><strong>sequential</strong></p><p>Generate sequential offset.</p><p><strong>identical</strong></p><p>Generate the same offset.</p><p><code>sequential</code> is only useful for random I/O, where fio would normally generate a new random offset for every I/O. If you append e.g.Â 8 to randread, you would get a new random offset for every 8 I/Os. The result would be a seek for only every 8 I/Os, instead of for every I/O. Use <code>rw=randread:8</code> to specify that. As sequential I/O is already sequential, setting <code>sequential</code> for that would not result in any differences. <code>identical</code> behaves in a similar fashion, except it sends the same offset 8 number of times before generating a new offset.</p></li><li><p><code>unified_rw_reporting=bool</code></p><p>Fio normally reports statistics on a per data direction basis, meaning that reads, writes, and trims are accounted and reported separately. If this option is set fio sums the results and report them as â€œmixedâ€ instead.</p></li><li><p><code>randrepeat=bool</code></p><p>Seed the random number generator used for random I/O patterns in a predictable way so the pattern is repeatable across runs. Default: true.</p></li><li><p><code>allrandrepeat=bool</code></p><p>Seed all random number generators in a predictable way so results are repeatable across runs. Default: false.</p></li><li><p><code>randseed=int</code></p><p>Seed the random number generators based on this seed value, to be able to control what sequence of output is being generated. If not set, the random sequence depends on the <code>[randrepeat](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-randrepeat)</code> setting.</p></li><li><p><code>fallocate=str</code></p><p>Whether pre-allocation is performed when laying down files. Accepted values are:</p><p><strong>none</strong></p><p>Do not pre-allocate space.</p><p><strong>native</strong></p><p>Use a platformâ€™s native pre-allocation call but fall back to <strong>none</strong> behavior if it fails/is not implemented.</p><p><strong>posix</strong></p><p>Pre-allocate via <em>posix_fallocate(3)</em>.</p><p><strong>keep</strong></p><p>Pre-allocate via <em>fallocate(2)</em> with FALLOC_FL_KEEP_SIZE set.</p><p><strong>truncate</strong></p><p>Extend file to final size via <em>ftruncate(2)</em> instead of allocating.</p><p><strong>0</strong></p><p>Backward-compatible alias for <strong>none</strong>.</p><p><strong>1</strong></p><p>Backward-compatible alias for <strong>posix</strong>.</p><p>May not be available on all supported platforms. <strong>keep</strong> is only available on Linux. If using ZFS on Solaris this cannot be set to <strong>posix</strong> because ZFS doesnâ€™t support pre-allocation. <code>Default</code>: <strong>native</strong> if any pre-allocation methods except <strong>truncate</strong> are available, <strong>none</strong> if not.</p><p>Note that using <strong>truncate</strong> on Windows will interact surprisingly with non-sequential write patterns. When writing to a file that has been extended by setting the end-of-file information, Windows will backfill the unwritten portion of the file up to that offset with zeroes before issuing the new write. This means that a single small write to the end of an extended file will stall until the entire file has been filled with zeroes.</p></li><li><p><code>fadvise_hint=str</code></p><p>Use <em>posix_fadvise(2)</em> or <em>posix_fadvise(2)</em> to advise the kernel on what I/O patterns are likely to be issued. Accepted values are:</p><p><strong>0</strong></p><p>Backwards-compatible hint for â€œno hintâ€.</p><p><strong>1</strong></p><p>Backwards compatible hint for â€œadvise with fio workload typeâ€. This uses <strong>FADV_RANDOM</strong> for a random workload, and <strong>FADV_SEQUENTIAL</strong> for a sequential workload.</p><p><strong>sequential</strong></p><p>Advise using <strong>FADV_SEQUENTIAL</strong>.</p><p><strong>random</strong></p><p>Advise using <strong>FADV_RANDOM</strong>.</p></li><li><p><code>write_hint=str</code></p><p>Use <em>fcntl(2)</em> to advise the kernel what life time to expect from a write. Only supported on Linux, as of version 4.13. Accepted values are:</p><p><strong>none</strong></p><p>No particular life time associated with this file.</p><p><strong>short</strong></p><p>Data written to this file has a short life time.</p><p><strong>medium</strong></p><p>Data written to this file has a medium life time.</p><p><strong>long</strong></p><p>Data written to this file has a long life time.</p><p><strong>extreme</strong></p><p>Data written to this file has a very long life time.</p><p>The values are all relative to each other, and no absolute meaning should be associated with them.</p></li><li><p>â¤<code>offset=int</code></p><p>Start I/O at the provided offset in the file, given as either a fixed size in bytes or a percentage. If a percentage is given, the generated offset will be aligned to the minimum <code>blocksize</code> or to the value of <code>offset_align</code> if provided. Data before the given offset will not be touched. This effectively caps the file size at <em>real_size - offset</em>. Can be combined with <code>[size](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-size)</code> to constrain the start and end range of the I/O workload. A percentage can be specified by a number between 1 and 100 followed by â€˜%â€™, for example, <code>offset=20%</code> to specify 20%.</p></li><li><p><code>offset_align=int</code></p><p>If set to non-zero value, the byte offset generated by a percentage <code>offset</code> is aligned upwards to this value. Defaults to 0 meaning that a percentage offset is aligned to the minimum block size.</p></li><li><p><code>offset_increment=int</code></p><p>If this is provided, then the real offset becomes <em>offset + offset_increment * thread_number</em>, where the thread number is a counter that starts at 0 and is incremented for each sub-job (i.e.Â when <code>[numjobs](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-numjobs)</code> option is specified). This option is useful if there are several jobs which are intended to operate on a file in parallel disjoint segments, with even spacing between the starting points. Percentages can be used for this option. If a percentage is given, the generated offset will be aligned to the minimum <code>blocksize</code> or to the value of <code>offset_align</code> if provided.</p><blockquote><p>åŒä¸€ä¸ªfileçš„å¤šä¸ªjobå¯ä»¥æœ‰ä¸åŒçš„èµ·ç‚¹ã€‚ä½†è·‘ç€è·‘ç€å¯èƒ½å°±æ··åœ¨ä¸€èµ·äº†ï¼Œå› ä¸ºé€Ÿåº¦ä¸æ˜¯ä¸€æ ·çš„ã€‚</p></blockquote></li><li><p>â¤<code>number_ios=int</code></p><p>Fio will normally perform I/Os until it has exhausted the size of the region set by <code>[size](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-size)</code>, or if it exhaust the allocated time (or hits an error condition). With this setting, the range/size can be set independently of the number of I/Os to perform. When fio reaches this number, it will exit normally and report status. Note that this does not extend the amount of I/O that will be done, it will only stop fio if this condition is met before other end-of-job criteria.</p></li><li><p><code>fsync=int</code></p><p>If writing to a file, issue an <em>fsync(2)</em> (or its equivalent) of the dirty data for every number of blocks given. For example, if you give 32 as a parameter, fio will sync the file after every 32 writes issued. If fio is using non-buffered I/O, we may not sync the file. The exception is the sg I/O engine, which synchronizes the disk cache anyway. Defaults to 0, which means fio does not periodically issue and wait for a sync to complete. Also see <code>[end_fsync](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-end-fsync)</code> and <code>[fsync_on_close](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-fsync-on-close)</code>.</p></li><li><p><code>fdatasync=int</code></p><p>Like <code>[fsync](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-fsync)</code> but uses <em>fdatasync(2)</em> to only sync data and not metadata blocks. In Windows, FreeBSD, DragonFlyBSD or OSX there is no <em>fdatasync(2)</em> so this falls back to using <em>fsync(2)</em>. Defaults to 0, which means fio does not periodically issue and wait for a data-only sync to complete.</p></li><li><p><code>write_barrier=int</code></p><p>Make every N-th write a barrier write.</p></li><li><p><code>sync_file_range=str:int</code></p><p>Use <em>sync_file_range(2)</em> for every int number of write operations. Fio will track range of writes that have happened since the last <em>sync_file_range(2)</em> call. str can currently be one or more of:</p><p><strong>wait_before</strong></p><p>SYNC_FILE_RANGE_WAIT_BEFORE</p><p><strong>write</strong></p><p>SYNC_FILE_RANGE_WRITE</p><p><strong>wait_after</strong></p><p>SYNC_FILE_RANGE_WAIT_AFTER</p><p>So if you do <code>sync_file_range=wait_before,write:8</code>, fio would use <code>SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE</code> for every 8 writes. Also see the <em>sync_file_range(2)</em> man page. This option is Linux specific.</p></li><li><p><code>overwrite=bool</code></p><p>If true, writes to a file will always overwrite existing data. If the file doesnâ€™t already exist, it will be created before the write phase begins. If the file exists and is large enough for the specified write phase, nothing will be done. Default: false.</p></li><li><p><code>end_fsync=bool</code></p><p>If true, <em>fsync(2)</em> file contents when a write stage has completed. Default: false.</p></li><li><p><code>fsync_on_close=bool</code></p><p>If true, fio will <em>fsync(2)</em> a dirty file on close. This differs from <code>[end_fsync](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-end-fsync)</code> in that it will happen on every file close, not just at the end of the job. Default: false.</p></li><li><p>â¤<code>rwmixread=int</code></p><p>Percentage of a mixed workload that should be reads. Default: 50.</p></li><li><p>â¤<code>rwmixwrite=int</code></p><p>Percentage of a mixed workload that should be writes. If both <code>[rwmixread](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-rwmixread)</code> and <code>[rwmixwrite](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-rwmixwrite)</code> is given and the values do not add up to 100%, the latter of the two will be used to override the first. This may interfere with a given rate setting, if fio is asked to limit reads or writes to a certain rate. If that is the case, then the distribution may be skewed. Default: 50.</p></li><li><p><code>random_distribution=str:float[:float][,str:float][,str:float]</code></p><p>By default, fio will use a completely uniform random distribution when asked to perform random I/O. Sometimes it is useful to <code>skew</code> the distribution in specific ways, ensuring that some parts of the data is more hot than others. fio includes the following distribution models:</p><p><strong>random</strong></p><p>Uniform random distribution</p><p><strong>zipf</strong></p><p>Zipf distribution</p><p><strong>pareto</strong></p><p>Pareto distribution</p><p><strong>normal</strong></p><p>Normal (Gaussian) distribution</p><p><strong>zoned</strong></p><p>Zoned random distribution</p><p><strong>zoned_abs</strong></p><p>Zone absolute random distribution</p><p>When using a <strong>zipf</strong> or <strong>pareto</strong> distribution, an input value is also needed to define the access pattern. For <strong>zipf</strong>, this is the <em>Zipf theta</em>. For <strong>pareto</strong>, itâ€™s the <em>Pareto power</em>. Fio includes a test program, <strong>fio-genzipf</strong>, that can be used visualize what the given input values will yield in terms of hit rates. If you wanted to use <strong>zipf</strong> with a theta of 1.2, you would use <code>random_distribution=zipf:1.2</code> as the option. If a non-uniform model is used, fio will disable use of the random map. For the <strong>normal</strong> distribution, a normal (Gaussian) deviation is supplied as a value between 0 and 100.</p><p>The second, optional float is allowed for <strong>pareto</strong>, <strong>zipf</strong> and <strong>normal</strong> distributions. It allows to set base of distribution in non-default place, giving more control over most probable outcome. This value is in range [0-1] which maps linearly to range of possible random values. Defaults are: random for <strong>pareto</strong> and <strong>zipf</strong>, and 0.5 for <strong>normal</strong>. If you wanted to use <strong>zipf</strong> with a theta of 1.2 centered on 1/4 of allowed value range, you would use <code>random_distibution=zipf:1.2:0.25</code>.</p><p>For a <strong><code>zoned</code></strong> distribution, fio supports specifying percentages of I/O access that should fall within what range of the file or device. For example, given a criteria of:</p><ul><li>60% of accesses should be to the first 10%</li><li>30% of accesses should be to the next 20%</li><li>8% of accesses should be to the next 30%</li><li>2% of accesses should be to the next 40%</li></ul><p>we can define that through zoning of the random accesses. For the above example, the user would do:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>random_distribution</span><span class=o>=</span>zoned:60/10:30/20:8/30:2/40
</span></span></code></pre></td></tr></table></div></div><p>A <strong><code>zoned_abs</code></strong> distribution works exactly like the <strong>zoned</strong>, except that it takes absolute sizes. For example, letâ€™s say you wanted to define access according to the following criteria:</p><ul><li>60% of accesses should be to the first 20G</li><li>30% of accesses should be to the next 100G</li><li>10% of accesses should be to the next 500G</li></ul><p>we can define an absolute zoning distribution with:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>random_distribution</span><span class=o>=</span><span class=nv>zoned_abs</span><span class=o>=</span>60/20G:30/100G:10/500g
</span></span></code></pre></td></tr></table></div></div><p>For both <strong>zoned</strong> and <strong>zoned_abs</strong>, fio supports defining up to 256 separate zones.</p><p>Similarly to how <code>[bssplit](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-bssplit)</code> works for setting ranges and percentages of block sizes. Like <code>[bssplit](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-bssplit)</code>, itâ€™s possible to specify separate zones for reads, writes, and trims. If just one set is given, itâ€™ll apply to all of them. This goes for both <strong>zoned</strong> <strong>zoned_abs</strong> distributions.</p></li><li><p><code>percentage_random=int[,int][,int]</code></p><p>For a random workload, set how big a percentage should be random. This defaults to 100%, in which case the workload is fully random. It can be set from anywhere from 0 to 100. Setting it to 0 would make the workload fully sequential. Any setting in between will result in a random mix of sequential and random I/O, at the given percentages. Comma-separated values may be specified for reads, writes, and trims as described in <code>[blocksize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize)</code>.</p></li><li><p><code>norandommap</code></p><p>Normally fio will cover every block of the file when doing random I/O. If this option is given, fio will just get a new random offset without looking at past I/O history. This means that some blocks may not be read or written, and that some blocks may be read/written more than once. If this option is used with <code>[verify](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-verify)</code> and multiple blocksizes (via <code>[bsrange](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize-range)</code>), only intact blocks are verified, i.e., partially-overwritten blocks are ignored. With an async I/O engine and an I/O depth > 1, it is possible for the same block to be overwritten, which can cause verification errors. Either do not use norandommap in this case, or also use the lfsr random generator.</p></li><li><p><code>softrandommap=bool</code></p><p>See <code>[norandommap](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-norandommap)</code>. If fio runs with the random block map enabled and it fails to allocate the map, if this option is set it will continue without a random block map. As coverage will not be as complete as with random maps, this option is disabled by default.</p></li><li><p><code>random_generator=str</code></p><p>Fio supports the following engines for generating I/O offsets for random I/O:</p><p><strong>tausworthe</strong></p><p>Strong 2^88 cycle random number generator.</p><p><strong>lfsr</strong></p><p>Linear feedback shift register generator.</p><p><strong>tausworthe64</strong></p><p>Strong 64-bit 2^258 cycle random number generator.</p><p><strong>tausworthe</strong> is a strong random number generator, but it requires tracking on the side if we want to ensure that blocks are only read or written once. <strong>lfsr</strong> guarantees that we never generate the same offset twice, and itâ€™s also less computationally expensive. Itâ€™s not a true random generator, however, though for I/O purposes itâ€™s typically good enough. <strong>lfsr</strong> only works with single block sizes, not with workloads that use multiple block sizes. If used with such a workload, fio may read or write some blocks multiple times. The default value is <strong>tausworthe</strong>, unless the required space exceeds 2^32 blocks. If it does, then <strong>tausworthe64</strong> is selected automatically.</p><blockquote><p>å¦‚ä½•ç†è§£ï¼Ÿ</p></blockquote></li></ul><h3 id=1127-block-size>1.12.7. Block size</h3><ul><li><p>â¤<code>blocksize=int[,int][,int], bs=int[,int][,int]</code></p><p>The block size in bytes used for I/O units. Default: 4096. A single value applies to reads, writes, and trims. Comma-separated values may be specified for reads, writes, and trims. A value not terminated in a comma applies to subsequent types.</p><p>Examples:</p><p><strong>bs=256k</strong></p><p>means 256k for reads, writes and trims.</p><p><strong>bs=8k,32k</strong></p><p>means 8k for reads, 32k for writes and trims.</p><p><strong>bs=8k,32k,</strong></p><p>means 8k for reads, 32k for writes, and default for trims.</p><p><strong>bs=,8k</strong></p><p>means default for reads, 8k for writes and trims.</p><p><strong>bs=,8k,</strong></p><p>means default for reads, 8k for writes, and default for trims.</p></li><li><p><code>blocksize_range=irange[,irange][,irange], bsrange=irange[,irange][,irange]</code></p><p>A range of block sizes in bytes for I/O units. The issued I/O unit will always be a multiple of the minimum size, unless <code>[blocksize_unaligned](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize-unaligned)</code> is set.</p><p>Comma-separated ranges may be specified for reads, writes, and trims as described in <code>[blocksize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize)</code>.</p><p>Example: <code>bsrange=1k-4k,2k-8k</code>.</p></li><li><p><code>bssplit=str[,str][,str]</code></p><p>Sometimes you want even finer grained control of the block sizes issued, not just an even split between them. This option allows you to weight various block sizes, so that you are able to define a specific amount of block sizes issued. The format for this option is:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>bssplit</span><span class=o>=</span>blocksize/percentage:blocksize/percentage
</span></span></code></pre></td></tr></table></div></div><p>for as many block sizes as needed. So if you want to define a workload that has 50% 64k blocks, 10% 4k blocks, and 40% 32k blocks, you would write:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>bssplit</span><span class=o>=</span>4k/10:64k/50:32k/40
</span></span></code></pre></td></tr></table></div></div><p>Ordering does not matter. If the percentage is left blank, fio will fill in the remaining values evenly. So a bssplit option like this one:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>bssplit</span><span class=o>=</span>4k/50:1k/:32k/
</span></span></code></pre></td></tr></table></div></div><p>would have 50% 4k ios, and 25% 1k and 32k ios. The percentages always add up to 100, if bssplit is given a range that adds up to more, it will error out.</p><p>Comma-separated values may be specified for reads, writes, and trims as described in <code>[blocksize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize)</code>.</p><p>If you want a workload that has 50% 2k reads and 50% 4k reads, while having 90% 4k writes and 10% 8k writes, you would specify:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>bssplit</span><span class=o>=</span>2k/50:4k/50,4k/90:8k/10
</span></span></code></pre></td></tr></table></div></div><p>Fio supports defining up to 64 different weights for each data direction.</p></li><li><p><code>blocksize_unaligned, bs_unaligned</code></p><p>If set, fio will issue I/O units with any size within <code>[blocksize_range](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize-range)</code>, not just multiples of the minimum size. This typically wonâ€™t work with direct I/O, as that normally requires sector alignment.</p></li><li><p><code>bs_is_seq_rand=bool</code></p><p>If this option is set, fio will use the normal read,write blocksize settings as sequential,random blocksize settings instead. Any random read or write will use the WRITE blocksize settings, and any sequential read or write will use the READ blocksize settings.</p></li><li><p><code>blockalign=int[,int][,int], ba=int[,int][,int]</code></p><p>Boundary to which fio will align random I/O units. Default: <code>[blocksize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize)</code>. Minimum alignment is typically 512b for using direct I/O, though it usually depends on the hardware block size. This option is mutually exclusive with using a random map for files, so it will turn off that option. Comma-separated values may be specified for reads, writes, and trims as described in <code>[blocksize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize)</code>.</p></li></ul><h3 id=1128-buffers-and-memory>1.12.8. Buffers and memory</h3><ul><li><p><code>zero_buffers</code></p><p>Initialize buffers with all zeros. Default: fill buffers with random data.</p></li><li><p><code>refill_buffers</code></p><p>If this option is given, fio will refill the I/O buffers on every submit. Only makes sense if <code>[zero_buffers](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-zero-buffers)</code> isnâ€™t specified, naturally. Defaults to being unset i.e., the buffer is only filled at init time and the data in it is reused when possible but if any of <code>[verify](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-verify)</code>, <code>[buffer_compress_percentage](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-buffer-compress-percentage)</code> or <code>[dedupe_percentage](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-dedupe-percentage)</code> are enabled then refill_buffers is also automatically enabled.</p></li><li><p><code>scramble_buffers=bool</code></p><p>If <code>[refill_buffers](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-refill-buffers)</code> is too costly and the target is using data deduplication, then setting this option will slightly modify the I/O buffer contents to defeat normal de-dupe attempts. This is not enough to defeat more clever block compression attempts, but it will stop naive dedupe of blocks. Default: true.</p></li><li><p><code>buffer_compress_percentage=int</code></p><p>If this is set, then fio will attempt to provide I/O buffer content (on WRITEs) that compresses to the specified level. Fio does this by providing a mix of random data followed by fixed pattern data. The fixed pattern is either zeros, or the pattern specified by <code>[buffer_pattern](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-buffer-pattern)</code>. If the buffer_pattern option is used, it might skew the compression ratio slightly. Setting buffer_compress_percentage to a value other than 100 will also enable <code>[refill_buffers](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-refill-buffers)</code> in order to reduce the likelihood that adjacent blocks are so similar that they over compress when seen together. See <code>[buffer_compress_chunk](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-buffer-compress-chunk)</code> for how to set a finer or coarser granularity for the random/fixed data region. Defaults to unset i.e., buffer data will not adhere to any compression level.</p></li><li><p><code>buffer_compress_chunk=int</code></p><p>This setting allows fio to manage how big the random/fixed data region is when using <code>[buffer_compress_percentage](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-buffer-compress-percentage)</code>. When buffer_compress_chunk is set to some non-zero value smaller than the block size, fio can repeat the random/fixed region throughout the I/O buffer at the specified interval (which particularly useful when bigger block sizes are used for a job). When set to 0, fio will use a chunk size that matches the block size resulting in a single random/fixed region within the I/O buffer. Defaults to 512. When the unit is omitted, the value is interpreted in bytes.</p></li><li><p><code>buffer_pattern=str</code></p><p>If set, fio will fill the I/O buffers with this pattern or with the contents of a file. If not set, the contents of I/O buffers are defined by the other options related to buffer contents. The setting can be any pattern of bytes, and can be prefixed with 0x for hex values. It may also be a string, where the string must then be wrapped with <code>""</code>. Or it may also be a filename, where the filename must be wrapped with <code>''</code> in which case the file is opened and read. Note that not all the file contents will be read if that would cause the buffers to overflow. So, for example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>buffer_pattern</span><span class=o>=</span><span class=s1>&#39;filename&#39;</span>
</span></span></code></pre></td></tr></table></div></div><p>or:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>buffer_pattern</span><span class=o>=</span><span class=s2>&#34;abcd&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>or:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>buffer_pattern</span><span class=o>=</span>-12
</span></span></code></pre></td></tr></table></div></div><p>or:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>buffer_pattern</span><span class=o>=</span>0xdeadface
</span></span></code></pre></td></tr></table></div></div><p>Also you can combine everything together in any order:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>buffer_pattern</span><span class=o>=</span>0xdeadface<span class=s2>&#34;abcd&#34;</span>-12<span class=s1>&#39;filename&#39;</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><code>dedupe_percentage=int</code></p><p>If set, fio will generate this percentage of identical buffers when writing. These buffers will be naturally dedupable. The contents of the buffers depend on what other buffer compression settings have been set. Itâ€™s possible to have the individual buffers either fully compressible, or not at all â€“ this option only controls the distribution of unique buffers. Setting this option will also enable <code>[refill_buffers](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-refill-buffers)</code> to prevent every buffer being identical.</p></li><li><p><code>invalidate=bool</code></p><p>Invalidate the buffer/page cache parts of the files to be used prior to starting I/O if the platform and file type support it. Defaults to true. This will be ignored if <code>[pre_read](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-pre-read)</code> is also specified for the same job.</p></li><li><p><code>sync=str</code></p><p>Whether, and what type, of synchronous I/O to use for writes. The allowed values are:</p><p><strong>none</strong></p><p>Do not use synchronous IO, the default.</p><p><strong>0</strong></p><p>Same as <strong>none</strong>.</p><p><strong>sync</strong></p><p>Use synchronous file IO. For the majority of I/O engines, this means using O_SYNC.</p><p><strong>1</strong></p><p>Same as <strong>sync</strong>.</p><p><strong>dsync</strong></p><p>Use synchronous data IO. For the majority of I/O engines, this means using O_DSYNC.</p></li><li><p><code>iomem=str, mem=str</code></p><p>Fio can use various types of memory as the I/O unit buffer. The allowed values are:</p><p><strong>malloc</strong></p><p>Use memory from <em>malloc(3)</em> as the buffers. Default memory type.</p><p><strong>shm</strong></p><p>Use shared memory as the buffers. Allocated through <em>shmget(2)</em>.</p><p><strong>shmhuge</strong></p><p>Same as shm, but use huge pages as backing.</p><p><strong>mmap</strong></p><p>Use <em>mmap(2)</em> to allocate buffers. May either be anonymous memory, or can be file backed if a filename is given after the option. The format is <em>mem=mmap:/path/to/file</em>.</p><p><strong>mmaphuge</strong></p><p>Use a memory mapped huge file as the buffer backing. Append filename after mmaphuge, ala <em>mem=mmaphuge:/hugetlbfs/file</em>.</p><p><strong>mmapshared</strong></p><p>Same as mmap, but use a MMAP_SHARED mapping.</p><p><strong>cudamalloc</strong></p><p>Use GPU memory as the buffers for GPUDirect RDMA benchmark. The <code>[ioengine](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-ioengine)</code> must be rdma.</p><p>The area allocated is a function of the maximum allowed <code>bs size</code> for the job, multiplied by the <code>I/O depth</code> given. Note that for <strong>shmhuge</strong> and <strong>mmaphuge</strong> to work, the system must have free huge pages allocated. This can normally be checked and set by reading/writing <code>/proc/sys/vm/nr_hugepages</code> on a Linux system. Fio assumes a huge page is 4MiB in size. So to calculate the number of huge pages you need for a given job file, add up the I/O depth of all jobs (normally one unless <code>[iodepth](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-iodepth)</code> is used) and multiply by the maximum bs set. Then divide that number by the huge page size. You can see the size of the huge pages in <code>/proc/meminfo</code>. If no huge pages are allocated by having a non-zero number in nr_hugepages, using <strong>mmaphuge</strong> or <strong>shmhuge</strong> will fail. Also see <code>[hugepage-size](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-hugepage-size)</code>.</p><p><strong>mmaphuge</strong> also needs to have hugetlbfs mounted and the file location should point there. So if itâ€™s mounted in <code>/huge</code>, you would use <em>mem=mmaphuge:/huge/somefile</em>.</p></li><li><p><code>iomem_align=int, mem_align=int</code></p><p>This indicates the memory alignment of the I/O memory buffers. Note that the given alignment is applied to the first I/O unit buffer, if using <code>[iodepth](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-iodepth)</code> the alignment of the following buffers are given by the <code>[bs](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize)</code> used. In other words, if using a <code>[bs](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize)</code> that is a multiple of the page sized in the system, all buffers will be aligned to this value. If using a <code>[bs](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize)</code> that is not page aligned, the alignment of subsequent I/O memory buffers is the sum of the <code>[iomem_align](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-iomem-align)</code> and <code>[bs](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize)</code> used.</p></li><li><p><code>hugepage-size=int</code></p><p>Defines the size of a huge page. Must at least be equal to the system setting, see <code>/proc/meminfo</code>. Defaults to 4MiB. Should probably always be a multiple of megabytes, so using <code>hugepage-size=Xm</code> is the preferred way to set this to avoid setting a non-pow-2 bad value.</p></li><li><p><code>lockmem=int</code></p><p>Pin the specified amount of memory with <em><code>mlock</code>(2)</em>. Can be used to simulate a smaller amount of memory. The amount specified is per worker.</p></li></ul><h3 id=1129-io-size>1.12.9. I/O size</h3><ul><li><p>â¤<code>size=int</code></p><p>The total size of file I/O for each thread of this job. Fio will run until this many bytes has been transferred, unless runtime is limited by other options (such as <code>[runtime](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-runtime)</code>, for instance, or increased/decreased by <code>[io_size](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-io-size)</code>). Fio will divide this size between the available files determined by options such as <code>[nrfiles](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-nrfiles)</code>, <code>[filename](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-filename)</code>, unless <code>[filesize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-filesize)</code> is specified by the job. If the result of division happens to be 0, the size is set to the physical size of the given files or devices if they exist. If this option is not specified, fio will use the full size of the given files or devices. If the files do not exist, size must be given. It is also possible to give size as a percentage between 1 and 100. If <code>size=20%</code> is given, fio will use 20% of the full size of the given files or devices. Can be combined with <code>[offset](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-offset)</code> to constrain the start and end range that I/O will be done within.</p></li><li><p>â¤<code>io_size=int, io_limit=int</code></p><p>Normally fio operates within the region set by <code>[size](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-size)</code>, which means that the <code>[size](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-size)</code> option sets both the region and size of I/O to be performed. Sometimes that is not what you want. With this option, it is possible to define just the amount of I/O that fio should do. For instance, if <code>[size](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-size)</code> is set to 20GiB and <code>[io_size](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-io-size)</code> is set to 5GiB, fio will perform I/O within the first 20GiB but exit when 5GiB have been done. The opposite is also possible â€“ if <code>[size](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-size)</code> is set to 20GiB, and <code>[io_size](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-io-size)</code> is set to 40GiB, then fio will do 40GiB of I/O within the 0..20GiB region.</p></li><li><p>â¤<code>filesize=irange(int)</code></p><p>Individual file sizes. May be a range, in which case fio will select sizes for files at random within the given range and limited to <code>[size](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-size)</code> in total (if that is given). If not given, each created file is the same size. This option overrides <code>[size](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-size)</code> in terms of file size, which means this value is used as a fixed size or possible range of each file.</p></li><li><p><code>file_append=bool</code></p><p>Perform I/O after the end of the file. Normally fio will operate within the size of a file. If this option is set, then fio will append to the file instead. This has identical behavior to setting <code>[offset](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-offset)</code> to the size of a file. This option is ignored on non-regular files.</p></li><li><p><code>fill_device=bool, fill_fs=bool</code></p><p>Sets size to something really large and waits for ENOSPC (no space left on device) as the terminating condition. Only makes sense with <code>sequential write</code>. For a read workload, the mount point will be filled first then I/O started on the result. This option doesnâ€™t make sense if operating on a raw device node, since the size of that is already known by the file system. Additionally, writing beyond end-of-device will not return ENOSPC there.</p></li></ul><h3 id=11210-io-engine>1.12.10. I/O engine</h3><ul><li><p>â¤<code>ioengine=str</code></p><p>Defines how the job issues I/O to the file. The following types are defined:</p><p><strong>sync</strong>Basic <em>read(2)</em> or <em>write(2)</em> I/O. <em>lseek(2)</em> is used to position the I/O location. See <code>[fsync](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-fsync)</code> and <code>[fdatasync](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-fdatasync)</code> for syncing write I/Os.</p><p><strong>psync</strong>Basic <em>pread(2)</em> or <em>pwrite(2)</em> I/O. Default on all supported operating systems except for Windows.</p><p><strong>vsync</strong>Basic <em>readv(2)</em> or <em>writev(2)</em> I/O. Will emulate queuing by coalescing adjacent I/Os into a single submission.</p><p><strong>pvsync</strong>Basic <em>preadv(2)</em> or <em>pwritev(2)</em> I/O.</p><p><strong>pvsync2</strong>Basic <em>preadv2(2)</em> or <em>pwritev2(2)</em> I/O.</p><p><strong>io_uring</strong>Fast Linux native asynchronous I/O. Supports async IO for both direct and buffered IO. This engine defines engine specific options.</p><p><strong>libaio</strong>Linux native asynchronous I/O. Note that Linux may only support queued behavior with non-buffered I/O (set <code>direct=1</code> or <code>buffered=0</code>). This engine defines engine specific options.</p><p><strong>posixaio</strong>POSIX asynchronous I/O using <em>aio_read(3)</em> and <em>aio_write(3)</em>.</p><p><strong>solarisaio</strong>Solaris native asynchronous I/O.</p><p><strong>windowsaio</strong>Windows native asynchronous I/O. Default on Windows.</p><p><strong>mmap</strong>File is memory mapped with <em>mmap(2)</em> and data copied to/from using <em>memcpy(3)</em>.</p><p><strong>splice</strong><em>splice(2)</em> is used to transfer the data and <em>vmsplice(2)</em> to transfer data from user space to the kernel.</p><p><strong>sg</strong>SCSI generic sg v3 I/O. May either be synchronous using the SG_IO ioctl, or if the target is an sg character device we use <em>read(2)</em> and <em>write(2)</em> for asynchronous I/O. Requires <code>[filename](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-filename)</code> option to specify either block or character devices. This engine supports trim operations. The sg engine includes engine specific options.</p><p><strong>null</strong>Doesnâ€™t transfer any data, just pretends to. This is mainly used to exercise fio itself and for debugging/testing purposes.</p><p><strong>net</strong>Transfer over the network to given <code>host:port</code>. Depending on the <code>[protocol](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-protocol)</code> used, the <code>[hostname](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-hostname)</code>, <code>[port](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-port)</code>, <code>[listen](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-listen)</code> and <code>[filename](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-filename)</code> options are used to specify what sort of connection to make, while the <code>[protocol](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-protocol)</code> option determines which protocol will be used. This engine defines engine specific options.</p><p><strong>netsplice</strong>Like <strong>net</strong>, but uses <em>splice(2)</em> and <em>vmsplice(2)</em> to map data and send/receive. This engine defines engine specific options.</p><p><strong>cpuio</strong>Doesnâ€™t transfer any data, but burns CPU cycles according to the <code>[cpuload](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-cpuload)</code>, <code>[cpuchunks](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-cpuchunks)</code> and <code>cpumode</code> options. Setting <code>[cpuload](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-cpuload)</code>=85 will cause that job to do nothing but burn 85% of the CPU. In case of SMP machines, use <code>[numjobs](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-numjobs)</code>= to get desired CPU usage, as the cpuload only loads a single CPU at the desired rate. A job never finishes unless there is at least one non-cpuio job. Setting <code>cpumode</code>=qsort replace the default noop instructions loop by a qsort algorithm to consume more energy.</p><p><strong>rdma</strong>The RDMA I/O engine supports both RDMA memory semantics (RDMA_WRITE/RDMA_READ) and channel semantics (Send/Recv) for the InfiniBand, RoCE and iWARP protocols. This engine defines engine specific options.</p><p><strong>falloc</strong>I/O engine that does regular fallocate to simulate data transfer as fio ioengine.</p><p>DDIR_READdoes fallocate(,mode = FALLOC_FL_KEEP_SIZE,).</p><p>DDIR_WRITEdoes fallocate(,mode = 0).</p><p>DDIR_TRIMdoes fallocate(,mode = FALLOC_FL_KEEP_SIZE|FALLOC_FL_PUNCH_HOLE).</p><p><strong>ftruncate</strong>I/O engine that sends <em>ftruncate(2)</em> operations in response to write (DDIR_WRITE) events. Each ftruncate issued sets the fileâ€™s size to the current block offset. <code>[blocksize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize)</code> is ignored.</p><p><strong>e4defrag</strong>I/O engine that does regular EXT4_IOC_MOVE_EXT ioctls to simulate defragment activity in request to DDIR_WRITE event.</p><p><strong>rados</strong>I/O engine supporting direct access to Ceph Reliable Autonomic Distributed Object Store (RADOS) via <code>librados</code>. This ioengine defines engine specific options.</p><p><strong>rbd</strong>I/O engine supporting direct access to Ceph Rados Block Devices (RBD) via <code>librbd</code> without the need to use the kernel rbd driver. This ioengine defines engine specific options.</p><p><strong>http</strong></p><p>I/O engine supporting GET/PUT requests over HTTP(S) with libcurl to a WebDAV or S3 endpoint. This ioengine defines engine specific options.</p><p>This engine only supports direct IO of iodepth=1; you need to scale this via numjobs. blocksize defines the size of the objects to be created.</p><p>TRIM is translated to object deletion.</p><p><strong>gfapi</strong>Using GlusterFS libgfapi sync interface to direct access to GlusterFS volumes without having to go through FUSE. This ioengine defines engine specific options.</p><p><strong>gfapi_async</strong>Using GlusterFS libgfapi async interface to direct access to GlusterFS volumes without having to go through FUSE. This ioengine defines engine specific options.</p><p><strong>libhdfs</strong>Read and write through Hadoop (HDFS). The <code>[filename](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-filename)</code> option is used to specify host,port of the hdfs name-node to connect. This engine interprets offsets a little differently. In HDFS, files once created cannot be modified so random writes are not possible. To imitate this the libhdfs engine expects a bunch of small files to be created over HDFS and will randomly pick a file from them based on the offset generated by fio backend (see the example job file to create such files, use <code>rw=write</code> option). Please note, it may be necessary to set environment variables to work with HDFS/libhdfs properly. Each job uses its own connection to HDFS.</p><p><strong>mtd</strong>Read, write and erase an MTD character device (e.g., <code>/dev/mtd0</code>). Discards are treated as erases. Depending on the underlying device type, the I/O may have to go in a certain pattern, e.g., on NAND, writing sequentially to erase blocks and discarding before overwriting. The trimwrite mode works well for this constraint.</p><p><strong>pmemblk</strong>Read and write using filesystem DAX to a file on a filesystem mounted with DAX on a persistent memory device through the <code>PMDK</code> libpmemblk library.</p><p><strong>dev-dax</strong>Read and write using device DAX to a persistent memory device (e.g., /dev/dax0.0) through the PMDK libpmem library.</p><p><strong>external</strong>Prefix to specify loading an external I/O engine object file. Append the engine filename, e.g.Â <code>ioengine=external:/tmp/foo.o</code> to load ioengine <code>foo.o</code> in <code>/tmp</code>. The path can be either absolute or relative. See <code>engines/skeleton_external.c</code> for details of writing an external I/O engine.</p><p><strong>filecreate</strong>Simply create the files and do no I/O to them. You still need to set filesize so that all the accounting still occurs, but no actual I/O will be done other than creating the file.</p><p><strong>filestat</strong>Simply do stat() and do no I/O to the file. You need to set â€˜filesizeâ€™ and â€˜nrfilesâ€™, so that files will be created. This engine is to measure file lookup and meta data access.</p><p><strong>libpmem</strong>Read and write using mmap I/O to a file on a filesystem mounted with DAX on a persistent memory device through the PMDK libpmem library.</p><p><strong>ime_psync</strong>Synchronous read and write using DDNâ€™s Infinite Memory Engine (IME). This engine is very basic and issues calls to IME whenever an IO is queued.</p><p><strong>ime_psyncv</strong>Synchronous read and write using DDNâ€™s Infinite Memory Engine (IME). This engine uses iovecs and will try to stack as much IOs as possible (if the IOs are â€œcontiguousâ€ and the IO depth is not exceeded) before issuing a call to IME.</p><p><strong>ime_aio</strong>Asynchronous read and write using DDNâ€™s Infinite Memory Engine (IME). This engine will try to stack as much IOs as possible by creating requests for IME. FIO will then decide when to commit these requests.</p><p><strong>libiscsi</strong>Read and write iscsi lun with libiscsi.</p><p><strong>nbd</strong>Read and write a Network Block Device (NBD).</p><p><strong>libcufile</strong>I/O engine supporting libcufile synchronous access to nvidia-fs and a GPUDirect Storage-supported filesystem. This engine performs I/O without transferring buffers between user-space and the kernel, unless <code>[verify](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-verify)</code> is set or <code>[cuda_io](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-cuda-io)</code> is posix. <code>[iomem](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-iomem)</code> must not be cudamalloc. This ioengine defines engine specific options.</p></li></ul><h3 id=11211-io-engine-specific-parameters>1.12.11. I/O engine specific parameters</h3><p>In addition, there are some parameters which are only valid when a specific <code>[ioengine](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-ioengine)</code> is in use. These are used identically to normal parameters, with the caveat that when used on the command line, they must come after the <code>[ioengine](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-ioengine)</code> that defines them is selected.</p><ul><li><p><code>cmdprio_percentage``=int : [io_uring] [libaio]</code></p><p>Set the percentage of I/O that will be issued with higher priority by setting the priority bit. Non-read I/O is likely unaffected by <code>cmdprio_percentage</code>. This option cannot be used with the prio or prioclass options. For this option to set the priority bit properly, NCQ priority must be supported and enabled and <code>[direct](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-direct)</code>=1 option must be used. fio must also be run as the root user.</p></li><li><p><code>fixedbufs`` : [io_uring]</code></p><p>If fio is asked to do direct IO, then Linux will map pages for each IO call, and release them when IO is done. If this option is set, the pages are pre-mapped before IO is started. This eliminates the need to map and release for each IO. This is more efficient, and reduces the IO latency as well.</p></li><li><p><code>hipri`` : [io_uring]</code></p><p>If this option is set, fio will attempt to use polled IO completions. Normal IO completions generate interrupts to signal the completion of IO, polled completions do not. Hence they are require active reaping by the application. The benefits are more efficient IO for high IOPS scenarios, and lower latencies for low queue depth IO.</p></li><li><p><code>registerfiles`` : [io_uring]</code></p><p>With this option, fio registers the set of files being used with the kernel. This avoids the overhead of managing file counts in the kernel, making the submission and completion part more lightweight. Required for the below <code>[sqthread_poll](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-sqthread-poll)</code> option.</p></li><li><p><code>sqthread_poll`` : [io_uring]</code></p><p>Normally fio will submit IO by issuing a system call to notify the kernel of available items in the SQ ring. If this option is set, the act of submitting IO will be done by a polling thread in the kernel. This frees up cycles for fio, at the cost of using more CPU in the system.</p></li><li><p><code>sqthread_poll_cpu`` : [io_uring]</code></p><p>When <code>[sqthread_poll](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-sqthread-poll)</code> is set, this option provides a way to define which CPU should be used for the polling thread.</p></li><li><p><code>userspace_reap`` : [libaio]</code></p><p>Normally, with the libaio engine in use, fio will use the <em>io_getevents(2)</em> system call to reap newly returned events. With this flag turned on, the AIO ring will be read directly from user-space to reap events. The reaping mode is only enabled when polling for a minimum of 0 events (e.g.Â when <code>[iodepth_batch_complete](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-iodepth-batch-complete-min)</code> =0).</p></li><li><p><code>hipri`` : [pvsync2]</code></p><p>Set RWF_HIPRI on I/O, indicating to the kernel that itâ€™s of higher priority than normal.</p></li><li><p><code>hipri_percentage`` : [pvsync2]</code></p><p>When hipri is set this determines the probability of a pvsync2 I/O being high priority. The default is 100%.</p></li><li><p><code>nowait`` : [pvsync2] [libaio] [io_uring]</code></p><p>By default if a request cannot be executed immediately (e.g.Â resource starvation, waiting on locks) it is queued and the initiating process will be blocked until the required resource becomes free.This option sets the RWF_NOWAIT flag (supported from the 4.14 Linux kernel) and the call will return instantly with EAGAIN or a partial result rather than waiting.It is useful to also use ignore_error=EAGAIN when using this option.Note: glibc 2.27, 2.28 have a bug in syscall wrappers preadv2, pwritev2. They return EOPNOTSUP instead of EAGAIN.For cached I/O, using this option usually means a request operates only with cached data. Currently the RWF_NOWAIT flag does not supported for cached write.For direct I/O, requests will only succeed if cache invalidation isnâ€™t required, file blocks are fully allocated and the disk request could be issued immediately.</p></li><li><p><code>cpuload``=int : [cpuio]</code></p><p>Attempt to use the specified percentage of CPU cycles. This is a mandatory option when using cpuio I/O engine.</p></li><li><p><code>cpuchunks``=int : [cpuio]</code></p><p>Split the load into cycles of the given time. In microseconds.</p></li><li><p><code>exit_on_io_done``=bool : [cpuio]</code></p><p>Detect when I/O threads are done, then exit.</p></li><li><p><code>namenode``=str : [libhdfs]</code></p><p>The hostname or IP address of a HDFS cluster namenode to contact.</p></li><li><p><code>port``=int</code></p><p>[libhdfs]The listening port of the HFDS cluster namenode.[netsplice], [net]The TCP or UDP port to bind to or connect to. If this is used with <code>[numjobs](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-numjobs)</code> to spawn multiple instances of the same job type, then this will be the starting port number since fio will use a range of ports.[rdma]The port to use for RDMA-CM communication. This should be the same value on the client and the server side.</p></li><li><p><code>hostname``=str : [netsplice] [net] [rdma]</code></p><p>The hostname or IP address to use for TCP, UDP or RDMA-CM based I/O. If the job is a TCP listener or UDP reader, the hostname is not used and must be omitted unless it is a valid UDP multicast address.</p></li><li><p><code>interface``=str : [netsplice] [net]</code></p><p>The IP address of the network interface used to send or receive UDP multicast.</p></li><li><p><code>ttl``=int : [netsplice] [net]</code></p><p>Time-to-live value for outgoing UDP multicast packets. Default: 1.</p></li><li><p><code>nodelay``=bool : [netsplice] [net]</code></p><p>Set TCP_NODELAY on TCP connections.</p></li><li><p><code>protocol``=str``, ``proto``=str : [netsplice] [net]</code></p><p>The network protocol to use. Accepted values are:<strong>tcp</strong>Transmission control protocol.<strong>tcpv6</strong>Transmission control protocol V6.<strong>udp</strong>User datagram protocol.<strong>udpv6</strong>User datagram protocol V6.<strong>unix</strong>UNIX domain socket.When the protocol is TCP or UDP, the port must also be given, as well as the hostname if the job is a TCP listener or UDP reader. For unix sockets, the normal <code>[filename](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-filename)</code> option should be used and the port is invalid.</p></li><li><p><code>listen`` : [netsplice] [net]</code></p><p>For TCP network connections, tell fio to listen for incoming connections rather than initiating an outgoing connection. The <code>[hostname](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-hostname)</code> must be omitted if this option is used.</p></li><li><p><code>pingpong`` : [netsplice] [net]</code></p><p>Normally a network writer will just continue writing data, and a network reader will just consume packages. If <code>pingpong=1</code> is set, a writer will send its normal payload to the reader, then wait for the reader to send the same payload back. This allows fio to measure network latencies. The submission and completion latencies then measure local time spent sending or receiving, and the completion latency measures how long it took for the other end to receive and send back. For UDP multicast traffic <code>pingpong=1</code> should only be set for a single reader when multiple readers are listening to the same address.</p></li><li><p><code>window_size`` : [netsplice] [net]</code></p><p>Set the desired socket buffer size for the connection.</p></li><li><p><code>mss`` : [netsplice] [net]</code></p><p>Set the TCP maximum segment size (TCP_MAXSEG).</p></li><li><p><code>donorname``=str : [e4defrag]</code></p><p>File will be used as a block donor (swap extents between files).</p></li><li><p><code>inplace``=int : [e4defrag]</code></p><p>Configure donor file blocks allocation strategy:<strong>0</strong>Default. Preallocate donorâ€™s file on init.<strong>1</strong>Allocate space immediately inside defragment event, and free right after event.</p></li><li><p><code>clustername``=str : [rbd,rados]</code></p><p>Specifies the name of the Ceph cluster.</p></li><li><p><code>rbdname``=str : [rbd]</code></p><p>Specifies the name of the RBD.</p></li><li><p><code>pool``=str : [rbd,rados]</code></p><p>Specifies the name of the Ceph pool containing RBD or RADOS data.</p></li><li><p><code>clientname``=str : [rbd,rados]</code></p><p>Specifies the username (without the â€˜client.â€™ prefix) used to access the Ceph cluster. If the <em>clustername</em> is specified, the <em>clientname</em> shall be the full <em>type.id</em> string. If no type. prefix is given, fio will add â€˜client.â€™ by default.</p></li><li><p><code>busy_poll``=bool : [rbd,rados]</code></p><p>Poll store instead of waiting for completion. Usually this provides better throughput at cost of higher(up to 100%) CPU utilization.</p></li><li><p><code>skip_bad``=bool : [mtd]</code></p><p>Skip operations against known bad blocks.</p></li><li><p><code>hdfsdirectory`` : [libhdfs]</code></p><p>libhdfs will create chunk in this HDFS directory.</p></li><li><p><code>chunk_size`` : [libhdfs]</code></p><p>The size of the chunk to use for each file.</p></li><li><p><code>verb``=str : [rdma]</code></p><p>The RDMA verb to use on this side of the RDMA ioengine connection. Valid values are write, read, send and recv. These correspond to the equivalent RDMA verbs (e.g.Â write = rdma_write etc.). Note that this only needs to be specified on the client side of the connection. See the examples folder.</p></li><li><p><code>bindname``=str : [rdma]</code></p><p>The name to use to bind the local RDMA-CM connection to a local RDMA device. This could be a hostname or an IPv4 or IPv6 address. On the server side this will be passed into the rdma_bind_addr() function and on the client site it will be used in the rdma_resolve_add() function. This can be useful when multiple paths exist between the client and the server or in certain loopback configurations.</p></li><li><p><code>stat_type``=str : [filestat]</code></p><p>Specify stat system call type to measure lookup/getattr performance. Default is <strong>stat</strong> for <em>stat(2)</em>.</p></li><li><p><code>readfua``=bool : [sg]</code></p><p>With readfua option set to 1, read operations include the force unit access (fua) flag. Default is 0.</p></li><li><p><code>writefua``=bool : [sg]</code></p><p>With writefua option set to 1, write operations include the force unit access (fua) flag. Default is 0.</p></li><li><p><code>sg_write_mode``=str : [sg]</code></p><p>Specify the type of write commands to issue. This option can take three values:<strong>write</strong>This is the default where write opcodes are issued as usual.<strong>verify</strong>Issue WRITE AND VERIFY commands. The BYTCHK bit is set to 0. This directs the device to carry out a medium verification with no data comparison. The writefua option is ignored with this selection.<strong>same</strong>Issue WRITE SAME commands. This transfers a single block to the device and writes this same block of data to a contiguous sequence of LBAs beginning at the specified offset. fioâ€™s block size parameter specifies the amount of data written with each command. However, the amount of data actually transferred to the device is equal to the deviceâ€™s block (sector) size. For a device with 512 byte sectors, blocksize=8k will write 16 sectors with each command. fio will still generate 8k of data for each command but only the first 512 bytes will be used and transferred to the device. The writefua option is ignored with this selection.</p></li><li><p><code>hipri`` : [sg]</code></p><p>If this option is set, fio will attempt to use polled IO completions. This will have a similar effect as (io_uring)hipri. Only SCSI READ and WRITE commands will have the SGV4_FLAG_HIPRI set (not UNMAP (trim) nor VERIFY). Older versions of the Linux sg driver that do not support hipri will simply ignore this flag and do normal IO. The Linux SCSI Low Level Driver (LLD) that â€œownsâ€ the device also needs to support hipri (also known as iopoll and mq_poll). The MegaRAID driver is an example of a SCSI LLD. Default: clear (0) which does normal (interrupted based) IO.</p></li><li><p><code>http_host``=str : [http]</code></p><p>Hostname to connect to. For S3, this could be the bucket hostname. Default is <strong>localhost</strong></p></li><li><p><code>http_user``=str : [http]</code></p><p>Username for HTTP authentication.</p></li><li><p><code>http_pass``=str : [http]</code></p><p>Password for HTTP authentication.</p></li><li><p><code>https``=str : [http]</code></p><p>Enable HTTPS instead of http. <em>on</em> enables HTTPS; <em>insecure</em> will enable HTTPS, but disable SSL peer verification (use with caution!). Default is <strong>off</strong></p></li><li><p><code>http_mode``=str : [http]</code></p><p>Which HTTP access mode to use: <em>webdav</em>, <em>swift</em>, or <em>s3</em>. Default is <strong>webdav</strong></p></li><li><p><code>http_s3_region``=str : [http]</code></p><p>The S3 region/zone string. Default is <strong>us-east-1</strong></p></li><li><p><code>http_s3_key``=str : [http]</code></p><p>The S3 secret key.</p></li><li><p><code>http_s3_keyid``=str : [http]</code></p><p>The S3 key/access id.</p></li><li><p><code>http_swift_auth_token``=str : [http]</code></p><p>The Swift auth token. See the example configuration file on how to retrieve this.</p></li><li><p><code>http_verbose``=int : [http]</code></p><p>Enable verbose requests from libcurl. Useful for debugging. 1 turns on verbose logging from libcurl, 2 additionally enables HTTP IO tracing. Default is <strong>0</strong></p></li><li><p><code>uri``=str : [nbd]</code></p><p>Specify the NBD URI of the server to test. The string is a standard NBD URI (see
<a href=https://github.com/NetworkBlockDevice/nbd/tree/master/doc%29 rel=noopener>https://github.com/NetworkBlockDevice/nbd/tree/master/doc)</a>. Example URIs: nbd://localhost:10809 nbd+unix:///?socket=/tmp/socket nbds://tlshost/exportname</p></li><li><p><code>gpu_dev_ids``=str : [libcufile]</code></p><p>Specify the GPU IDs to use with CUDA. This is a colon-separated list of int. GPUs are assigned to workers roundrobin. Default is 0.</p></li><li><p><code>cuda_io``=str : [libcufile]</code></p><p>Specify the type of I/O to use with CUDA. Default is <strong>cufile</strong>.<strong>cufile</strong>Use libcufile and nvidia-fs. This option performs I/O directly between a GPUDirect Storage filesystem and GPU buffers, avoiding use of a bounce buffer. If <code>[verify](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-verify)</code> is set, cudaMemcpy is used to copy verificaton data between RAM and GPU. Verification data is copied from RAM to GPU before a write and from GPU to RAM after a read. <code>[direct](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-direct)</code> must be 1.<strong>posix</strong>Use POSIX to perform I/O with a RAM buffer, and use cudaMemcpy to transfer data between RAM and the GPUs. Data is copied from GPU to RAM before a write and copied from RAM to GPU after a read. <code>[verify](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-verify)</code> does not affect use of cudaMemcpy.</p></li></ul><h3 id=11212-io-depth>1.12.12. I/O depth</h3><ul><li><p>â¤<code>iodepth=int</code></p><p>Number of I/O units to keep in flight against the file. Note that increasing <em>iodepth</em> beyond 1 will not affect synchronous ioengines (except for small degrees when <code>[verify_async](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-verify-async)</code> is in use). Even async engines may impose OS restrictions causing the desired depth not to be achieved. This may happen on Linux when using libaio and not setting <code>[direct](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-direct)</code>=1, since buffered I/O is not async on that OS. Keep an eye on the I/O depth distribution in the fio output to verify that the achieved depth is as expected. Default: 1.</p></li><li><p><code>iodepth_batch_submit=int, iodepth_batch=int</code></p><p>This defines how many pieces of I/O to submit at once. It defaults to 1 which means that we submit each I/O as soon as it is available, but can be raised to submit bigger batches of I/O at the time. If it is set to 0 the <code>[iodepth](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-iodepth)</code> value will be used.</p></li><li><p><code>iodepth_batch_complete_min=int, iodepth_batch_complete=int</code></p><p>This defines how many pieces of I/O to retrieve at once. It defaults to 1 which means that weâ€™ll ask for a minimum of 1 I/O in the retrieval process from the kernel. The I/O retrieval will go on until we hit the limit set by <code>[iodepth_low](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-iodepth-low)</code>. If this variable is set to 0, then fio will always check for completed events before queuing more I/O. This helps reduce I/O latency, at the cost of more retrieval system calls.</p></li><li><p><code>iodepth_batch_complete_max=int</code></p><p>This defines maximum pieces of I/O to retrieve at once. This variable should be used along with <code>[iodepth_batch_complete_min](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-iodepth-batch-complete-min)</code>=int variable, specifying the range of min and max amount of I/O which should be retrieved. By default it is equal to the <code>[iodepth_batch_complete_min](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-iodepth-batch-complete-min)</code> value.</p><p>Example #1:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>iodepth_batch_complete_min</span><span class=o>=</span><span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nv>iodepth_batch_complete_max</span><span class=o>=</span>&lt;iodepth&gt;
</span></span></code></pre></td></tr></table></div></div><p>which means that we will retrieve at least 1 I/O and up to the whole submitted queue depth. If none of I/O has been completed yet, we will wait.</p><p>Example #2:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>iodepth_batch_complete_min</span><span class=o>=</span><span class=m>0</span>
</span></span><span class=line><span class=cl><span class=nv>iodepth_batch_complete_max</span><span class=o>=</span>&lt;iodepth&gt;
</span></span></code></pre></td></tr></table></div></div><p>which means that we can retrieve up to the whole submitted queue depth, but if none of I/O has been completed yet, we will NOT wait and immediately exit the system call. In this example we simply do polling.</p></li><li><p><code>iodepth_low=int</code></p><p>The low water mark indicating when to start filling the queue again. Defaults to the same as <code>[iodepth](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-iodepth)</code>, meaning that fio will attempt to keep the queue full at all times. If <code>[iodepth](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-iodepth)</code> is set to e.g.Â 16 and <em>iodepth_low</em> is set to 4, then after fio has filled the queue of 16 requests, it will let the depth drain down to 4 before starting to fill it again.</p></li><li><p><code>serialize_overlap=bool</code></p><p>Serialize in-flight I/Os that might otherwise cause or suffer from data races. When two or more I/Os are submitted simultaneously, there is no guarantee that the I/Os will be processed or completed in the submitted order. Further, if two or more of those I/Os are writes, any overlapping region between them can become indeterminate/undefined on certain storage. These issues can cause verification to fail erratically when at least one of the racing I/Os is changing data and the overlapping region has a non-zero size. Setting <code>serialize_overlap</code> tells fio to avoid provoking this behavior by explicitly serializing in-flight I/Os that have a non-zero overlap. Note that setting this option can reduce both performance and the <code>[iodepth](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-iodepth)</code> achieved.</p><p>This option only applies to I/Os issued for a single job except when it is enabled along with <code>[io_submit_mode](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-io-submit-mode)</code>=offload. In offload mode, fio will check for overlap among all I/Os submitted by offload jobs with <code>[serialize_overlap](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-serialize-overlap)</code> enabled.</p><p>Default: false.</p></li><li><p><code>io_submit_mode=str</code></p><p>This option controls how fio submits the I/O to the I/O engine. The default is inline, which means that the fio job threads submit and reap I/O directly. If set to <code>offload</code>, the job threads will offload I/O submission to a dedicated pool of I/O threads. This requires some coordination and thus has a bit of extra overhead, especially for lower queue depth I/O where it can increase latencies. The benefit is that fio can manage submission rates independently of the device completion rates. This avoids skewed latency reporting if I/O gets backed up on the device side (the coordinated omission problem). Note that this option cannot reliably be used with async IO engines.</p></li></ul><h3 id=11213-io-rate>1.12.13. I/O rate</h3><ul><li><p><code>thinktime=time</code></p><p>Stall the job for the specified period of time after an I/O has completed before issuing the next. May be used to simulate processing being done by an application. When the unit is omitted, the value is interpreted in <code>microseconds</code>. See <code>[thinktime_blocks](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-thinktime-blocks)</code> and <code>[thinktime_spin](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-thinktime-spin)</code>.</p></li><li><p><code>thinktime_spin=time</code></p><p>Only valid if <code>[thinktime](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-thinktime)</code> is set - pretend to spend CPU time doing something with the data received, before falling back to sleeping for the rest of the period specified by <code>[thinktime](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-thinktime)</code>. When the unit is omitted, the value is interpreted in <code>microseconds</code>.</p></li><li><p><code>thinktime_blocks=int</code></p><p>Only valid if <code>[thinktime](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-thinktime)</code> is set - control how many blocks to issue, before waiting <code>[thinktime](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-thinktime)</code> usecs. If not set, defaults to 1 which will make fio wait <code>[thinktime](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-thinktime)</code> usecs after every block. This effectively makes any queue depth setting redundant, since no more than 1 I/O will be queued before we have to complete it and do our <code>[thinktime](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-thinktime)</code>. In other words, this setting effectively caps the queue depth if the latter is larger.</p></li><li><p><code>thinktime_blocks_type=str</code></p><p>Only valid if <code>[thinktime](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-thinktime)</code> is set - control how <code>[thinktime_blocks](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-thinktime-blocks)</code> triggers. The default is complete, which triggers thinktime when fio completes <code>[thinktime_blocks](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-thinktime-blocks)</code> blocks. If this is set to issue, then the trigger happens at the <code>issue side</code>.</p></li><li><p><code>rate=int[,int][,int]</code></p><p>Cap the bandwidth used by this job. The number is in bytes/sec, the normal suffix rules apply. Comma-separated values may be specified for reads, writes, and trims as described in <code>[blocksize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize)</code>.</p><p>For example, using rate=1m,500k would limit reads to 1MiB/sec and writes to 500KiB/sec.Â Capping only reads or writes can be done with rate=,500k or rate=500k, where the former will only limit writes (to 500KiB/sec) and the latter will only limit reads.</p></li><li><p><code>rate_min=int[,int][,int]</code></p><p>Tell fio to do whatever it can to maintain at least this bandwidth. Failing to meet this requirement will cause the job to exit. Comma-separated values may be specified for reads, writes, and trims as described in <code>[blocksize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize)</code>.</p></li><li><p><code>rate_iops=int[,int][,int]</code></p><p>Cap the bandwidth to this number of IOPS. Basically the same as <code>[rate](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-rate)</code>, just specified independently of bandwidth. If the job is given a block size range instead of a fixed value, the smallest block size is used as the metric. Comma-separated values may be specified for reads, writes, and trims as described in <code>[blocksize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize)</code>.</p></li><li><p><code>rate_iops_min=int[,int][,int]</code></p><p>If fio doesnâ€™t meet this rate of I/O, it will cause the job to exit. Comma-separated values may be specified for reads, writes, and trims as described in <code>[blocksize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize)</code>.</p></li><li><p><code>rate_process=str</code></p><p>This option controls how fio manages rated I/O submissions. The default is linear, which submits I/O in a linear fashion with fixed delays between I/Os that gets adjusted based on I/O completion rates. If this is set to poisson, fio will submit I/O based on a more real world random request flow, known as the Poisson process (
<a href=https://en.wikipedia.org/wiki/Poisson_point_process rel=noopener>https://en.wikipedia.org/wiki/Poisson_point_process</a>). The lambda will be 10^6 / IOPS for the given workload.</p></li><li><p><code>rate_ignore_thinktime=bool</code></p><p>By default, fio will attempt to catch up to the specified rate setting, if any kind of thinktime setting was used. If this option is set, then fio will ignore the thinktime and continue doing IO at the specified rate, instead of entering a catch-up mode after thinktime is done.</p></li></ul><h3 id=11214-io-latency>1.12.14. I/O latency</h3><ul><li><p><code>latency_target``=time</code></p><p>If set, fio will attempt to find the max performance point that the given workload will run at while maintaining a latency below this target. When the unit is omitted, the value is interpreted in microseconds. See <code>[latency_window](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-latency-window)</code> and <code>[latency_percentile](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-latency-percentile)</code>.</p></li><li><p><code>latency_window``=time</code></p><p>Used with <code>[latency_target](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-latency-target)</code> to specify the sample window that the job is run at varying queue depths to test the performance. When the unit is omitted, the value is interpreted in microseconds.</p></li><li><p><code>latency_percentile``=float</code></p><p>The percentage of I/Os that must fall within the criteria specified by <code>[latency_target](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-latency-target)</code> and <code>[latency_window](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-latency-window)</code>. If not set, this defaults to 100.0, meaning that all I/Os must be equal or below to the value set by <code>[latency_target](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-latency-target)</code>.</p></li><li><p><code>latency_run``=bool</code></p><p>Used with <code>[latency_target](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-latency-target)</code>. If false (default), fio will find the highest queue depth that meets <code>[latency_target](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-latency-target)</code> and exit. If true, fio will continue running and try to meet <code>[latency_target](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-latency-target)</code> by adjusting queue depth.</p></li><li><p><code>max_latency``=time</code></p><p>If set, fio will exit the job with an ETIMEDOUT error if it exceeds this maximum latency. When the unit is omitted, the value is interpreted in microseconds.</p></li><li><p><code>rate_cycle``=int</code></p><p>Average bandwidth for <code>[rate](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-rate)</code> and <code>[rate_min](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-rate-min)</code> over this number of milliseconds. Defaults to 1000.</p></li></ul><h3 id=11215-io-replay>1.12.15. I/O replay</h3><ul><li><p><code>write_iolog``=str</code></p><p>Write the issued I/O patterns to the specified file. See <code>[read_iolog](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-read-iolog)</code>. Specify a separate file for each job, otherwise the iologs will be interspersed and the file may be corrupt.</p></li><li><p><code>read_iolog``=str</code></p><p>Open an iolog with the specified filename and replay the I/O patterns it contains. This can be used to store a workload and replay it sometime later. The iolog given may also be a blktrace binary file, which allows fio to replay a workload captured by <strong>blktrace</strong>. See <em>blktrace(8)</em> for how to capture such logging data. For blktrace replay, the file needs to be turned into a blkparse binary data file first (<code>blkparse &lt;device> -o /dev/null -d file_for_fio.bin</code>). You can specify a number of files by separating the names with a â€˜:â€™ character. See the <code>[filename](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-filename)</code> option for information on how to escape â€˜:â€™ characters within the file names. These files will be sequentially assigned to job clones created by <code>[numjobs](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-numjobs)</code>. â€˜-â€˜ is a reserved name, meaning read from stdin, notably if <code>[filename](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-filename)</code> is set to â€˜-â€˜ which means stdin as well, then this flag canâ€™t be set to â€˜-â€˜.</p></li><li><p><code>read_iolog_chunked``=bool</code></p><p>Determines how iolog is read. If false(default) entire <code>[read_iolog](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-read-iolog)</code> will be read at once. If selected true, input from iolog will be read gradually. Useful when iolog is very large, or it is generated.</p></li><li><p><code>merge_blktrace_file``=str</code></p><p>When specified, rather than replaying the logs passed to <code>[read_iolog](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-read-iolog)</code>, the logs go through a merge phase which aggregates them into a single blktrace. The resulting file is then passed on as the <code>[read_iolog](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-read-iolog)</code> parameter. The intention here is to make the order of events consistent. This limits the influence of the scheduler compared to replaying multiple blktraces via concurrent jobs.</p></li><li><p><code>merge_blktrace_scalars``=float_list</code></p><p>This is a percentage based option that is index paired with the list of files passed to <code>[read_iolog](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-read-iolog)</code>. When merging is performed, scale the time of each event by the corresponding amount. For example, <code>--merge_blktrace_scalars="50:100"</code> runs the first trace in halftime and the second trace in realtime. This knob is separately tunable from <code>[replay_time_scale](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-replay-time-scale)</code> which scales the trace during runtime and does not change the output of the merge unlike this option.</p></li><li><p><code>merge_blktrace_iters``=float_list</code></p><p>This is a whole number option that is index paired with the list of files passed to <code>[read_iolog](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-read-iolog)</code>. When merging is performed, run each trace for the specified number of iterations. For example, <code>--merge_blktrace_iters="2:1"</code> runs the first trace for two iterations and the second trace for one iteration.</p></li><li><p><code>replay_no_stall``=bool</code></p><p>When replaying I/O with <code>[read_iolog](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-read-iolog)</code> the default behavior is to attempt to respect the timestamps within the log and replay them with the appropriate delay between IOPS. By setting this variable fio will not respect the timestamps and attempt to replay them as fast as possible while still respecting ordering. The result is the same I/O pattern to a given device, but different timings.</p></li><li><p><code>replay_time_scale``=int</code></p><p>When replaying I/O with <code>[read_iolog](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-read-iolog)</code>, fio will honor the original timing in the trace. With this option, itâ€™s possible to scale the time. Itâ€™s a percentage option, if set to 50 it means run at 50% the original IO rate in the trace. If set to 200, run at twice the original IO rate. Defaults to 100.</p></li><li><p><code>replay_redirect``=str</code></p><p>While replaying I/O patterns using <code>[read_iolog](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-read-iolog)</code> the default behavior is to replay the IOPS onto the major/minor device that each IOP was recorded from. This is sometimes undesirable because on a different machine those major/minor numbers can map to a different device. Changing hardware on the same system can also result in a different major/minor mapping. <code>replay_redirect</code> causes all I/Os to be replayed onto the single specified device regardless of the device it was recorded from. i.e.Â <code>[replay_redirect](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-replay-redirect)</code>= <code>/dev/sdc</code> would cause all I/O in the blktrace or iolog to be replayed onto <code>/dev/sdc</code>. This means multiple devices will be replayed onto a single device, if the trace contains multiple devices. If you want multiple devices to be replayed concurrently to multiple redirected devices you must blkparse your trace into separate traces and replay them with independent fio invocations. Unfortunately this also breaks the strict time ordering between multiple device accesses.</p></li><li><p><code>replay_align``=int</code></p><p>Force alignment of the byte offsets in a trace to this value. The value must be a power of 2.</p></li><li><p><code>replay_scale``=int</code></p><p>Scale byte offsets down by this factor when replaying traces. Should most likely use <code>[replay_align](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-replay-align)</code> as well.</p></li><li><p><code>replay_skip``=str</code></p><p>Sometimes itâ€™s useful to skip certain IO types in a replay trace. This could be, for instance, eliminating the writes in the trace. Or not replaying the trims/discards, if you are redirecting to a device that doesnâ€™t support them. This option takes a comma separated list of read, write, trim, sync.</p></li></ul><h3 id=11216-threads-processes-and-job-synchronization>1.12.16. Threads, processes and job synchronization</h3><ul><li><p>`thread```</p><p>Fio defaults to creating jobs by using fork, however if this option is given, fio will create jobs by using POSIX Threadsâ€™ function <em>pthread_create(3)</em> to create threads instead.</p></li><li><p><code>wait_for``=str</code></p><p>If set, the current job wonâ€™t be started until all workers of the specified waitee job are done.<code>wait_for</code> operates on the job name basis, so there are a few limitations. First, the waitee must be defined prior to the waiter job (meaning no forward references). Second, if a job is being referenced as a waitee, it must have a unique name (no duplicate waitees).</p></li><li><p><code>nice``=int</code></p><p>Run the job with the given nice value. See man <em>nice(2)</em>.On Windows, values less than -15 set the process class to â€œHighâ€; -1 through -15 set â€œAbove Normalâ€; 1 through 15 â€œBelow Normalâ€; and above 15 â€œIdleâ€ priority class.</p></li><li><p><code>prio``=int</code></p><p>Set the I/O priority value of this job. Linux limits us to a positive value between 0 and 7, with 0 being the highest. See man <em>ionice(1)</em>. Refer to an appropriate manpage for other operating systems since meaning of priority may differ. For per-command priority setting, see I/O engine specific cmdprio_percentage and hipri_percentage options.</p></li><li><p><code>prioclass``=int</code></p><p>Set the I/O priority class. See man <em>ionice(1)</em>. For per-command priority setting, see I/O engine specific cmdprio_percentage and hipri_percentage options.</p></li><li><p>â¤<code>cpus_allowed``=str</code></p><p>Controls the same options as <code>[cpumask](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-cpumask)</code>, but accepts a textual specification of the permitted CPUs instead and CPUs are indexed from 0. So to use CPUs 0 and 5 you would specify <code>cpus_allowed=0,5</code>. This option also allows a range of CPUs to be specified â€“ say you wanted a binding to CPUs 0, 5, and 8 to 15, you would set <code>cpus_allowed=0,5,8-15</code>.On Windows, when <code>cpus_allowed</code> is unset only CPUs from fioâ€™s current processor group will be used and affinity settings are inherited from the system. An fio build configured to target Windows 7 makes options that set CPUs processor group aware and values will set both the processor group and a CPU from within that group. For example, on a system where processor group 0 has 40 CPUs and processor group 1 has 32 CPUs, <code>cpus_allowed</code> values between 0 and 39 will bind CPUs from processor group 0 and <code>cpus_allowed</code> values between 40 and 71 will bind CPUs from processor group 1. When using <code>cpus_allowed_policy=shared</code> all CPUs specified by a single <code>cpus_allowed</code> option must be from the same processor group. For Windows fio builds not built for Windows 7, CPUs will only be selected from (and be relative to) whatever processor group fio happens to be running in and CPUs from other processor groups cannot be used.</p></li><li><p><code>cpus_allowed_policy``=str</code></p><p>Set the policy of how fio distributes the CPUs specified by <code>[cpus_allowed](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-cpus-allowed)</code> or <code>[cpumask](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-cpumask)</code>. Two policies are supported:<strong>shared</strong>All jobs will share the CPU set specified.<strong>split</strong>Each job will get a unique CPU from the CPU set.<strong>shared</strong> is the default behavior, if the option isnâ€™t specified. If <strong>split</strong> is specified, then fio will assign one cpu per job. If not enough CPUs are given for the jobs listed, then fio will roundrobin the CPUs in the set.</p></li><li><p><code>cpumask``=int</code></p><p>Set the CPU affinity of this job. The parameter given is a bit mask of allowed CPUs the job may run on. So if you want the allowed CPUs to be 1 and 5, you would pass the decimal value of (1 &#171; 1 | 1 &#171; 5), or 34. See man <em>sched_setaffinity(2)</em>. This may not work on all supported operating systems or kernel versions. This option doesnâ€™t work well for a higher CPU count than what you can store in an integer mask, so it can only control cpus 1-32. For boxes with larger CPU counts, use <code>[cpus_allowed](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-cpus-allowed)</code>.</p></li><li><p><code>numa_cpu_nodes``=str</code></p><p>Set this job running on specified NUMA nodesâ€™ CPUs. The arguments allow comma delimited list of cpu numbers, A-B ranges, or all. Note, to enable NUMA options support, fio must be built on a system with libnuma-dev(el) installed.</p></li><li><p><code>numa_mem_policy``=str</code></p><p>Set this jobâ€™s memory policy and corresponding NUMA nodes. Format of the arguments:<code>&lt;mode>[:&lt;nodelist>] ``mode</code> is one of the following memory policies: <code>default</code>, <code>prefer</code>, <code>bind</code>, <code>interleave</code> or <code>local</code>. For <code>default</code> and <code>local</code> memory policies, no node needs to be specified. For <code>prefer</code>, only one node is allowed. For <code>bind</code> and <code>interleave</code> the <code>nodelist</code> may be as follows: a comma delimited list of numbers, A-B ranges, or all.</p></li><li><p><code>cgroup``=str</code></p><p>Add job to this control group. If it doesnâ€™t exist, it will be created. The system must have a mounted cgroup blkio mount point for this to work. If your system doesnâ€™t have it mounted, you can do so with:<code># mount -t cgroup -o blkio none /cgroup</code></p></li><li><p><code>cgroup_weight``=int</code></p><p>Set the weight of the cgroup to this value. See the documentation that comes with the kernel, allowed values are in the range of 100..1000.</p></li><li><p><code>cgroup_nodelete``=bool</code></p><p>Normally fio will delete the cgroups it has created after the job completion. To override this behavior and to leave cgroups around after the job completion, set <code>cgroup_nodelete=1</code>. This can be useful if one wants to inspect various cgroup files after job completion. Default: false.</p></li><li><p><code>flow_id``=int</code></p><p>The ID of the flow. If not specified, it defaults to being a global flow. See <code>[flow](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-flow)</code>.</p></li><li><p><code>flow``=int</code></p><p>Weight in token-based flow control. If this value is used, then there is a â€˜flow counterâ€™ which is used to regulate the proportion of activity between two or more jobs. Fio attempts to keep this flow counter near zero. The <code>flow</code> parameter stands for how much should be added or subtracted to the flow counter on each iteration of the main I/O loop. That is, if one job has <code>flow=8</code> and another job has <code>flow=-1</code>, then there will be a roughly 1:8 ratio in how much one runs vs the other.</p></li><li><p><code>flow_sleep``=int</code></p><p>The period of time, in microseconds, to wait after the flow counter has exceeded its proportion before retrying operations.</p></li><li><p><code>stonewall``, ``wait_for_previous</code></p><p>Wait for preceding jobs in the job file to exit, before starting this one. Can be used to insert serialization points in the job file. A stone wall also implies starting a new reporting group, see <code>[group_reporting](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-group-reporting)</code>.</p></li><li><p>`exitall```</p><p>By default, fio will continue running all other jobs when one job finishes. Sometimes this is not the desired action. Setting <code>exitall</code> will instead make fio terminate all jobs in the same group, as soon as one job of that group finishes.</p></li><li><p>`exit_what```</p><p>By default, fio will continue running all other jobs when one job finishes. Sometimes this is not the desired action. Setting <code>exit_all</code> will instead make fio terminate all jobs in the same group. The option <code>exit_what</code> allows to control which jobs get terminated when <code>exitall</code> is enabled. The default is <code>group</code> and does not change the behaviour of <code>exitall</code>. The setting <code>all</code> terminates all jobs. The setting <code>stonewall</code> terminates all currently running jobs across all groups and continues execution with the next stonewalled group.</p></li><li><p><code>exec_prerun``=str</code></p><p>Before running this job, issue the command specified through <em>system(3)</em>. Output is redirected in a file called <code>jobname.prerun.txt</code>.</p></li><li><p><code>exec_postrun``=str</code></p><p>After the job completes, issue the command specified though <em>system(3)</em>. Output is redirected in a file called <code>jobname.postrun.txt</code>.</p></li><li><p><code>uid``=int</code></p><p>Instead of running as the invoking user, set the user ID to this value before the thread/process does any work.</p></li><li><p><code>gid``=int</code></p><p>Set group ID, see <code>[uid](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-uid)</code>.</p></li></ul><h3 id=11217-verification>1.12.17. Verification</h3><ul><li><p><code>verify_only</code></p><p>Do not perform specified workload, only verify data still matches previous invocation of this workload. This option allows one to check data multiple times at a later date without overwriting it. This option makes sense only for workloads that write data, and does not support workloads with the <code>[time_based](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-time-based)</code> option set.</p></li><li><p><code>do_verify=bool</code></p><p>Run the verify phase after a write phase. Only valid if <code>[verify](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-verify)</code> is set. Default: true.</p></li><li><p>â¤<code>verify=str</code></p><p>If writing to a file, fio can verify the file contents after each iteration of the job. Each verification method also implies verification of special header, which is written to the beginning of each block. This header also includes meta information, like offset of the block, block number, timestamp when block was written, etc. <code>[verify](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-verify)</code> can be combined with <code>[verify_pattern](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-verify-pattern)</code> option. The allowed values are:<strong>md5</strong>Use an md5 sum of the data area and store it in the header of each block.<strong>crc64</strong>Use an experimental crc64 sum of the data area and store it in the header of each block.<strong>crc32c</strong>Use a crc32c sum of the data area and store it in the header of each block. This will automatically use hardware acceleration (e.g.Â SSE4.2 on an x86 or CRC crypto extensions on ARM64) but will fall back to software crc32c if none is found. Generally the fastest checksum fio supports when hardware accelerated.<strong>crc32c-intel</strong>Synonym for crc32c.<strong>crc32</strong>Use a crc32 sum of the data area and store it in the header of each block.<strong>crc16</strong>Use a crc16 sum of the data area and store it in the header of each block.<strong>crc7</strong>Use a crc7 sum of the data area and store it in the header of each block.<strong>xxhash</strong>Use xxhash as the checksum function. Generally the fastest software checksum that fio supports.<strong>sha512</strong>Use sha512 as the checksum function.<strong>sha256</strong>Use sha256 as the checksum function.<strong>sha1</strong>Use optimized sha1 as the checksum function.<strong>sha3-224</strong>Use optimized sha3-224 as the checksum function.<strong>sha3-256</strong>Use optimized sha3-256 as the checksum function.<strong>sha3-384</strong>Use optimized sha3-384 as the checksum function.<strong>sha3-512</strong>Use optimized sha3-512 as the checksum function.<strong>meta</strong>This option is deprecated, since now meta information is included in generic verification header and meta verification happens by default. For detailed information see the description of the <code>[verify](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-verify)</code> setting. This option is kept because of compatibilityâ€™s sake with old configurations. Do not use it.<strong>pattern</strong>Verify a strict pattern. Normally fio includes a header with some basic information and checksumming, but if this option is set, only the specific pattern set with <code>[verify_pattern](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-verify-pattern)</code> is verified.<strong>null</strong>Only pretend to verify. Useful for testing internals with <code>[ioengine](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-ioengine)</code>=null, not for much else.This option can be used for repeated burn-in tests of a system to make sure that the written data is also correctly read back. If the data direction given is a read or random read, fio will assume that it should verify a previously written file. If the data direction includes any form of write, the verify will be of the newly written data.To avoid false verification errors, do not use the norandommap option when verifying data with async I/O engines and I/O depths > 1. Or use the norandommap and the lfsr random generator together to avoid writing to the same offset with muliple outstanding I/Os.</p></li><li><p><code>verify_offset=int</code></p><p>Swap the verification header with data somewhere else in the block before writing. It is swapped back before verifying.</p></li><li><p><code>verify_interval=int</code></p><p>Write the verification header at a finer granularity than the <code>[blocksize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize)</code>. It will be written for chunks the size of <code>verify_interval</code>. <code>[blocksize](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-blocksize)</code> should divide this evenly.</p></li><li><p><code>verify_pattern=str</code></p><p>If set, fio will fill the I/O buffers with this pattern. Fio defaults to filling with totally random bytes, but sometimes itâ€™s interesting to fill with a known pattern for I/O verification purposes. Depending on the width of the pattern, fio will fill 1/2/3/4 bytes of the buffer at the time (it can be either a decimal or a hex number). The <code>verify_pattern</code> if larger than a 32-bit quantity has to be a hex number that starts with either â€œ0xâ€ or â€œ0Xâ€. Use with <code>[verify](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-verify)</code>. Also, <code>verify_pattern</code> supports <code>%o</code> format, which means that for each block offset will be written and then verified back, e.g.:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>verify_pattern</span><span class=o>=</span>%o
</span></span></code></pre></td></tr></table></div></div><p>Or use combination of everything:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>verify_pattern</span><span class=o>=</span>0xff%o<span class=s2>&#34;abcd&#34;</span>-12
</span></span></code></pre></td></tr></table></div></div></li><li><p><code>verify_fatal=bool</code></p><p>Normally fio will keep checking the entire contents before quitting on a block verification failure. If this option is set, fio will exit the job on the first observed failure. Default: false.</p></li><li><p><code>verify_dump=bool</code></p><p>If set, dump the contents of both the original data block and the data block we read off disk to files. This allows later analysis to inspect just what kind of data corruption occurred. Off by default.</p></li><li><p><code>verify_async=int</code></p><p>Fio will normally verify I/O inline from the submitting thread. This option takes an integer describing how many async offload threads to create for I/O verification instead, causing fio to offload the duty of verifying I/O contents to one or more separate threads. If using this offload option, even sync I/O engines can benefit from using an <code>[iodepth](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-iodepth)</code> setting higher than 1, as it allows them to have I/O in flight while verifies are running. Defaults to 0 async threads, i.e.Â verification is not asynchronous.</p></li><li><p><code>verify_async_cpus=str</code></p><p>Tell fio to set the given <code>CPU affinity</code> on the async I/O verification threads. See <code>[cpus_allowed](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-cpus-allowed)</code> for the format used.</p></li><li><p><code>verify_backlog=int</code></p><p>Fio will normally verify the written contents of a job that utilizes verify once that job has completed. In other words, everything is written then everything is read back and verified. You may want to verify continually instead for a variety of reasons. Fio stores the meta data associated with an I/O block in memory, so for large verify workloads, quite a bit of memory would be used up holding this meta data. If this option is enabled, fio will write only N blocks before verifying these blocks.</p></li><li><p><code>verify_backlog_batch=int</code></p><p>Control how many blocks fio will verify if <code>[verify_backlog](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-verify-backlog)</code> is set. If not set, will default to the value of <code>[verify_backlog](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-verify-backlog)</code> (meaning the entire queue is read back and verified). If <code>verify_backlog_batch</code> is less than <code>[verify_backlog](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-verify-backlog)</code> then not all blocks will be verified, if <code>verify_backlog_batch</code> is larger than <code>[verify_backlog](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-verify-backlog)</code>, some blocks will be verified more than once.</p></li><li><p><code>verify_state_save=bool</code></p><p>When a job exits during the write phase of a verify workload, save its current state. This allows fio to replay up until that point, if the verify state is loaded for the verify read phase. The format of the filename is, roughly:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&lt;type&gt;-&lt;jobname&gt;-&lt;jobindex&gt;-verify.state.
</span></span></code></pre></td></tr></table></div></div><p>is â€œlocalâ€ for a local run, â€œsockâ€ for a client/server socket connection, and â€œipâ€ (192.168.0.1, for instance) for a networked client/server connection. Defaults to true.</p></li><li><p><code>verify_state_load=bool</code></p><p>If a verify termination trigger was used, fio stores the current write state of each thread. This can be used at verification time so that fio knows how far it should verify. Without this information, fio will run a full verification pass, according to the settings in the job file used. Default false.</p></li><li><p><code>trim_percentage=int</code></p><p>Number of verify blocks to discard/trim.</p></li><li><p><code>trim_verify_zero=bool</code></p><p>Verify that trim/discarded blocks are returned as zeros.</p></li><li><p><code>trim_backlog=int</code></p><p>Trim after this number of blocks are written.</p></li><li><p><code>trim_backlog_batch=int</code></p><p>Trim this number of I/O blocks.</p></li><li><p><code>experimental_verify=bool</code></p><p>Enable experimental verification.</p></li></ul><h3 id=11218-steady-state>1.12.18. Steady state</h3><ul><li><p><code>steadystate``=str:float``, ``ss``=str:float</code></p><p>Define the criterion and limit for assessing steady state performance. The first parameter designates the criterion whereas the second parameter sets the threshold. When the criterion falls below the threshold for the specified duration, the job will stop. For example, iops_slope:0.1% will direct fio to terminate the job when the least squares regression slope falls below 0.1% of the mean IOPS. If <code>[group_reporting](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-group-reporting)</code> is enabled this will apply to all jobs in the group. Below is the list of available steady state assessment criteria. All assessments are carried out using only data from the rolling collection window. Threshold limits can be expressed as a fixed value or as a percentage of the mean in the collection window.When using this feature, most jobs should include the <code>[time_based](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-time-based)</code> and <code>[runtime](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-runtime)</code> options or the <code>[loops](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-loops)</code> option so that fio does not stop running after it has covered the full size of the specified file(s) or device(s).<strong>iops</strong>Collect IOPS data. Stop the job if all individual IOPS measurements are within the specified limit of the mean IOPS (e.g., <code>iops:2</code> means that all individual IOPS values must be within 2 of the mean, whereas <code>iops:0.2%</code> means that all individual IOPS values must be within 0.2% of the mean IOPS to terminate the job).<strong>iops_slope</strong>Collect IOPS data and calculate the least squares regression slope. Stop the job if the slope falls below the specified limit.<strong>bw</strong>Collect bandwidth data. Stop the job if all individual bandwidth measurements are within the specified limit of the mean bandwidth.<strong>bw_slope</strong>Collect bandwidth data and calculate the least squares regression slope. Stop the job if the slope falls below the specified limit.</p></li><li><p><code>steadystate_duration``=time``, ``ss_dur``=time</code></p><p>A rolling window of this duration will be used to judge whether steady state has been reached. Data will be collected once per second. The default is 0 which disables steady state detection. When the unit is omitted, the value is interpreted in seconds.</p></li><li><p><code>steadystate_ramp_time``=time``, ``ss_ramp``=time</code></p><p>Allow the job to run for the specified duration before beginning data collection for checking the steady state job termination criterion. The default is 0. When the unit is omitted, the value is interpreted in seconds.</p></li></ul><h3 id=11219-measurements-and-reporting>1.12.19. Measurements and reporting</h3><ul><li><p><code>per_job_logs``=bool</code></p><p>If set, this generates bw/clat/iops log with per file private filenames. If not set, jobs with identical names will share the log filename. Default: true.</p></li><li><p>`group_reporting```</p><p>It may sometimes be interesting to display statistics for groups of jobs as a whole instead of for each individual job. This is especially true if <code>[numjobs](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-numjobs)</code> is used; looking at individual thread/process output quickly becomes unwieldy. To see the final report per-group instead of per-job, use <code>[group_reporting](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-group-reporting)</code>. Jobs in a file will be part of the same reporting group, unless if separated by a <code>[stonewall](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-stonewall)</code>, or by using <code>[new_group](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-new-group)</code>.</p></li><li><p>`new_group```</p><p>Start a new reporting group. See: <code>[group_reporting](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-group-reporting)</code>. If not given, all jobs in a file will be part of the same reporting group, unless separated by a <code>[stonewall](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-stonewall)</code>.</p></li><li><p><code>stats``=bool</code></p><p>By default, fio collects and shows final output results for all jobs that run. If this option is set to 0, then fio will ignore it in the final stat output.</p></li><li><p><code>write_bw_log``=str</code></p><p>If given, write a bandwidth log for this job. Can be used to store data of the bandwidth of the jobs in their lifetime.If no str argument is given, the default filename of <code>jobname_type.x.log</code> is used. Even when the argument is given, fio will still append the type of log. So if one specifies:<code>write_bw_log=foo</code>The actual log name will be <code>foo_bw.x.log</code> where x is the index of the job (1..N, where N is the number of jobs). If <code>[per_job_logs](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-per-job-logs)</code> is false, then the filename will not include the .x job index.The included <strong>fio_generate_plots</strong> script uses <strong>gnuplot</strong> to turn these text files into nice graphs. See
<a href=https://fio.readthedocs.io/en/latest/fio_doc.html#log-file-formats rel=noopener>Log File Formats</a> for how data is structured within the file.</p></li><li><p><code>write_lat_log``=str</code></p><p>Same as <code>[write_bw_log](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-write-bw-log)</code>, except this option creates I/O submission (e.g., <code>name_slat.x.log</code>), completion (e.g., <code>name_clat.x.log</code>), and total (e.g., <code>name_lat.x.log</code>) latency files instead. See <code>[write_bw_log](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-write-bw-log)</code> for details about the filename format and
<a href=https://fio.readthedocs.io/en/latest/fio_doc.html#log-file-formats rel=noopener>Log File Formats</a> for how data is structured within the files.</p></li><li><p><code>write_hist_log``=str</code></p><p>Same as <code>[write_bw_log](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-write-bw-log)</code> but writes an I/O completion latency histogram file (e.g., <code>name_hist.x.log</code>) instead. Note that this file will be empty unless <code>[log_hist_msec](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-log-hist-msec)</code> has also been set. See <code>[write_bw_log](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-write-bw-log)</code> for details about the filename format and
<a href=https://fio.readthedocs.io/en/latest/fio_doc.html#log-file-formats rel=noopener>Log File Formats</a> for how data is structured within the file.</p></li><li><p><code>write_iops_log``=str</code></p><p>Same as <code>[write_bw_log](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-write-bw-log)</code>, but writes an IOPS file (e.g.Â <code>name_iops.x.log</code>) instead. Because fio defaults to individual I/O logging, the value entry in the IOPS log will be 1 unless windowed logging (see <code>[log_avg_msec](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-log-avg-msec)</code>) has been enabled. See <code>[write_bw_log](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-write-bw-log)</code> for details about the filename format and
<a href=https://fio.readthedocs.io/en/latest/fio_doc.html#log-file-formats rel=noopener>Log File Formats</a> for how data is structured within the file.</p></li><li><p><code>log_avg_msec``=int</code></p><p>By default, fio will log an entry in the iops, latency, or bw log for every I/O that completes. When writing to the disk log, that can quickly grow to a very large size. Setting this option makes fio average the each log entry over the specified period of time, reducing the resolution of the log. See <code>[log_max_value](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-log-max-value)</code> as well. Defaults to 0, logging all entries. Also see
<a href=https://fio.readthedocs.io/en/latest/fio_doc.html#log-file-formats rel=noopener>Log File Formats</a>.</p></li><li><p><code>log_hist_msec``=int</code></p><p>Same as <code>[log_avg_msec](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-log-avg-msec)</code>, but logs entries for completion latency histograms. Computing latency percentiles from averages of intervals using <code>[log_avg_msec](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-log-avg-msec)</code> is inaccurate. Setting this option makes fio log histogram entries over the specified period of time, reducing log sizes for high IOPS devices while retaining percentile accuracy. See <code>[log_hist_coarseness](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-log-hist-coarseness)</code> and <code>[write_hist_log](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-write-hist-log)</code> as well. Defaults to 0, meaning histogram logging is disabled.</p></li><li><p><code>log_hist_coarseness``=int</code></p><p>Integer ranging from 0 to 6, defining the coarseness of the resolution of the histogram logs enabled with <code>[log_hist_msec](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-log-hist-msec)</code>. For each increment in coarseness, fio outputs half as many bins. Defaults to 0, for which histogram logs contain 1216 latency bins. See <code>[write_hist_log](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-write-hist-log)</code> and
<a href=https://fio.readthedocs.io/en/latest/fio_doc.html#log-file-formats rel=noopener>Log File Formats</a>.</p></li><li><p><code>log_max_value``=bool</code></p><p>If <code>[log_avg_msec](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-log-avg-msec)</code> is set, fio logs the average over that window. If you instead want to log the maximum value, set this option to 1. Defaults to 0, meaning that averaged values are logged.</p></li><li><p><code>log_offset``=bool</code></p><p>If this is set, the iolog options will include the byte offset for the I/O entry as well as the other data values. Defaults to 0 meaning that offsets are not present in logs. Also see
<a href=https://fio.readthedocs.io/en/latest/fio_doc.html#log-file-formats rel=noopener>Log File Formats</a>.</p></li><li><p><code>log_compression``=int</code></p><p>If this is set, fio will compress the I/O logs as it goes, to keep the memory footprint lower. When a log reaches the specified size, that chunk is removed and compressed in the background. Given that I/O logs are fairly highly compressible, this yields a nice memory savings for longer runs. The downside is that the compression will consume some background CPU cycles, so it may impact the run. This, however, is also true if the logging ends up consuming most of the system memory. So pick your poison. The I/O logs are saved normally at the end of a run, by decompressing the chunks and storing them in the specified log file. This feature depends on the availability of zlib.</p></li><li><p><code>log_compression_cpus``=str</code></p><p>Define the set of CPUs that are allowed to handle online log compression for the I/O jobs. This can provide better isolation between performance sensitive jobs, and background compression work. See <code>[cpus_allowed](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-cpus-allowed)</code> for the format used.</p></li><li><p><code>log_store_compressed``=bool</code></p><p>If set, fio will store the log files in a compressed format. They can be decompressed with fio, using the <code>[--inflate-log](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-inflate-log)</code> command line parameter. The files will be stored with a <code>.fz</code> suffix.</p></li><li><p><code>log_unix_epoch``=bool</code></p><p>If set, fio will log Unix timestamps to the log files produced by enabling write_type_log for each log type, instead of the default zero-based timestamps.</p></li><li><p><code>block_error_percentiles``=bool</code></p><p>If set, record errors in trim block-sized units from writes and trims and output a histogram of how many trims it took to get to errors, and what kind of error was encountered.</p></li><li><p><code>bwavgtime``=int</code></p><p>Average the calculated bandwidth over the given time. Value is specified in milliseconds. If the job also does bandwidth logging through <code>[write_bw_log](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-write-bw-log)</code>, then the minimum of this option and <code>[log_avg_msec](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-log-avg-msec)</code> will be used. Default: 500ms.</p></li><li><p><code>iopsavgtime``=int</code></p><p>Average the calculated IOPS over the given time. Value is specified in milliseconds. If the job also does IOPS logging through <code>[write_iops_log](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-write-iops-log)</code>, then the minimum of this option and <code>[log_avg_msec](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-log-avg-msec)</code> will be used. Default: 500ms.</p></li><li><p><code>disk_util``=bool</code></p><p>Generate disk utilization statistics, if the platform supports it. Default: true.</p></li><li><p><code>disable_lat``=bool</code></p><p>Disable measurements of total latency numbers. Useful only for cutting back the number of calls to <em>gettimeofday(2)</em>, as that does impact performance at really high IOPS rates. Note that to really get rid of a large amount of these calls, this option must be used with <code>[disable_slat](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-disable-slat)</code> and <code>[disable_bw_measurement](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-disable-bw-measurement)</code> as well.</p></li><li><p><code>disable_clat``=bool</code></p><p>Disable measurements of completion latency numbers. See <code>[disable_lat](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-disable-lat)</code>.</p></li><li><p><code>disable_slat``=bool</code></p><p>Disable measurements of submission latency numbers. See <code>[disable_lat](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-disable-lat)</code>.</p></li><li><p><code>disable_bw_measurement``=bool``, ``disable_bw``=bool</code></p><p>Disable measurements of throughput/bandwidth numbers. See <code>[disable_lat](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-disable-lat)</code>.</p></li><li><p><code>slat_percentiles``=bool</code></p><p>Report submission latency percentiles. Submission latency is not recorded for synchronous ioengines.</p></li><li><p><code>clat_percentiles``=bool</code></p><p>Report completion latency percentiles.</p></li><li><p><code>lat_percentiles``=bool</code></p><p>Report total latency percentiles. Total latency is the sum of submission latency and completion latency.</p></li><li><p><code>percentile_list``=float_list</code></p><p>Overwrite the default list of percentiles for latencies and the block error histogram. Each number is a floating point number in the range (0,100], and the maximum length of the list is 20. Use <code>:</code> to separate the numbers. For example, <code>--percentile_list=99.5:99.9</code> will cause fio to report the latency durations below which 99.5% and 99.9% of the observed latencies fell, respectively.</p></li><li><p><code>significant_figures``=int</code></p><p>If using <code>[--output-format](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-output-format)</code> of normal, set the significant figures to this value. Higher values will yield more precise IOPS and throughput units, while lower values will round. Requires a minimum value of 1 and a maximum value of 10. Defaults to 4.</p></li></ul><h3 id=11220-error-handling>1.12.20. Error handling</h3><ul><li><p>`exitall_on_error```</p><p>When one job finishes in error, terminate the rest. The default is to wait for each job to finish.</p></li><li><p><code>continue_on_error``=str</code></p><p>Normally fio will exit the job on the first observed failure. If this option is set, fio will continue the job when there is a â€˜non-fatal errorâ€™ (EIO or EILSEQ) until the runtime is exceeded or the I/O size specified is completed. If this option is used, there are two more stats that are appended, the total error count and the first error. The error field given in the stats is the first error that was hit during the run.The allowed values are:<strong>none</strong>Exit on any I/O or verify errors.<strong>read</strong>Continue on read errors, exit on all others.<strong>write</strong>Continue on write errors, exit on all others.<strong>io</strong>Continue on any I/O error, exit on all others.<strong>verify</strong>Continue on verify errors, exit on all others.<strong>all</strong>Continue on all errors.<strong>0</strong>Backward-compatible alias for â€˜noneâ€™.<strong>1</strong>Backward-compatible alias for â€˜allâ€™.</p></li><li><p><code>ignore_error``=str</code></p><p>Sometimes you want to ignore some errors during test in that case you can specify error list for each error type, instead of only being able to ignore the default â€˜non-fatal errorâ€™ using <code>[continue_on_error](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-continue-on-error)</code>. <code>ignore_error=READ_ERR_LIST,WRITE_ERR_LIST,VERIFY_ERR_LIST</code> errors for given error type is separated with â€˜:â€™. Error may be symbol (â€˜ENOSPCâ€™, â€˜ENOMEMâ€™) or integer. Example:<code>ignore_error=EAGAIN,ENOSPC:122</code>This option will ignore EAGAIN from READ, and ENOSPC and 122(EDQUOT) from WRITE. This option works by overriding <code>[continue_on_error](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-continue-on-error)</code> with the list of errors for each error type if any.</p></li><li><p><code>error_dump``=bool</code></p><p>If set dump every error even if it is non fatal, true by default. If disabled only fatal error will be dumped.</p></li></ul><h2 id=113-running-predefined-workloads>1.13. Running predefined workloads</h2><p>Fio includes predefined profiles that mimic the I/O workloads generated by other tools.</p><ul><li><p><code>profile``=str</code></p><p>The predefined workload to run. Current profiles are:<strong>tiobench</strong>Threaded I/O bench (tiotest/tiobench) like workload.<strong>act</strong>Aerospike Certification Tool (ACT) like workload.</p></li></ul><p>To view a profileâ€™s additional options use <code>[--cmdhelp](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-cmdhelp)</code> after specifying the profile. For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ fio --profile=act --cmdhelp
</span></span></code></pre></td></tr></table></div></div><h3 id=1131-act-profile-options>1.13.1. Act profile options</h3><ul><li><p><code>device-names``=str</code></p><p>Devices to use.</p></li><li><p><code>load``=int</code></p><p>ACT load multiplier. Default: 1.</p></li><li><p><code>test-duration``=time</code></p><p>How long the entire test takes to run. When the unit is omitted, the value is given in seconds. Default: 24h.</p></li><li><p><code>threads-per-queue``=int</code></p><p>Number of read I/O threads per device. Default: 8.</p></li><li><p><code>read-req-num-512-blocks``=int</code></p><p>Number of 512B blocks to read at the time. Default: 3.</p></li><li><p><code>large-block-op-kbytes``=int</code></p><p>Size of large block ops in KiB (writes). Default: 131072.</p></li><li><p>`prep```</p><p>Set to run ACT prep phase.</p></li></ul><h3 id=1132-tiobench-profile-options>1.13.2. Tiobench profile options</h3><ul><li><p><code>size``=str</code></p><p>Size in MiB.</p></li><li><p><code>block``=int</code></p><p>Block size in bytes. Default: 4096.</p></li><li><p><code>numruns``=int</code></p><p>Number of runs.</p></li><li><p><code>dir``=str</code></p><p>Test directory.</p></li><li><p><code>threads``=int</code></p><p>Number of threads.</p></li></ul><h2 id=114-interpreting-the-output>1.14. Interpreting the output</h2><p>Fio spits out a lot of output. While running, fio will display the status of the jobs created. An example of that would be:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Jobs: 1 (f=1): [_(1),M(1)][24.8%][r=20.5MiB/s,w=23.5MiB/s][r=82,w=94 IOPS][eta 01m:31s]
</span></span></code></pre></td></tr></table></div></div><p>The characters inside the first set of square brackets denote the current status of each thread. The first character is the first job defined in the job file, and so forth. The possible values (in typical life cycle order) are:</p><p><a rel=noopener class="internal-link broken" data-src=1%20fio%20-%20Flexible%20IO%20tester%20rev%203%2025%200f270069ce274f55b1a66853bd856c77/Untitled%20Database%20b0b64ab37bef4d569c8a0f0ca6041149.csv>Untitled</a></p><p>Fio will condense the thread string as not to take up more space on the command line than needed. For instance, if you have 10 readers and 10 writers running, the output would look like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Jobs: 20 (f=20): [R(10),W(10)][4.0%][r=20.5MiB/s,w=23.5MiB/s][r=82,w=94 IOPS][eta 57m:36s]
</span></span></code></pre></td></tr></table></div></div><p>Note that the status string is displayed in order, so itâ€™s possible to tell which of the jobs are currently doing what. In the example above this means that jobs 1â€“10 are readers and 11â€“20 are writers.</p><p>The other values are fairly self explanatory â€“ number of threads currently running and doing I/O, the number of currently open files (f=), the estimated completion percentage, the rate of I/O since last check (read speed listed first, then write speed and optionally trim speed) in terms of bandwidth and IOPS, and time to completion for the current running group. Itâ€™s impossible to estimate runtime of the following groups (if any).</p><p>When fio is done (or interrupted by Ctrl-C), it will show the data for each thread, group of threads, and disks in that order. For each overall thread (or group) the output looks like:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Client1: (groupid=0, jobs=1): err= 0: pid=16109: Sat Jun 24 12:07:54 2017
</span></span><span class=line><span class=cl>  write: IOPS=88, BW=623KiB/s (638kB/s)(30.4MiB/50032msec)
</span></span><span class=line><span class=cl>    slat (nsec): min=500, max=145500, avg=8318.00, stdev=4781.50
</span></span><span class=line><span class=cl>    clat (usec): min=170, max=78367, avg=4019.02, stdev=8293.31
</span></span><span class=line><span class=cl>     lat (usec): min=174, max=78375, avg=4027.34, stdev=8291.79
</span></span><span class=line><span class=cl>    clat percentiles (usec):
</span></span><span class=line><span class=cl>     |  1.00th=[  302],  5.00th=[  326], 10.00th=[  343], 20.00th=[  363],
</span></span><span class=line><span class=cl>     | 30.00th=[  392], 40.00th=[  404], 50.00th=[  416], 60.00th=[  445],
</span></span><span class=line><span class=cl>     | 70.00th=[  816], 80.00th=[ 6718], 90.00th=[12911], 95.00th=[21627],
</span></span><span class=line><span class=cl>     | 99.00th=[43779], 99.50th=[51643], 99.90th=[68682], 99.95th=[72877],
</span></span><span class=line><span class=cl>     | 99.99th=[78119]
</span></span><span class=line><span class=cl>   bw (  KiB/s): min=  532, max=  686, per=0.10%, avg=622.87, stdev=24.82, samples=  100
</span></span><span class=line><span class=cl>   iops        : min=   76, max=   98, avg=88.98, stdev= 3.54, samples=  100
</span></span><span class=line><span class=cl>  lat (usec)   : 250=0.04%, 500=64.11%, 750=4.81%, 1000=2.79%
</span></span><span class=line><span class=cl>  lat (msec)   : 2=4.16%, 4=1.84%, 10=4.90%, 20=11.33%, 50=5.37%
</span></span><span class=line><span class=cl>  lat (msec)   : 100=0.65%
</span></span><span class=line><span class=cl>  cpu          : usr=0.27%, sys=0.18%, ctx=12072, majf=0, minf=21
</span></span><span class=line><span class=cl>  IO depths    : 1=85.0%, 2=13.1%, 4=1.8%, 8=0.1%, 16=0.0%, 32=0.0%, &gt;=64=0.0%
</span></span><span class=line><span class=cl>     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%
</span></span><span class=line><span class=cl>     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%
</span></span><span class=line><span class=cl>     issued rwt: total=0,4450,0, short=0,0,0, dropped=0,0,0
</span></span><span class=line><span class=cl>     latency   : target=0, window=0, percentile=100.00%, depth=8
</span></span></code></pre></td></tr></table></div></div><p>The job name (or first jobâ€™s name when using <code>[group_reporting](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-group-reporting)</code>) is printed, along with the group id, count of jobs being aggregated, last error id seen (which is 0 when there are no errors), pid/tid of that thread and the time the job/group completed. Below are the I/O statistics for each data direction performed (showing writes in the example above). In the order listed, they denote:</p><ul><li><p><strong>read/write/trim</strong></p><p>The string before the colon shows the I/O direction the statistics are for. <strong>IOPS</strong> is the average I/Os performed per second. <strong>BW</strong> is the average bandwidth rate shown as: value in power of 2 format (value in power of 10 format). The last two values show: (<strong>total I/O performed</strong> in power of 2 format / <strong>runtime</strong> of that thread).</p></li><li><p><strong>slat</strong></p><p><code>Submission latency</code> (<strong>min</strong> being the minimum, <strong>max</strong> being the maximum, <strong>avg</strong> being the average, <strong>stdev</strong> being the standard deviation). This is the time it took to submit the I/O. For sync I/O this row is not displayed as the slat is really the completion latency (since queue/complete is one operation there). This value can be in nanoseconds, microseconds or milliseconds â€” fio will choose the most appropriate base and print that (in the example above nanoseconds was the best scale). Note: in <code>[--minimal](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-minimal)</code> mode latencies are always expressed in microseconds.</p></li><li><p><strong>clat</strong></p><p><code>Completion latency</code>. Same names as slat, this denotes the time from submission to completion of the I/O pieces. For sync I/O, clat will usually be equal (or very close) to 0, as the time from submit to complete is basically just CPU time (I/O has already been done, see slat explanation).</p></li><li><p><strong>lat</strong></p><p><code>Total latency</code>. Same names as slat and clat, this denotes the time from when fio created the I/O unit to completion of the I/O operation.</p></li><li><p><strong>bw</strong></p><p>Bandwidth statistics based on samples. Same names as the xlat stats, but also includes the number of samples taken (<strong>samples</strong>) and an approximate percentage of total aggregate bandwidth this thread received in its group (<strong>per</strong>). This last value is only really useful if the threads in this group are on the same disk, since they are then competing for disk access.</p></li><li><p><strong>iops</strong></p><p>IOPS statistics based on samples. Same names as bw.</p></li><li><p><strong>lat (nsec/usec/msec)</strong></p><p>The distribution of I/O completion latencies. This is the time from when I/O leaves fio and when it gets completed. Unlike the separate read/write/trim sections above, the data here and in the remaining sections apply to all I/Os for the reporting group. 250=0.04% means that 0.04% of the I/Os completed in under 250us. 500=64.11% means that 64.11% of the I/Os required 250 to 499us for completion.</p></li><li><p><strong>cpu</strong></p><p>CPU usage. User and system time, along with the number of context switches this thread went through, usage of system and user time, and finally the number of major and minor page faults. The CPU utilization numbers are averages for the jobs in that reporting group, while the context and fault counters are summed.</p></li><li><p><strong>IO depths</strong></p><p>The distribution of I/O depths over the job lifetime. The numbers are divided into powers of 2 and each entry covers depths from that value up to those that are lower than the next entry â€“ e.g., 16= covers depths from 16 to 31. Note that the range covered by a depth distribution entry can be different to the range covered by the equivalent submit/complete distribution entry.</p></li><li><p><strong>IO submit</strong></p><p>How many pieces of I/O were submitting in a single submit call. Each entry denotes that amount and below, until the previous entry â€“ e.g., 16=100% means that we submitted anywhere between 9 to 16 I/Os per submit call. Note that the range covered by a submit distribution entry can be different to the range covered by the equivalent depth distribution entry.</p></li><li><p><strong>IO complete</strong></p><p>Like the above submit number, but for completions instead.</p></li><li><p><strong>IO issued rwt</strong></p><p>The number of read/write/trim requests issued, and how many of them were short or dropped.</p></li><li><p><strong>IO latency</strong></p><p>These values are for <code>[latency_target](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-latency-target)</code> and related options. When these options are engaged, this section describes the I/O depth required to meet the specified latency target.</p></li></ul><p>After each client has been listed, the group statistics are printed. They will look like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Run status group 0 (all jobs):
</span></span><span class=line><span class=cl>   READ: bw=20.9MiB/s (21.9MB/s), 10.4MiB/s-10.8MiB/s (10.9MB/s-11.3MB/s), io=64.0MiB (67.1MB), run=2973-3069msec
</span></span><span class=line><span class=cl>  WRITE: bw=1231KiB/s (1261kB/s), 616KiB/s-621KiB/s (630kB/s-636kB/s), io=64.0MiB (67.1MB), run=52747-53223msec
</span></span></code></pre></td></tr></table></div></div><p>For each data direction it prints:</p><ul><li><p><strong>bw</strong></p><p><code>Aggregate bandwidth</code> of threads in this group followed by the minimum and maximum bandwidth of all the threads in this group. Values outside of brackets are power-of-2 format and those within are the equivalent value in a power-of-10 format.</p></li><li><p><strong>io</strong></p><p>Aggregate I/O performed of all threads in this group. The format is the same as bw.</p></li><li><p><strong>run</strong></p><p>The smallest and longest runtimes of the threads in this group.</p></li></ul><p>And finally, the <code>disk statistics</code> are printed. This is Linux specific. They will look like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Disk stats (read/write):
</span></span><span class=line><span class=cl>  sda: ios=16398/16511, merge=30/162, ticks=6853/819634, in_queue=826487, util=100.00%
</span></span></code></pre></td></tr></table></div></div><p>Each value is printed for both reads and writes, with reads first. The numbers denote:</p><ul><li><p><strong>ios</strong></p><p>Number of I/Os performed by all groups.</p></li><li><p><strong>merge</strong></p><p>Number of merges performed by the I/O scheduler.</p></li><li><p><strong>ticks</strong></p><p>Number of ticks we kept the disk busy.</p></li><li><p><strong>in_queue</strong></p><p>Total time spent in the disk queue.</p></li><li><p><strong>util</strong></p><p>The disk utilization. A value of 100% means we kept the disk busy constantly, 50% would be a disk idling half of the time.</p></li></ul><p>It is also possible to get fio to dump the current output while it is running, without terminating the job. To do that, send fio the <strong><code>USR1</code></strong> signal. You can also get regularly timed dumps by using the <code>[--status-interval](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-status-interval)</code> parameter, or by creating a file in <code>/tmp</code> named <code>fio-dump-status</code>. If fio sees this file, it will unlink it and dump the current output status.</p><h2 id=115-terse-output>1.15. Terse output</h2><p>For scripted usage where you typically want to generate <code>tables or graphs</code> of the results, fio can output the results in a semicolon separated format. The format is one long line of values, such as:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>2;card0;0;0;7139336;121836;60004;1;10109;27.932460;116.933948;220;126861;3495.446807;1085.368601;226;126864;3523.635629;1089.012448;24063;99944;50.275485%;59818.274627;5540.657370;7155060;122104;60004;1;8338;29.086342;117.839068;388;128077;5032.488518;1234.785715;391;128085;5061.839412;1236.909129;23436;100928;50.287926%;59964.832030;5644.844189;14.595833%;19.394167%;123706;0;7313;0.1%;0.1%;0.1%;0.1%;0.1%;0.1%;100.0%;0.00%;0.00%;0.00%;0.00%;0.00%;0.00%;0.01%;0.02%;0.05%;0.16%;6.04%;40.40%;52.68%;0.64%;0.01%;0.00%;0.01%;0.00%;0.00%;0.00%;0.00%;0.00%
</span></span><span class=line><span class=cl>A description of this job goes here.
</span></span></code></pre></td></tr></table></div></div><p>The job description (if provided) follows on a second line for terse v2. It appears on the same line for other terse versions.</p><p>To enable terse output, use the <code>[--minimal](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-minimal)</code> or <code>[--output-format](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-output-format)</code>=terse command line options. The first value is the version of the terse output format. If the output has to be changed for some reason, this number will be incremented by 1 to signify that change.</p><p>Split up, the format is as follows (comments in brackets denote when a field was introduced or whether itâ€™s specific to some terse version):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>terse version, fio version <span class=o>[</span>v3<span class=o>]</span>, jobname, groupid, error
</span></span></code></pre></td></tr></table></div></div><p>READ status:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Total IO <span class=o>(</span>KiB<span class=o>)</span>, bandwidth <span class=o>(</span>KiB/sec<span class=o>)</span>, IOPS, runtime <span class=o>(</span>msec<span class=o>)</span>
</span></span><span class=line><span class=cl>Submission latency: min, max, mean, stdev <span class=o>(</span>usec<span class=o>)</span>
</span></span><span class=line><span class=cl>Completion latency: min, max, mean, stdev <span class=o>(</span>usec<span class=o>)</span>
</span></span><span class=line><span class=cl>Completion latency percentiles: <span class=m>20</span> fields <span class=o>(</span>see below<span class=o>)</span>
</span></span><span class=line><span class=cl>Total latency: min, max, mean, stdev <span class=o>(</span>usec<span class=o>)</span>
</span></span><span class=line><span class=cl>Bw <span class=o>(</span>KiB/s<span class=o>)</span>: min, max, aggregate percentage of total, mean, stdev, number of samples <span class=o>[</span>v5<span class=o>]</span>
</span></span><span class=line><span class=cl>IOPS <span class=o>[</span>v5<span class=o>]</span>: min, max, mean, stdev, number of samples
</span></span></code></pre></td></tr></table></div></div><p>WRITE status:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Total IO <span class=o>(</span>KiB<span class=o>)</span>, bandwidth <span class=o>(</span>KiB/sec<span class=o>)</span>, IOPS, runtime <span class=o>(</span>msec<span class=o>)</span>
</span></span><span class=line><span class=cl>Submission latency: min, max, mean, stdev <span class=o>(</span>usec<span class=o>)</span>
</span></span><span class=line><span class=cl>Completion latency: min, max, mean, stdev <span class=o>(</span>usec<span class=o>)</span>
</span></span><span class=line><span class=cl>Completion latency percentiles: <span class=m>20</span> fields <span class=o>(</span>see below<span class=o>)</span>
</span></span><span class=line><span class=cl>Total latency: min, max, mean, stdev <span class=o>(</span>usec<span class=o>)</span>
</span></span><span class=line><span class=cl>Bw <span class=o>(</span>KiB/s<span class=o>)</span>: min, max, aggregate percentage of total, mean, stdev, number of samples <span class=o>[</span>v5<span class=o>]</span>
</span></span><span class=line><span class=cl>IOPS <span class=o>[</span>v5<span class=o>]</span>: min, max, mean, stdev, number of samples
</span></span></code></pre></td></tr></table></div></div><p>TRIM status [all but version 3]:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Fields are similar to READ/WRITE status.
</span></span></code></pre></td></tr></table></div></div><p>CPU usage:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>user, system, context switches, major faults, minor faults
</span></span></code></pre></td></tr></table></div></div><p>I/O depths:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&lt;<span class=o>=</span>1, 2, 4, 8, 16, 32, &gt;<span class=o>=</span><span class=m>64</span>
</span></span></code></pre></td></tr></table></div></div><p>I/O latencies microseconds:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&lt;<span class=o>=</span>2, 4, 10, 20, 50, 100, 250, 500, 750, <span class=m>1000</span>
</span></span></code></pre></td></tr></table></div></div><p>I/O latencies milliseconds:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&lt;<span class=o>=</span>2, 4, 10, 20, 50, 100, 250, 500, 750, 1000, 2000, &gt;<span class=o>=</span><span class=m>2000</span>
</span></span></code></pre></td></tr></table></div></div><p>Disk utilization [v3]:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>disk name, <span class=nb>read</span> ios, write ios, <span class=nb>read</span> merges, write merges, <span class=nb>read</span> ticks, write ticks,
</span></span><span class=line><span class=cl><span class=nb>time</span> spent in queue, disk utilization percentage
</span></span></code></pre></td></tr></table></div></div><p>Additional Info (dependent on continue_on_error, default off):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>total <span class=c1># errors, first error code</span>
</span></span></code></pre></td></tr></table></div></div><p>Additional Info (dependent on description being set):</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Text description
</span></span></code></pre></td></tr></table></div></div><p>Completion latency percentiles can be a grouping of up to 20 sets, so for the terse output fio writes all of them. Each field will look like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>1.00%<span class=o>=</span><span class=m>6112</span>
</span></span></code></pre></td></tr></table></div></div><p>which is the Xth percentile, and the usec latency associated with it.</p><p>For Disk utilization, all disks used by fio are shown. So for each disk there will be a disk utilization section.</p><p>Below is a single line containing short names for each of the fields in the minimal output v3, separated by semicolons:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>terse_version_3;fio_version;jobname;groupid;error;read_kb;read_bandwidth_kb;read_iops;read_runtime_ms;read_slat_min_us;read_slat_max_us;read_slat_mean_us;read_slat_dev_us;read_clat_min_us;read_clat_max_us;read_clat_mean_us;read_clat_dev_us;read_clat_pct01;read_clat_pct02;read_clat_pct03;read_clat_pct04;read_clat_pct05;read_clat_pct06;read_clat_pct07;read_clat_pct08;read_clat_pct09;read_clat_pct10;read_clat_pct11;read_clat_pct12;read_clat_pct13;read_clat_pct14;read_clat_pct15;read_clat_pct16;read_clat_pct17;read_clat_pct18;read_clat_pct19;read_clat_pct20;read_tlat_min_us;read_lat_max_us;read_lat_mean_us;read_lat_dev_us;read_bw_min_kb;read_bw_max_kb;read_bw_agg_pct;read_bw_mean_kb;read_bw_dev_kb;write_kb;write_bandwidth_kb;write_iops;write_runtime_ms;write_slat_min_us;write_slat_max_us;write_slat_mean_us;write_slat_dev_us;write_clat_min_us;write_clat_max_us;write_clat_mean_us;write_clat_dev_us;write_clat_pct01;write_clat_pct02;write_clat_pct03;write_clat_pct04;write_clat_pct05;write_clat_pct06;write_clat_pct07;write_clat_pct08;write_clat_pct09;write_clat_pct10;write_clat_pct11;write_clat_pct12;write_clat_pct13;write_clat_pct14;write_clat_pct15;write_clat_pct16;write_clat_pct17;write_clat_pct18;write_clat_pct19;write_clat_pct20;write_tlat_min_us;write_lat_max_us;write_lat_mean_us;write_lat_dev_us;write_bw_min_kb;write_bw_max_kb;write_bw_agg_pct;write_bw_mean_kb;write_bw_dev_kb;cpu_user;cpu_sys;cpu_csw;cpu_mjf;cpu_minf;iodepth_1;iodepth_2;iodepth_4;iodepth_8;iodepth_16;iodepth_32;iodepth_64;lat_2us;lat_4us;lat_10us;lat_20us;lat_50us;lat_100us;lat_250us;lat_500us;lat_750us;lat_1000us;lat_2ms;lat_4ms;lat_10ms;lat_20ms;lat_50ms;lat_100ms;lat_250ms;lat_500ms;lat_750ms;lat_1000ms;lat_2000ms;lat_over_2000ms;disk_name;disk_read_iops;disk_write_iops;disk_read_merges;disk_write_merges;disk_read_ticks;write_ticks;disk_queue_time;disk_util
</span></span></code></pre></td></tr></table></div></div><p>In client/server mode terse output differs from what appears when jobs are run locally. Disk utilization data is omitted from the standard terse output and for v3 and later appears on its own separate line at the end of each terse reporting cycle.</p><h2 id=116-json-output>1.16. JSON output</h2><p>The <code>json</code> output format is intended to be both human readable and convenient for automated parsing. For the most part its sections mirror those of the normal output. The runtime value is reported in msec and the bw value is reported in 1024 bytes per second units.</p><h2 id=117-json-output>1.17. JSON+ output</h2><p>The json+ output format is identical to the json output format except that it adds a full dump of the completion latency bins. Each bins object contains a set of (key, value) pairs where keys are latency durations and values count how many I/Os had completion latencies of the corresponding duration. For example, consider:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>â€œbinsâ€ : <span class=o>{</span> â€œ87552â€ : 1, â€œ89600â€ : 1, â€œ94720â€ : 1, â€œ96768â€ : 1, â€œ97792â€ : 1, â€œ99840â€ : 1, â€œ100864â€ : 2, â€œ103936â€ : 6, â€œ104960â€ : 534, â€œ105984â€ : 5995, â€œ107008â€ : 7529, â€¦ <span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This data indicates that one I/O required 87,552ns to complete, two I/Os required 100,864ns to complete, and 7529 I/Os required 107,008ns to complete.</p><p>Also included with fio is a Python script <code>fio_jsonplus_clat2csv</code> that takes json+ output and generates CSV-formatted latency data suitable for plotting.</p><p>The latency durations actually represent the midpoints of latency intervals. For details refer to <code>stat.h</code>.</p><h2 id=118-trace-file-format>1.18. Trace file format</h2><p>There are two trace file format that you can encounter. The older (v1) format is unsupported since version 1.20-rc3 (March 2008). It will still be described below in case that you get an old trace and want to understand it.</p><p>In any case the trace is a simple text file with a single action per line.</p><h3 id=1181-trace-file-format-v1>1.18.1. Trace file format v1</h3><p>Each line represents a single I/O action in the following format:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>rw, offset, length
</span></span></code></pre></td></tr></table></div></div><p>where rw=0/1 for read/write, and the offset and length entries being in bytes.</p><p>This format is not supported in fio versions >= 1.20-rc3.</p><h3 id=1182-trace-file-format-v2>1.18.2. Trace file format v2</h3><p>The second version of the trace file format was added in fio version 1.17. It allows to access more then one file per trace and has a bigger set of possible file actions.</p><p>The first line of the trace file has to be:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>fio version 2 iolog
</span></span></code></pre></td></tr></table></div></div><p>Following this can be lines in two different formats, which are described below.</p><p>The <code>file management format</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>filename action
</span></span></code></pre></td></tr></table></div></div><p>The filename is given as an absolute path. The action can be one of these:</p><ul><li><p><strong>add</strong></p><p>Add the given filename to the trace.</p></li><li><p><strong>open</strong></p><p>Open the file with the given filename. The filename has to have been added with the <strong>add</strong> action before.</p></li><li><p><strong>close</strong></p><p>Close the file with the given filename. The file has to have been opened before.</p></li></ul><p>The <code>file I/O action format</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>filename action offset length
</span></span></code></pre></td></tr></table></div></div><p>The filename is given as an absolute path, and has to have been added and opened before it can be used with this format. The offset and length are given in bytes. The action can be one of these:</p><ul><li><p><strong>wait</strong></p><p>Wait for offset microseconds. Everything below 100 is discarded. The time is relative to the previous wait statement.</p></li><li><p><strong>read</strong></p><p>Read length bytes beginning from offset.</p></li><li><p><strong>write</strong></p><p>Write length bytes beginning from offset.</p></li><li><p><strong>sync</strong></p><p><em>fsync(2)</em> the file.</p></li><li><p><strong>datasync</strong></p><p><em>fdatasync(2)</em> the file.</p></li><li><p><strong>trim</strong></p><p>Trim the given file from the given offset for length bytes.</p></li></ul><h2 id=119-io-replay---merging-traces>1.19. I/O Replay - Merging Traces</h2><p>Colocation is a common practice used to get the most out of a machine. Knowing which workloads play nicely with each other and which ones donâ€™t is a much harder task. While fio can replay workloads concurrently via multiple jobs, it leaves some variability up to the scheduler making results harder to <code>reproduce</code>. Merging is a way to make the order of events consistent.</p><p>Merging is integrated into I/O replay and done when a <code>[merge_blktrace_file](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-merge-blktrace-file)</code> is specified. The list of files passed to <code>[read_iolog](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-read-iolog)</code> go through the merge process and output a single file stored to the specified file. The output file is passed on as if it were the only file passed to <code>[read_iolog](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-read-iolog)</code>. An example would look like:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ fio --read_iolog=&#34;&lt;file1&gt;:&lt;file2&gt;&#34; --merge_blktrace_file=&#34;&lt;output_file&gt;&#34;
</span></span></code></pre></td></tr></table></div></div><p>Creating only the merged file can be done by passing the command line argument <code>[--merge-blktrace-only](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-merge-blktrace-only)</code>.</p><p>Scaling traces can be done to see the relative impact of any particular trace being slowed down or sped up. <code>[merge_blktrace_scalars](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-merge-blktrace-scalars)</code> takes in a colon separated list of percentage scalars. It is index paired with the files passed to <code>[read_iolog](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-read-iolog)</code>.</p><p>With scaling, it may be desirable to match the running time of all traces. This can be done with <code>[merge_blktrace_iters](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-merge-blktrace-iters)</code>. It is index paired with <code>[read_iolog](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-read-iolog)</code> just like <code>[merge_blktrace_scalars](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-merge-blktrace-scalars)</code>.</p><p>In an example, given two traces, A and B, each 60s long. If we want to see the impact of trace A issuing IOs twice as fast and repeat trace A over the runtime of trace B, the following can be done:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ fio --read_iolog=&#34;&lt;trace_a&gt;:&#34;&lt;trace_b&gt;&#34; --merge_blktrace_file&#34;&lt;output_file&gt;&#34; --merge_blktrace_scalars=&#34;50:100&#34; --merge_blktrace_iters=&#34;2:1&#34;
</span></span></code></pre></td></tr></table></div></div><p>This runs trace A at 2x the speed twice for approximately the same runtime as a single run of trace B.</p><h2 id=120-cpu-idleness-profiling>1.20. CPU idleness profiling</h2><p>In some cases, we want to understand CPU overhead in a test. For example, we test patches for the specific goodness of whether they reduce CPU usage. Fio implements a <code>balloon approach</code> to create a thread per CPU that runs at idle priority, meaning that it only runs when nobody else needs the cpu. By measuring the amount of work completed by the thread, idleness of each CPU can be derived accordingly.</p><p>An <code>unit work</code> is defined as touching a full page of unsigned characters. Mean and standard deviation of time to complete an unit work is reported in â€œunit workâ€ section. Options can be chosen to report detailed percpu idleness or overall system idleness by aggregating percpu stats.</p><h2 id=121-verification-and-triggers>1.21. Verification and triggers</h2><p>Fio is usually run in one of two ways, when data verification is done. The first is a normal write job of some sort with verify enabled. When the write phase has completed, fio switches to reads and verifies everything it wrote. The second model is running just the write phase, and then later on running the same job (but with reads instead of writes) to repeat the same I/O patterns and verify the contents. Both of these methods depend on the write phase being completed, as fio otherwise has no idea how much data was written.</p><p>With verification triggers, fio supports dumping the current write state to local files. Then a subsequent read verify workload can load this state and know exactly where to stop. This is useful for testing cases where power is cut to a server in a managed fashion, for instance.</p><p>A verification trigger consists of two things:</p><ol><li>Storing the write state of each job.</li><li>Executing a trigger command.</li></ol><p>The write state is relatively small, on the order of hundreds of bytes to single kilobytes. It contains information on the number of completions done, the last X completions, etc.</p><p>A trigger is invoked either through creation (â€˜touchâ€™) of a specified file in the system, or through a timeout setting. If fio is run with <code>[--trigger-file](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-trigger-file)</code>= <code>/tmp/trigger-file</code>, then it will continually check for the existence of <code>/tmp/trigger-file</code>. When it sees this file, it will fire off the trigger (thus saving state, and executing the trigger command).</p><p>For client/server runs, thereâ€™s both a local and remote trigger. If fio is running as a server backend, it will send the job states back to the client for safe storage, then execute the remote trigger, if specified. If a local trigger is specified, the server will still send back the write state, but the client will then execute the trigger.</p><h3 id=1211-verification-trigger-example>1.21.1. Verification trigger example</h3><p>Letâ€™s say we want to run a <code>powercut test</code> on the remote Linux machine â€˜serverâ€™. Our write workload is in <code>write-test.fio</code>. We want to cut power to â€˜serverâ€™ at some point during the run, and weâ€™ll run this test from the safety or our local machine, â€˜localboxâ€™. On the server, weâ€™ll start the fio backend normally:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>server# fio --server
</span></span></code></pre></td></tr></table></div></div><p>and on the client, weâ€™ll fire off the workload:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>localbox$ fio --client=server --trigger-file=/tmp/my-trigger --trigger-remote=&#34;bash -c \&#34;echo b &gt; /proc/sysrq-triger\&#34;&#34;
</span></span></code></pre></td></tr></table></div></div><p>We set <code>/tmp/my-trigger</code> as the trigger file, and we tell fio to execute:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>echo b &gt; /proc/sysrq-trigger
</span></span></code></pre></td></tr></table></div></div><p>on the server once it has received the trigger and sent us the write state. This will work, but itâ€™s not <strong>really</strong> cutting power to the server, itâ€™s merely abruptly rebooting it. If we have a remote way of cutting power to the server through <code>IPMI</code> or similar, we could do that through a local trigger command instead. Letâ€™s assume we have a script that does IPMI reboot of a given hostname, ipmi-reboot. On localbox, we could then have run fio with a local trigger instead:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>localbox$ fio --client=server --trigger-file=/tmp/my-trigger --trigger=&#34;ipmi-reboot server&#34;
</span></span></code></pre></td></tr></table></div></div><p>For this case, fio would wait for the server to send us the write state, then execute <code>ipmi-reboot server</code> when that happened.</p><h3 id=1212-loading-verify-state>1.21.2. Loading verify state</h3><p>To load stored write state, a read verification job file must contain the <code>[verify_state_load](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-verify-state-load)</code> option. If that is set, fio will load the previously stored state. For a local fio run this is done by loading the files directly, and on a client/server run, the server backend will ask the client to send the files over and load them from there.</p><h2 id=122-log-file-formats>1.22. Log File Formats</h2><p>Fio supports a variety of log file formats, for logging latencies, bandwidth, and IOPS. The logs share a common format, which looks like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>time</span> <span class=o>(</span>msec<span class=o>)</span>, value, data direction, block size <span class=o>(</span>bytes<span class=o>)</span>, offset <span class=o>(</span>bytes<span class=o>)</span>, <span class=nb>command</span> priority
</span></span></code></pre></td></tr></table></div></div><p><em><code>Time</code></em> for the log entry is always in milliseconds. The <em><code>value</code></em> logged depends on the type of log, it will be one of the following:</p><p>Latency log</p><p>Value is latency in nsecs</p><p>Bandwidth log</p><p>Value is in KiB/sec</p><p>IOPS log</p><p>Value is IOPS</p><p><em><code>Data direction</code></em> is one of the following:</p><p>0</p><p>I/O is a READ</p><p>1</p><p>I/O is a WRITE</p><p>2</p><p>I/O is a TRIM</p><p>The entryâ€™s <em><code>block size</code></em> is always in bytes. The <em><code>offset</code></em> is the position in bytes from the start of the file for that particular I/O. The logging of the offset can be toggled with <code>[log_offset](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-log-offset)</code>.</p><p><em><code>Command priority</code></em> is 0 for normal priority and 1 for high priority. This is controlled by the ioengine specific <code>[cmdprio_percentage](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-cmdprio-percentage)</code>.</p><p>Fio defaults to logging every individual I/O but when windowed logging is set through <code>[log_avg_msec](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-log-avg-msec)</code>, either the average (by default) or the maximum (<code>[log_max_value](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-arg-log-max-value)</code> is set) <em>value</em> seen over the specified period of time is recorded. Each <em>data direction</em> seen within the window period will aggregate its values in a separate row. Further, when using windowed logging the <em>block size</em> and <em>offset</em> entries will always contain 0.</p><h2 id=123-clientserver>1.23. Client/Server</h2><p>Normally fio is invoked as a stand-alone application on the machine where the I/O workload should be generated. However, the backend and frontend of fio can be run separately i.e., the fio server can generate an I/O workload on the â€œDevice Under Testâ€ while being controlled by a client on another machine.</p><p>Start the server on the machine which has access to the storage DUT:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ fio --server=args
</span></span></code></pre></td></tr></table></div></div><p>where args defines what fio listens to. The arguments are of the form <code>type,hostname</code> or <code>IP,port</code>. <em>type</em> is either <code>ip</code> (or ip4) for TCP/IP v4, <code>ip6</code> for TCP/IP v6, or <code>sock</code> for a local unix domain socket. <em>hostname</em> is either a hostname or IP address, and <em>port</em> is the port to listen to (only valid for TCP/IP, not a local socket). Some examples:</p><ol><li><p><code>fio --server</code></p><p>Start a fio server, listening on all interfaces on the default port (8765).</p></li><li><p><code>fio --server=ip:hostname,4444</code></p><p>Start a fio server, listening on IP belonging to hostname and on port 4444.</p></li><li><p><code>fio --server=ip6:::1,4444</code></p><p>Start a fio server, listening on IPv6 localhost ::1 and on port 4444.</p></li><li><p><code>fio --server=,4444</code></p><p>Start a fio server, listening on all interfaces on port 4444.</p></li><li><p><code>fio --server=1.2.3.4</code></p><p>Start a fio server, listening on IP 1.2.3.4 on the default port.</p></li><li><p><code>fio --server=sock:/tmp/fio.sock</code></p><p>Start a fio server, listening on the local socket <code>/tmp/fio.sock</code>.</p></li></ol><p>Once a server is running, a â€œclientâ€ can connect to the fio server with:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>fio &lt;local-args&gt; --client=&lt;server&gt; &lt;remote-args&gt; &lt;job file(s)&gt;
</span></span></code></pre></td></tr></table></div></div><p>where <code>local-args</code> are arguments for the client where it is running, <code>server</code> is the connect string, and <code>remote-args</code> and <code>job file(s)</code> are sent to the server. The server string follows the same format as it does on the server side, to allow IP/hostname/socket and port strings.</p><p>Fio can connect to multiple servers this way:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>fio --client=&lt;server1&gt; &lt;job file(s)&gt; --client=&lt;server2&gt; &lt;job file(s)&gt;
</span></span></code></pre></td></tr></table></div></div><p>If the job file is located on the fio server, then you can tell the server to load a local file as well. This is done by using <code>[--remote-config](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-remote-config)</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>fio --client=server --remote-config /path/to/file.fio
</span></span></code></pre></td></tr></table></div></div><p>Then fio will open this local (to the server) job file instead of being passed one from the client.</p><p>If you have many servers (example: 100 VMs/containers), you can input a pathname of a file containing host IPs/names as the parameter value for the <code>[--client](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-client)</code> option. For example, here is an example <code>host.list</code> file containing 2 hostnames:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>host1.your.dns.domain
</span></span><span class=line><span class=cl>host2.your.dns.domain
</span></span></code></pre></td></tr></table></div></div><p>The fio command would then be:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>fio --client=host.list &lt;job file(s)&gt;
</span></span></code></pre></td></tr></table></div></div><p>In this mode, you cannot input server-specific parameters or job files â€“ all servers receive the same job file.</p><p>In order to let <code>fio --client</code> runs use a shared filesystem from multiple hosts, <code>fio --client</code> now prepends the IP address of the server to the filename. For example, if fio is using the directory <code>/mnt/nfs/fio</code> and is writing filename <code>fileio.tmp</code>, with a <code>[--client](https://fio.readthedocs.io/en/latest/fio_man.html#cmdoption-client)</code> hostfile containing two hostnames <code>h1</code> and <code>h2</code> with IP addresses 192.168.10.120 and 192.168.10.121, then fio will create two files:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/mnt/nfs/fio/192.168.10.120.fileio.tmp
</span></span><span class=line><span class=cl>/mnt/nfs/fio/192.168.10.121.fileio.tmp
</span></span></code></pre></td></tr></table></div></div><p>Terse output in client/server mode will differ slightly from what is produced when fio is run in stand-alone mode. See the terse output section for details.</p><h1 id=2-examples>2. Examples</h1><p>Some job file examples.</p><h2 id=21-poisson-request-flow>2.1. Poisson request flow</h2><p><code>[Download poisson-rate-submission.fio](https://fio.readthedocs.io/en/latest/_downloads/50da7e704b56933b52dce86ded66a7ee/poisson-rate-submission.fio)</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[poisson-rate-submit]
</span></span><span class=line><span class=cl>size=128m
</span></span><span class=line><span class=cl>rw=randread
</span></span><span class=line><span class=cl>ioengine=libaio
</span></span><span class=line><span class=cl>iodepth=32
</span></span><span class=line><span class=cl>direct=1
</span></span><span class=line><span class=cl># by setting the submit mode to offload, we can guarantee a fixed rate of
</span></span><span class=line><span class=cl># submission regardless of what the device completion rate is.
</span></span><span class=line><span class=cl>io_submit_mode=offload
</span></span><span class=line><span class=cl>rate_iops=50
</span></span><span class=line><span class=cl># Real world random request flow follows Poisson process. To give better
</span></span><span class=line><span class=cl># insight on latency distribution, we simulate request flow under Poisson
</span></span><span class=line><span class=cl># process.
</span></span><span class=line><span class=cl>rate_process=poisson
</span></span></code></pre></td></tr></table></div></div><h2 id=22-latency-profile>2.2. Latency profile</h2><p><code>[Download latency-profile.fio](https://fio.readthedocs.io/en/latest/_downloads/81c88b5b3ff9281d86d79ce3505a7174/latency-profile.fio)</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># Test job that demonstrates how to use the latency target
</span></span><span class=line><span class=cl># profiling. Fio will find the queue depth between 1..128
</span></span><span class=line><span class=cl># that fits within the latency constraints of this 4k random
</span></span><span class=line><span class=cl># read workload.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[global]
</span></span><span class=line><span class=cl>bs=4k
</span></span><span class=line><span class=cl>rw=randread
</span></span><span class=line><span class=cl>random_generator=lfsr
</span></span><span class=line><span class=cl>direct=1
</span></span><span class=line><span class=cl>ioengine=libaio
</span></span><span class=line><span class=cl>iodepth=128
</span></span><span class=line><span class=cl># Set max acceptable latency to 500msec
</span></span><span class=line><span class=cl>latency_target=500000
</span></span><span class=line><span class=cl># profile over a 5s window
</span></span><span class=line><span class=cl>latency_window=5000000
</span></span><span class=line><span class=cl># 99.9% of IOs must be below the target
</span></span><span class=line><span class=cl>latency_percentile=99.9
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[device]
</span></span><span class=line><span class=cl>filename=/dev/sda
</span></span></code></pre></td></tr></table></div></div><h2 id=23-read-4-files-with-aio-at-different-depths>2.3. Read 4 files with aio at different depths</h2><p><code>[Download aio-read.fio](https://fio.readthedocs.io/en/latest/_downloads/139209e14027e06d4c96f8fa88d81179/aio-read.fio)</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>; Read 4 files with aio at different depths
</span></span><span class=line><span class=cl>[global]
</span></span><span class=line><span class=cl>ioengine=libaio
</span></span><span class=line><span class=cl>buffered=0
</span></span><span class=line><span class=cl>rw=randread
</span></span><span class=line><span class=cl>bs=128k
</span></span><span class=line><span class=cl>size=512m
</span></span><span class=line><span class=cl>directory=/data1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[file1]
</span></span><span class=line><span class=cl>iodepth=4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[file2]
</span></span><span class=line><span class=cl>iodepth=32
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[file3]
</span></span><span class=line><span class=cl>iodepth=8
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[file4]
</span></span><span class=line><span class=cl>iodepth=16
</span></span></code></pre></td></tr></table></div></div><h2 id=24-read-backwards-in-a-file>2.4. Read backwards in a file</h2><p><code>[Download backwards-read.fio](https://fio.readthedocs.io/en/latest/_downloads/de396f97c3a45bf2908a925fb0f422fd/backwards-read.fio)</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># Demonstrates how to read backwards in a file.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[backwards-read]
</span></span><span class=line><span class=cl>bs=4k
</span></span><span class=line><span class=cl># seek -8k back for every IO
</span></span><span class=line><span class=cl>rw=read:-8k
</span></span><span class=line><span class=cl>filename=128m
</span></span><span class=line><span class=cl>size=128m
</span></span></code></pre></td></tr></table></div></div><h2 id=25-basic-verification>2.5. Basic verification</h2><p><code>[Download basic-verify.fio](https://fio.readthedocs.io/en/latest/_downloads/d47a6c0cc1b48a7d5c490427a7c2a34a/basic-verify.fio)</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># The most basic form of data verification. Write the device randomly
</span></span><span class=line><span class=cl># in 4K chunks, then read it back and verify the contents.
</span></span><span class=line><span class=cl>[write-and-verify]
</span></span><span class=line><span class=cl>rw=randwrite
</span></span><span class=line><span class=cl>bs=4k
</span></span><span class=line><span class=cl>direct=1
</span></span><span class=line><span class=cl>ioengine=libaio
</span></span><span class=line><span class=cl>iodepth=16
</span></span><span class=line><span class=cl>verify=crc32c
</span></span><span class=line><span class=cl># Use /dev/XXX. For running this on a file instead, remove the filename
</span></span><span class=line><span class=cl># option and add a size=32G (or whatever file size you want) instead.
</span></span><span class=line><span class=cl>filename=/dev/XXX
</span></span></code></pre></td></tr></table></div></div><h2 id=26-fixed-rate-submission>2.6. Fixed rate submission</h2><p><code>[Download fixed-rate-submission.fio](https://fio.readthedocs.io/en/latest/_downloads/0f45c5d56d864b9b3480b331a893a0cb/fixed-rate-submission.fio)</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[fixed-rate-submit]
</span></span><span class=line><span class=cl>size=128m
</span></span><span class=line><span class=cl>rw=read
</span></span><span class=line><span class=cl>ioengine=libaio
</span></span><span class=line><span class=cl>iodepth=32
</span></span><span class=line><span class=cl>direct=1
</span></span><span class=line><span class=cl># by setting the submit mode to offload, we can guarantee a fixed rate of
</span></span><span class=line><span class=cl># submission regardless of what the device completion rate is.
</span></span><span class=line><span class=cl>io_submit_mode=offload
</span></span><span class=line><span class=cl>rate_iops=1000
</span></span></code></pre></td></tr></table></div></div><h2 id=27-butterfly-seek-pattern>2.7. Butterfly seek pattern</h2><p><code>[Download butterfly.fio](https://fio.readthedocs.io/en/latest/_downloads/37e161c01718d93a7bc880140814d19e/butterfly.fio)</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># Perform a butterfly/funnel seek pattern. This won&#39;t always alternate ends on
</span></span><span class=line><span class=cl># every I/O but it will get close.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[global]
</span></span><span class=line><span class=cl>filename=/tmp/testfile
</span></span><span class=line><span class=cl>bs=4k
</span></span><span class=line><span class=cl>direct=1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[forward]
</span></span><span class=line><span class=cl>rw=read
</span></span><span class=line><span class=cl>flow=2
</span></span><span class=line><span class=cl># Uncomment the size= and offset= lines to prevent each direction going past
</span></span><span class=line><span class=cl># the middle of the file
</span></span><span class=line><span class=cl>#size=50%
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[backward]
</span></span><span class=line><span class=cl>rw=read:-8k
</span></span><span class=line><span class=cl>flow=2
</span></span><span class=line><span class=cl>#offset=50%
</span></span></code></pre></td></tr></table></div></div><h1 id=3-todo>3. TODO</h1><h2 id=31-gfio-todo>3.1. GFIO TODO</h2><p>In no particular order:</p><ul><li>Ability to save job files. Probably in an extended gfio format, so we can include options/settings outside of a fio job file.</li><li>End view improvements:<ul><li>Cleanup the layout</li><li>Add ability to save the results</li><li>Add ability to load end-results as well</li><li>Add ability to request graphs of whatever graphing options the fio job included.</li><li>Add ability to graph completion latencies, percentiles, etc.</li></ul></li><li>Add ability to edit job options:<ul><li>We need an options view after sending a job, that allows us to visually see what was parsed, make changes, resubmit.</li><li>Job options are already converted across the network and are available in gfio_client->o for view/edit. Weâ€™ll need a FIO_NET_CMD_UPDATE_OPTIONS command to send them back, and backend support for updating an existing set of options.</li></ul></li><li>Add support for printing end results, graphs, etc.</li><li>Improve the auto-start backend functionality, itâ€™s quite buggy.</li><li>Ensure that it works on OSX and Windows. Weâ€™ll need a bit of porting work there.</li><li>Persistent store of prefences set. This will need a per-OS bit as well, using <code>gfonf</code> on Linux, registry on Windows, ?? on OSX.</li><li>Ensure that local errors go to our log, instead of being displayed on the console.</li><li>Ensure that the whole connect/send/start button logic is sane. Right now it works when you perform the right sequence, but if you connect and disconnect, things can get confused. Weâ€™ll need to improve how we store and send job files. Right now they are in ge->job_files[] and are always emptied on send. Keep them around?</li><li>Commit rate display is not enabled.</li><li>Group status reporting is not enabled.</li><li>Split gfio.c a bit. Add gfio/ sub directory, and split it into files based on functionality. Itâ€™s already ~3000 lines long.</li><li>Attempt to ensure that we work with gtk 2.10 and newer. Right now the required version is ~2.18 (not quite known).</li></ul><h2 id=32-server-todo>3.2. Server TODO</h2><ul><li>Collate ETA output from multiple connections into 1</li><li>If <code>group_reporting</code> is set, collate final output from multiple connections</li></ul><h2 id=33-steady-state-todo>3.3. Steady State TODO</h2><p>Known issues/TODO (for steady-state)</p><ul><li>Allow user to specify the <code>frequency of measurements</code></li><li>Better documentation for output</li><li>Report read, write, trim IOPS/BW separately</li><li>Semantics for the ring buffer <code>ss->head</code> are confusing. ss->head points to the beginning of the buffer up through the point where the buffer is filled for the first time. afterwards, when a new element is added, ss->head is advanced to point to the second element in the buffer. if steady state is attained upon adding a new element, ss->head is not advanced so it actually does point to the head of the buffer.</li></ul><h1 id=4-moral-license>4. Moral License</h1><p>As specified by the <code>COPYING</code> file, fio is free software published under version 2 of the GPL license. That covers the copying part of the license. When using fio, you are encouraged to uphold the following moral obligations:</p><ul><li>If you publish results that are done using fio, it should be clearly stated that fio was used. The specific version should also be listed.</li><li>If you develop features or bug fixes for fio, they should be sent upstream for inclusion into the main repository. This isnâ€™t specific to fio, that is a general rule for any open source project. Itâ€™s just the Right Thing to do. Plus it means that you donâ€™t have to maintain the feature or change internally. In the long run, this is saving you a lot of time.</li></ul><p>I would consider the above to fall under â€œcommon courtesyâ€, but since people tend to have differing opinions of that, it doesnâ€™t hurt to spell out my expectations clearly.</p><h1 id=5-license>5. License</h1><p><a href=/quartz/wiki/wiki/storage/fio-wiki/1-fio-Flexible-IO-tester-rev-3-25-0f270069ce274f55b1a66853bd856c77/GPL-v2-da87a961088a40a3bba482960fbba797 rel=noopener class=internal-link data-src=/quartz/wiki/wiki/storage/fio-wiki/1-fio-Flexible-IO-tester-rev-3-25-0f270069ce274f55b1a66853bd856c77/GPL-v2-da87a961088a40a3bba482960fbba797>GPL v2</a></p><h1 id=ç–‘é—®>ç–‘é—®</h1><ul><li>fioå¤šä¸ªjobå†™å‘åŒä¸€ä¸ªfileï¼Œæ˜¯å¦‚ä½•å¤„ç†çš„ï¼Ÿ</li><li>å¦‚ä½•ç†è§£<code>random_generator</code>ï¼Ÿ</li><li>1.21 verification triggerä¸æ˜¯å¾ˆæ˜ç™½ã€‚</li></ul><h1 id=ç†è§£>ç†è§£</h1><ul><li>fioæµ‹è¯•çš„ç»“æŸ<ul><li>é»˜è®¤write amountè¾¾åˆ°sizeæ—¶é€€å‡ºï¼›</li><li>å¯ä»¥æ ¹æ®è¿è¡Œæ—¶é—´runtimeé€€å‡ºï¼›</li><li>å¯ä»¥æ ¹æ®IOé‡æ¥é€€å‡ºï¼Œæ¯”å¦‚io_size/io_limitï¼ˆæ“ä½œé‡ï¼Œæ¯”å¦‚5GiBï¼‰ï¼Œnumber_iosï¼ˆioæ•°é‡ï¼‰</li></ul></li></ul></article><hr><div class=page-end><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div></div><div id=contact_buttons><footer><p>Made by Jacky Zhao using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, Â© 2022</p><ul><li><a href=/>Home</a></li><li><a href=https://twitter.com/_jzhao>Twitter</a></li><li><a href=https://github.com/jackyzha0>Github</a></li></ul></footer></div><script src=https://lzyerste.github.io/quartz/js/popover.e57188d2e4c06b0654e020b3a734bb62.min.js></script>
<script>initPopover("https://lzyerste.github.io/quartz")</script></div></body></html>