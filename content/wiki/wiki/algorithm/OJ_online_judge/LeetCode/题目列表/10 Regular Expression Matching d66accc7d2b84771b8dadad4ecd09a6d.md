---
title: 10_Regular_Expression_Matching_d66accc7d2b84771b8dadad4ecd09a6d
---

# 10. Regular Expression Matching

Difficulty: Hard
ID: 10
Solved?: Yes
Tags: Backtracking, DP, String
击败: 98.08
推荐指数: ⭐⭐⭐⭐⭐

[Regular Expression Matching - LeetCode](https://leetcode.com/problems/regular-expression-matching/)

## 题意

给定一个字符串 (`s`) 和一个字符模式 (`p`)。实现支持 `'.'` 和 `'*'` 的正则表达式匹配。

```
'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
```

匹配应该覆盖**整个**字符串 (`s`) ，而不是部分字符串。

**说明:**

- `s` 可能为空，且只包含从 `a-z` 的小写字母。
- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `.` 和 `*`。

示例 1:

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

示例 2:

```
输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。
```

示例 3:

```
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。
```

示例 4:

```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。
```

示例 5:

```
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```

## 思路

- 动态规划，s与p在前面匹配的情况一起往右走。实际上，从右往前归约比较好写。
- 回溯？
- 模拟正则表达式（strings）

## 题解1：DP

针对s与p，从后往前归约。需要特殊处理的是星号`*`，它需要往前再看一个字符，可以它可以表示出现0次或多次。点号`.`很好处理，它实实在在占据一个字符，只是充当万能字符。

> 比如c*，如果从左往右扫描，先遇到c，还需要判断c的后面是不是星号，比较麻烦。如果是从右往左扫描，就会先遇到*，然后就知道它前面肯定还有个正常字符；如果是普通字符，那么就能明确它仅仅作为普通字符，不会与*搭配。
> 

举例，s为`aab`，p为`c*a*b`。

查看s与p的各自最末字符，p的最右是常规字符b，那么直接比较这两个字符，都是b，匹配，s和p各自往左走一步，s → s[:-1]，为aa；p → p[:-1]，为c*a*。

这时候p的最末字符是特殊字符*，再前一个字符是a。针对星号*的处理，有两种可能情况：

1. *表示使用0次，不参与匹配，那么归约后，s保持不变，p往前走2步（丢弃a*）。s变为aa，p变为c*，这种情况下最后结果是False。
2. *表示使用多次（至少1次），本次必须参与匹配，a与a匹配。那么归约后，s往前走1步，p保持不变（因为*在这里表示使用多次，现在只使用了一次，在归约子问题中可以继续使用。在子问题中可以表示使用0次，那么合计就是使用了1次）。s变为a，p仍然为c*a*。
    1. 同理，继续处理p最末的星号。成功的一条途径是继续使用a*来匹配a，那么，接下来s变为空串，p仍然为c*a*，这时候a*与c*都消费0次即可，归约为s与p都是空串，返回True。

情况1和情况2是并列的，要对它们的结果取OR操作。

边界情况处理见代码（s或p为空串）。

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        def match(a, b):
            return a == b or "." in {a, b}  # 两个字符是否匹配

        def dp(G, s, p):
            z = s, p
            if z in G:
                return G[z]  # memorization
            if not p:  # p is ""
                return s == ""
            if not s:  # s is ""
                if p[-1] == "*":  # p是否可归约为空串
                    return dp(G, s, p[:-2])
                return False
            # now s and p both are not empty
            if p[-1] == "*":
                # or之前表示丢弃*，使用0次，s不变，p前进2步
                # or之后表示消费*，在匹配的情况下，继续归约。s前进1步，p不变。
                G[z] = dp(G, s, p[:-2]) or (match(p[-2], s[-1]) and dp(G, s[:-1], p))
            else:
                # 常规匹配一个字符，若匹配，则各自前进1步
                G[z] = match(p[-1], s[-1]) and dp(G, s[:-1], p[:-1])
            return G[z]
        
        return dp({}, s, p)
```

击败98.08%

## 题解2：状态机实现正则表达式？

查看LeetCode上的提交记录。

Jupyter笔记。

将pattern转化为NFA，状态间支持空转移。

从初始状态出发，根据空转移得到可达集合，然后消耗字符串一个字符，集合内的状态加上这个字符，可以到达哪些状态，得到下一个集合，这个集合也要扩充为空转移可达集合。

最后，消耗完所有字符后，看最终状态是否在集合中。